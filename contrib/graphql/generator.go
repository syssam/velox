// Package graphql provides GraphQL code generation for Velox schemas.
//
// This package generates GraphQL schema (SDL), Go models, and resolver stubs
// compatible with gqlgen. It follows the patterns established by ent-contrib/entgql.
//
// # Basic Usage
//
// Most settings are controlled per-entity via schema annotations. The extension
// only needs global settings like the gqlgen.yml path:
//
//	import "github.com/syssam/velox/contrib/graphql"
//
//	ex, err := graphql.NewExtension(
//	    graphql.WithConfigPath("./gqlgen.yml"),  // Enable auto model binding
//	)
//	// OutDir, Package, ORMPackage are auto-inferred from graph.Config
//	err = graphql.Generate(graph, ex.Config())
//
// # Per-Entity Control via Schema Annotations
//
// Features like RelayConnection, Mutations, Ordering are enabled by default
// and can be controlled per-entity using schema annotations:
//
//	func (User) Annotations() []velox.Annotation {
//	    return []velox.Annotation{
//	        graphql.RelayConnection(),              // Enable Relay connections
//	        graphql.Mutations(                      // Control mutations
//	            graphql.MutationCreate(),
//	            graphql.MutationUpdate(),
//	        ),
//	        graphql.Skip(graphql.SkipWhereInput),   // Skip WhereInput generation
//	    }
//	}
//
// # Direct Config Usage
//
// For direct config usage without the extension:
//
//	err := graphql.Generate(graph, graphql.Config{
//	    OutDir:     "./velox",
//	    ORMPackage: "myapp/velox",
//	    // All features enabled by default
//	})
//
// Generated output structure (following entgql patterns):
//
//	{output}/
//	├── schema.graphql       # GraphQL SDL schema
//	├── schema/              # (if SplitSchema enabled)
//	│   ├── types.graphql       # Entity types
//	│   ├── inputs.graphql      # Input types (WhereInput, OrderBy, mutations)
//	│   ├── connections.graphql # Relay connection types
//	│   └── scalars.graphql     # Custom scalars
//	├── gql_where_input.go   # WhereInput to predicate converters
//	├── gql_node.go          # Relay Node interface implementation
//	├── gql_node_resolver.go # Node query resolver
//	├── gql_collection.go    # Field collection for eager loading
//	├── gql_edge.go          # Edge resolvers
//	├── gql_pagination.go    # Relay cursor pagination
//	└── gql_transaction.go   # Transaction middleware
//
// Note: The following are handled by gqlgen or external libraries:
//   - gqlgen.yml: User creates their own gqlgen config
//   - models_gen.go, resolvers.go: generated by gqlgen
//   - Enum marshalers: gqlgen handles with model binding
//   - Complexity calculation: gqlgen has built-in support
//   - DataLoaders: use graph-gophers/dataloader
//   - Error handling: use gqlgen's gqlerror package
package graphql

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"runtime"
	"slices"
	"strings"

	"github.com/dave/jennifer/jen"
	"golang.org/x/sync/errgroup"

	"github.com/syssam/velox/compiler/gen"
	"github.com/syssam/velox/schema/field"
)

// Config holds GraphQL generation configuration.
//
// Most options are global defaults that can be overridden per-entity using
// schema annotations (graphql.RelayConnection, graphql.Mutations, etc.).
type Config struct {
	// OutDir is the output directory for generated Go files (gql_*.go).
	// Auto-inferred from graph.Config.Target if not set.
	OutDir string

	// SchemaOutDir is the output directory for GraphQL schema files (.graphql).
	// If not set, defaults to OutDir.
	SchemaOutDir string

	// SchemaFilename is the name of the generated schema file.
	// Default: "schema.graphql". Set via WithSchemaPath().
	SchemaFilename string

	// Package is the Go package name for generated code.
	// Auto-inferred from graph.Config.Package if not set.
	Package string

	// ORMPackage is the import path of the generated ORM package.
	// Auto-inferred from graph.Config.Package if not set.
	ORMPackage string

	// SplitSchema splits schema into multiple files (types, inputs, connections).
	SplitSchema bool

	// --- Global defaults (typically controlled per-entity via annotations) ---

	// RelayConnection enables Relay-style cursor connections globally.
	// Default: true. Per-entity: graphql.RelayConnection() annotation.
	RelayConnection bool

	// WhereInputs enables WhereInput filter generation globally.
	// Default: true. Per-entity: graphql.Skip(graphql.SkipWhereInput).
	WhereInputs bool

	// Mutations enables mutation generation globally.
	// Default: true. Per-entity: graphql.Mutations() annotation.
	Mutations bool

	// Ordering enables OrderBy enum generation globally.
	// Default: true. Per-entity: graphql.Skip(graphql.SkipOrderField).
	Ordering bool

	// RelaySpec enables Relay specification support (Node interface, connections, etc.).
	// Default: true. Per-entity: graphql.Skip(graphql.SkipType).
	RelaySpec bool

	// --- Advanced options ---

	// MapScalarFunc is an optional function that maps a field to a custom GraphQL scalar.
	// If the function returns an empty string, the default scalar mapping is used.
	// This follows Ent's entgql.WithMapScalarFunc pattern.
	MapScalarFunc func(*gen.Type, *gen.Field) string

	// SchemaGenerator enables GraphQL schema file generation (.graphql files).
	// When false, only Go files are generated.
	// Default: false. Use WithSchemaGenerator() to enable.
	SchemaGenerator bool
}

// Generator generates GraphQL schema and code from Velox schemas.
type Generator struct {
	graph   *gen.Graph
	config  Config
	workers int

	// samePackage is true when generating into the same package as the ORM
	// In this case, we use unqualified type references instead of imports
	samePackage bool
}

// NewGenerator creates a new GraphQL generator.
func NewGenerator(g *gen.Graph, cfg Config) *Generator {
	// Auto-infer from graph.Config if not set
	if g.Config != nil {
		if cfg.OutDir == "" {
			cfg.OutDir = g.Config.Target
		}
		if cfg.ORMPackage == "" {
			cfg.ORMPackage = g.Config.Package
		}
		if cfg.Package == "" {
			// Extract package name from path (e.g., "myapp/velox" -> "velox")
			parts := strings.Split(g.Config.Package, "/")
			cfg.Package = parts[len(parts)-1]
		}
	}
	if cfg.Package == "" {
		cfg.Package = "graphql"
	}

	// Detect if we're generating into the same package as the ORM
	// This happens when the package name matches the last segment of ORMPackage
	samePackage := false
	if cfg.ORMPackage != "" {
		parts := strings.Split(cfg.ORMPackage, "/")
		ormPkgName := parts[len(parts)-1]
		samePackage = cfg.Package == ormPkgName
	}

	return &Generator{
		graph:       g,
		config:      cfg,
		workers:     runtime.GOMAXPROCS(0),
		samePackage: samePackage,
	}
}

// useGenericPredicates returns true if generic predicates should be used.
// By default, generic predicates are enabled (user.Where.Email.EQ(v)).
// Returns false only if FeatureEntPredicates is enabled (user.EmailEQ(v)).
func (g *Generator) useGenericPredicates() bool {
	if g.graph.Config == nil {
		return true // Default to generic predicates
	}
	entPredicates, err := g.graph.Config.FeatureEnabled("sql/entpredicates")
	if err != nil {
		return true // Default to generic predicates
	}
	return !entPredicates // Use generic unless Ent predicates are enabled
}

// Generate generates all GraphQL artifacts.
func (g *Generator) Generate(ctx context.Context) error {
	if err := os.MkdirAll(g.config.OutDir, 0o755); err != nil {
		return fmt.Errorf("create output directory: %w", err)
	}

	errg, _ := errgroup.WithContext(ctx)
	errg.SetLimit(g.workers)

	// Generate GraphQL SDL schema (only if SchemaGenerator is enabled)
	if g.config.SchemaGenerator {
		schemaFilename := g.config.SchemaFilename
		if schemaFilename == "" {
			schemaFilename = "schema.graphql"
		}
		if g.config.SplitSchema {
			errg.Go(func() error { return g.writeSchema(g.genTypesSchema(), "schema", "types.graphql") })
			errg.Go(func() error { return g.writeSchema(g.genInputsSchema(), "schema", "inputs.graphql") })
			errg.Go(func() error { return g.writeSchema(g.genConnectionsSchema(), "schema", "connections.graphql") })
			errg.Go(func() error { return g.writeSchema(g.genScalarsSchema(), "schema", "scalars.graphql") })
			errg.Go(func() error { return g.writeSchema(g.genRootSchema(), "", schemaFilename) })
		} else {
			errg.Go(func() error { return g.writeSchema(g.genFullSchema(), "", schemaFilename) })
		}
	}

	// Note: models_gen.go and resolvers.go are generated by gqlgen, not here

	// Generate WhereInput Go structs with P() and Filter() methods (like entgql's gql_where_input.go)
	// This generates the Go structs; the SDL is generated in the schema
	if g.config.WhereInputs && g.config.ORMPackage != "" {
		if f := g.genWhereInputGo(); f != nil {
			errg.Go(func() error { return g.writeFile(f, "gql_where_input.go") })
		}
	}

	// Generate Relay Node implementation (like entgql's gql_node.go)
	// Node descriptor (Node, Field, Edge structs) is included in gql_node.go like Ent
	if g.config.RelaySpec {
		errg.Go(func() error { return g.writeFile(g.genNode(), "gql_node.go") })
	}

	// Generate field collection utilities (like entgql's gql_collection.go)
	if g.config.ORMPackage != "" {
		if f := g.genCollection(); f != nil {
			errg.Go(func() error { return g.writeFile(f, "gql_collection.go") })
		}

		// Generate edge resolvers (like entgql's gql_edge.go)
		if f := g.genEdgeResolvers(); f != nil {
			errg.Go(func() error { return g.writeFile(f, "gql_edge.go") })
		}

		// Generate pagination utilities (Relay cursor connections)
		if g.config.RelayConnection {
			if f := g.genPagination(); f != nil {
				errg.Go(func() error { return g.writeFile(f, "gql_pagination.go") })
			}
		}

		// Generate mutation input structs (like entgql's gql_mutation_input.go)
		// These provide Go structs with Mutate() method for applying inputs to mutations
		if g.config.Mutations {
			if f := g.genMutationInput(); f != nil {
				errg.Go(func() error { return g.writeFile(f, "gql_mutation_input.go") })
			}
		}

		// Note: Enum MarshalGQL/UnmarshalGQL is generated by ORM generator into entity files
		// (like Ent's enum.tmpl which embeds into entity files, not a separate gql_enum.go)

		// Note: Transaction utilities (txCtxKey, TxFromContext, NewTxContext) are already
		// generated by the ORM generator in velox.go, so we don't generate gql_transaction.go
	}

	// Generate scalar marshalers for typed JSON fields defined in the schema
	// This generates Marshal/Unmarshal functions so gqlgen can auto-handle these types
	// Note: For third-party types like decimal.Decimal, users should define their own scalars
	if g.config.ORMPackage != "" && len(g.collectTypedJSONScalars()) > 0 {
		errg.Go(func() error { return g.writeFile(g.genScalars(), "gql_scalars.go") })
	}

	// Note: The following are handled by gqlgen or external libraries:
	// - gqlgen.yml: User creates their own gqlgen config
	// - Complexity: gqlgen has built-in complexity support
	// - DataLoaders: Use graph-gophers/dataloader or similar
	// - Error handling: Use gqlgen's gqlerror package

	return errg.Wait()
}

// Generate is a convenience function to generate GraphQL code.
func Generate(g *gen.Graph, cfg Config) error {
	gen := NewGenerator(g, cfg)
	return gen.Generate(context.Background())
}

// =============================================================================
// Schema generation
// =============================================================================

// genFullSchema generates the complete GraphQL schema as a single file.
func (g *Generator) genFullSchema() string {
	var buf bytes.Buffer

	// Write header
	buf.WriteString("# Code generated by velox. DO NOT EDIT.\n\n")

	// Scalars
	buf.WriteString(g.genScalarsSchema())
	buf.WriteString("\n")

	// Node interface (Relay)
	if g.config.RelaySpec {
		buf.WriteString(g.genNodeInterface())
		buf.WriteString("\n")
	}

	// Entity types
	buf.WriteString(g.genTypesSchema())
	buf.WriteString("\n")

	// Input types
	if g.config.WhereInputs || g.config.Mutations || g.config.Ordering {
		buf.WriteString(g.genInputsSchema())
		buf.WriteString("\n")
	}

	// Connection types (Relay)
	if g.config.RelayConnection {
		buf.WriteString(g.genConnectionsSchema())
		buf.WriteString("\n")
	}

	// Query and Mutation types
	buf.WriteString(g.genQueryType())
	buf.WriteString("\n")

	if g.config.Mutations {
		buf.WriteString(g.genMutationType())
	}

	return buf.String()
}

// genRootSchema generates the root schema file that imports other files.
func (g *Generator) genRootSchema() string {
	var buf bytes.Buffer
	buf.WriteString("# Code generated by velox. DO NOT EDIT.\n\n")
	buf.WriteString("# This schema imports types from the schema/ directory.\n")
	buf.WriteString("# Use gqlgen's schema glob to include all files.\n\n")

	buf.WriteString(g.genQueryType())
	buf.WriteString("\n")

	if g.config.Mutations {
		buf.WriteString(g.genMutationType())
	}

	return buf.String()
}

// typedJSONScalar holds information about a typed JSON scalar.
type typedJSONScalar struct {
	ScalarName  string // GraphQL scalar name (e.g., "Address")
	GoType      string // Full Go type path for @goModel (e.g., "example.com/shop/velox.Address")
	OrigPkgPath string // Original package path (e.g., "example.com/shop/schema")
	TypeName    string // Type name without package (e.g., "Address")
}

// collectTypedJSONScalars collects all unique typed JSON fields that need custom scalars.
// Returns a map from Go type identifier to scalar info.
func (g *Generator) collectTypedJSONScalars() map[string]typedJSONScalar {
	scalars := make(map[string]typedJSONScalar)

	for _, t := range g.graph.Nodes {
		for _, f := range t.Fields {
			if !f.IsJSON() || !f.HasGoType() {
				continue
			}
			if f.Type == nil || f.Type.Ident == "" {
				continue
			}

			// Skip fields with SkipAll annotation - they're not exposed in GraphQL
			ann := g.getFieldAnnotation(f)
			if ann.Skip&SkipAll != 0 {
				continue
			}

			// Skip fields with explicit graphql.Type() annotation - user controls the type
			// e.g., graphql.Type("[Permission!]") means Permission is defined elsewhere
			if ann.Type != "" {
				continue
			}

			ident := f.Type.Ident

			// Handle slice types - extract element type for custom scalar registration
			// e.g., "[]schema.Address" or "[]*schema.Address" -> "schema.Address"
			if strings.HasPrefix(ident, "[]") {
				elemType := strings.TrimPrefix(ident, "[]")
				elemType = strings.TrimPrefix(elemType, "*")

				// Skip primitives - they don't need scalar registration
				if g.isPrimitiveGoType(elemType) {
					continue
				}

				// Skip nested slices, maps, and generic types
				if strings.HasPrefix(elemType, "[]") ||
					strings.HasPrefix(elemType, "map[") ||
					elemType == "interface{}" ||
					elemType == "any" {
					continue
				}

				// Use element type for scalar registration
				ident = elemType
			}

			// Skip maps and generic types
			if strings.HasPrefix(ident, "map[") ||
				ident == "interface{}" ||
				ident == "any" {
				continue
			}

			// Create scalar name from type name
			// e.g., "schema.Address" → "Address", "*schema.Address" → "Address"
			scalarName := ident
			scalarName = strings.TrimPrefix(scalarName, "*")
			if idx := strings.LastIndex(scalarName, "."); idx >= 0 {
				scalarName = scalarName[idx+1:]
			}

			// Extract original package path and type name
			origPkgPath := f.Type.PkgPath
			typeName := strings.TrimPrefix(f.Type.Ident, "*")
			if idx := strings.LastIndex(typeName, "."); idx >= 0 {
				typeName = typeName[idx+1:]
			}

			// The @goModel directive must point to the ORM package where we generate the type alias
			// and marshalers, not the original type's package
			// e.g., "example.com/shop/velox.Address" instead of "example.com/shop/schema.Address"
			goType := g.config.ORMPackage + "." + scalarName

			// Use original type path as key to handle same-named types from different packages
			key := origPkgPath + "." + typeName
			if _, exists := scalars[key]; !exists {
				scalars[key] = typedJSONScalar{
					ScalarName:  scalarName,
					GoType:      goType,
					OrigPkgPath: origPkgPath,
					TypeName:    typeName,
				}
			}
		}
	}

	return scalars
}

// getTypedJSONScalarName returns the custom scalar name for a typed JSON field,
// or empty string if it's a generic JSON field.
func (g *Generator) getTypedJSONScalarName(f *gen.Field) string {
	if !f.IsJSON() || !f.HasGoType() {
		return ""
	}
	if f.Type == nil || f.Type.Ident == "" {
		return ""
	}

	// Skip generic JSON types
	ident := f.Type.Ident
	if strings.HasPrefix(ident, "map[") ||
		strings.HasPrefix(ident, "[]") ||
		ident == "interface{}" ||
		ident == "any" {
		return ""
	}

	// Get scalar name
	scalarName := ident
	scalarName = strings.TrimPrefix(scalarName, "*")
	if idx := strings.LastIndex(scalarName, "."); idx >= 0 {
		scalarName = scalarName[idx+1:]
	}

	return scalarName
}

// inferGraphQLSliceType returns the GraphQL list type for a JSON slice field.
// Returns empty string if the type cannot be inferred (maps, nested slices, etc).
// Examples:
//
//	[]string     -> [String!]
//	[]int        -> [Int!]
//	[]*Address   -> [Address!]
//	map[string]any -> "" (no inference)
func (g *Generator) inferGraphQLSliceType(f *gen.Field) string {
	if f.Type == nil || f.Type.Ident == "" {
		return ""
	}

	ident := f.Type.Ident

	// Check both string prefix and RType.Kind for robust slice detection (like Ent)
	isSlice := strings.HasPrefix(ident, "[]")
	if f.Type.RType != nil {
		isSlice = isSlice || f.Type.RType.Kind == reflect.Slice || f.Type.RType.Kind == reflect.Array
	}
	if !isSlice {
		return ""
	}

	// Extract element type: "[]T" or "[]*T" -> "T"
	elemType := strings.TrimPrefix(ident, "[]")
	elemType = strings.TrimPrefix(elemType, "*")

	// Skip nested slices, maps, and generic types
	if strings.HasPrefix(elemType, "[]") ||
		strings.HasPrefix(elemType, "map[") ||
		elemType == "interface{}" ||
		elemType == "any" {
		return ""
	}

	// Map Go type to GraphQL type
	gqlType := g.goTypeToGraphQL(elemType)
	if gqlType == "" {
		return ""
	}

	return "[" + gqlType + "!]"
}

// goTypeToGraphQL maps a Go element type to GraphQL scalar type.
func (g *Generator) goTypeToGraphQL(goType string) string {
	switch goType {
	case "string":
		return "String"
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64":
		return "Int"
	case "float32", "float64":
		return "Float"
	case "bool":
		return "Boolean"
	case "time.Time":
		return "Time"
	}

	// UUID types
	if goType == "uuid.UUID" || strings.HasSuffix(goType, ".UUID") {
		return "UUID"
	}

	// Custom struct types: "pkg.Type" -> "Type"
	if strings.Contains(goType, ".") {
		parts := strings.Split(goType, ".")
		return parts[len(parts)-1]
	}

	// Simple custom type (PascalCase = likely a struct)
	if goType != "" && goType[0] >= 'A' && goType[0] <= 'Z' {
		return goType
	}

	return ""
}

// isPrimitiveGoType returns true if the Go type is a primitive that doesn't need
// custom scalar registration.
func (g *Generator) isPrimitiveGoType(t string) bool {
	switch t {
	case "string", "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64", "bool", "time.Time":
		return true
	}
	if t == "uuid.UUID" || strings.HasSuffix(t, ".UUID") {
		return true
	}
	return false
}

// genScalarsSchema generates custom scalar definitions.
func (g *Generator) genScalarsSchema() string {
	var buf bytes.Buffer
	buf.WriteString("directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION\n")
	buf.WriteString("directive @goModel(model: String, models: [String!], forceGenerate: Boolean) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION\n")
	buf.WriteString("\n")
	// Custom scalars with descriptions (like Ent)
	buf.WriteString(`"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
`)
	if g.config.ORMPackage != "" {
		fmt.Fprintf(&buf, "scalar Cursor @goModel(model: \"%s.Cursor\")\n", g.config.ORMPackage)
	} else {
		buf.WriteString("scalar Cursor\n")
	}
	buf.WriteString(`"""
The builtin Time type
"""
scalar Time
`)
	// Generate custom scalars for typed JSON fields
	typedScalars := g.collectTypedJSONScalars()
	for _, scalar := range typedScalars {
		buf.WriteString(`"""
Custom JSON type.
"""
`)
		fmt.Fprintf(&buf, "scalar %s @goModel(model: \"%s\")\n", scalar.ScalarName, scalar.GoType)
	}

	return buf.String()
}

// genNodeInterface generates the Relay Node interface.
func (g *Generator) genNodeInterface() string {
	var buf bytes.Buffer
	buf.WriteString(`"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
`)
	fmt.Fprintf(&buf, `interface Node @goModel(model: "%s.Noder") {
  """
  The id of the object.
  """
  id: ID!
}
`, g.config.ORMPackage)
	return buf.String()
}

// genTypesSchema generates GraphQL types for all entities.
func (g *Generator) genTypesSchema() string {
	var buf bytes.Buffer

	// Generate enum types first
	enumTypes := g.genEnumTypes()
	if enumTypes != "" {
		buf.WriteString(enumTypes)
		buf.WriteString("\n")
	}

	buf.WriteString("# Entity types\n\n")

	// Use filterNodes to get nodes that should be included (like Ent)
	nodes := g.filterNodes(g.graph.Nodes, SkipType)
	for _, t := range nodes {
		buf.WriteString(g.genEntityType(t))
		buf.WriteString("\n")
	}

	return buf.String()
}

// genEnumTypes generates GraphQL enum type definitions for all enum fields.
func (g *Generator) genEnumTypes() string {
	var buf bytes.Buffer
	generatedEnums := make(map[string]bool)

	// Use filterNodes helper (like Ent)
	nodes := g.filterNodes(g.graph.Nodes, SkipType)
	for _, t := range nodes {
		// Use filterFields to exclude skipped fields
		fields := g.filterFields(t.Fields, SkipEnumField)
		for _, f := range fields {
			if !f.IsEnum() {
				continue
			}
			// Check for custom GraphQL type name (for shared enums like schematype.ItemType)
			ann := g.getFieldAnnotation(f)
			enumName := t.Name + pascal(f.Name)
			if customType := ann.GetType(); customType != "" {
				enumName = customType
			}
			if generatedEnums[enumName] {
				continue
			}
			generatedEnums[enumName] = true
			buf.WriteString(g.genEnumType(t, f))
			buf.WriteString("\n")
		}
	}

	return buf.String()
}

// genEnumType generates a GraphQL enum type definition.
func (g *Generator) genEnumType(t *gen.Type, f *gen.Field) string {
	var buf bytes.Buffer

	// Get field annotation for custom type name and enum value mapping
	ann := g.getFieldAnnotation(f)
	enumMapping := ann.GetEnumValues()

	// Check for custom GraphQL type name (for shared enums like schematype.ItemType)
	enumName := t.Name + pascal(f.Name)
	if customType := ann.GetType(); customType != "" {
		enumName = customType
	}

	// Add @goModel directive to bind to ORM enum type
	// For shared enums with GoType, use the GoType package path
	// For entity-specific enums, use the entity package
	goModel := ""
	if g.config.ORMPackage != "" {
		if f.HasGoType() && f.Type != nil && f.Type.PkgPath != "" {
			// Shared enum with GoType - extract the type name from the full ident
			typeName := f.Type.Ident
			if idx := strings.LastIndex(typeName, "."); idx >= 0 {
				typeName = typeName[idx+1:]
			}
			goModel = fmt.Sprintf(` @goModel(model: "%s.%s")`, f.Type.PkgPath, typeName)
		} else {
			// Entity-specific enum
			entityPkg := strings.ToLower(t.Name)
			goModel = fmt.Sprintf(` @goModel(model: "%s/%s.%s")`, g.config.ORMPackage, entityPkg, pascal(f.Name))
		}
	}

	// Enum type description (like Ent)
	fmt.Fprintf(&buf, `"""%s is enum for the field %s
"""
`, enumName, f.Name)
	fmt.Fprintf(&buf, "enum %s%s {\n", enumName, goModel)
	for _, v := range f.EnumValues() {
		// Use custom mapping if provided, otherwise auto-uppercase
		gqlValue := g.graphqlEnumValue(v, enumMapping)
		fmt.Fprintf(&buf, "  %s\n", gqlValue)
	}
	buf.WriteString("}\n")

	return buf.String()
}

// graphqlEnumValue returns the GraphQL enum value for a database value.
// If a custom mapping exists, it uses the mapped value.
// Otherwise, it automatically converts to SCREAMING_SNAKE_CASE (uppercase).
func (g *Generator) graphqlEnumValue(dbValue string, mapping map[string]string) string {
	if mapping != nil {
		if gqlValue, ok := mapping[dbValue]; ok {
			return gqlValue
		}
	}
	// Default: convert to uppercase (GraphQL enum convention)
	return strings.ToUpper(dbValue)
}

// genEntityType generates a GraphQL type for an entity.
func (g *Generator) genEntityType(t *gen.Type) string {
	var buf bytes.Buffer

	typeName := g.graphqlTypeName(t)

	// Build implements clause using nodeImplementors helper (like Ent)
	implementsList := g.nodeImplementors(t)
	implements := ""
	if len(implementsList) > 0 {
		implements = " implements " + strings.Join(implementsList, " & ")
	}

	// Type directives (user-defined + @goModel for autobind)
	directives := g.typeDirectives(t)
	if g.config.ORMPackage != "" {
		directives = fmt.Sprintf(" @goModel(model: \"%s.%s\")%s", g.config.ORMPackage, typeName, directives)
	}

	fmt.Fprintf(&buf, "type %s%s%s {\n", typeName, implements, directives)

	// ID field
	buf.WriteString("  id: ID!\n")

	// Regular fields - use filterFields helper (like Ent)
	fields := g.filterFields(t.Fields, SkipType)
	for _, f := range fields {
		// Check if this field is an edge FK field that should be skipped
		if g.isEdgeFKField(t, f) && g.shouldSkipEdgeFKField(t, f) {
			continue
		}
		fmt.Fprintf(&buf, "  %s\n", g.genField(t, f))
	}

	// Edge fields - use filterEdges helper (like Ent)
	edges := g.filterEdges(t.Edges, SkipType)
	for _, e := range edges {
		fmt.Fprintf(&buf, "  %s\n", g.genEdgeField(t, e))
	}

	buf.WriteString("}\n")
	return buf.String()
}

// isEdgeFKField returns true if the field is a foreign key field for an edge.
func (g *Generator) isEdgeFKField(t *gen.Type, f *gen.Field) bool {
	// Direct check if the field is marked as an edge field (has fk info)
	if f.IsEdgeField() {
		return true
	}
	// Check if any edge explicitly references this field by name
	for _, e := range t.Edges {
		if ef := e.Field(); ef != nil && ef.Name == f.Name {
			return true
		}
	}
	// Heuristic fallback: check if field name matches common FK patterns
	// Fields ending with _id that are numeric and have a matching edge
	if f.Type != nil && f.Type.Numeric() && strings.HasSuffix(f.Name, "_id") {
		// Try to find a matching edge by stripping _id suffix
		edgeName := strings.TrimSuffix(f.Name, "_id")
		for _, e := range t.Edges {
			if e.Name == edgeName {
				return true
			}
		}
	}
	return false
}

// shouldSkipEdgeFKField returns true if the edge FK field should be skipped from the GraphQL type.
func (g *Generator) shouldSkipEdgeFKField(_ *gen.Type, f *gen.Field) bool {
	// If the field has SkipAll annotation, skip it.
	ann := g.getFieldAnnotation(f)
	return ann.Skip&SkipAll != 0
}

// genField generates a GraphQL field definition.
func (g *Generator) genField(t *gen.Type, f *gen.Field) string {
	name := g.graphqlFieldName(f)
	typeName := g.graphqlFieldType(t, f)
	nullable := ""
	if !f.Optional && !f.Nillable {
		nullable = "!"
	}

	// Add @goField directive if needed (for field name mapping)
	directive := ""
	ann := g.getFieldAnnotation(f)
	if ann.GetFieldName() != "" && ann.GetFieldName() != camel(f.Name) {
		directive = fmt.Sprintf(" @goField(name: %q, forceResolver: false)", pascal(f.Name))
	}

	return fmt.Sprintf("%s: %s%s%s", name, typeName, nullable, directive)
}

// genConnectionArgs generates documented connection arguments.
func (g *Generator) genConnectionArgs(targetType string, orderByArg string) string {
	var buf bytes.Buffer
	buf.WriteString("(\n")
	buf.WriteString(`    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

`)
	if targetType != "" {
		// Ent order: orderBy before where
		fmt.Fprintf(&buf, `    """
    Ordering options for %s returned from the connection.
    """
    %s

`, pluralize(targetType), orderByArg)
		fmt.Fprintf(&buf, `    """
    Filtering options for %s returned from the connection.
    """
    where: %sWhereInput
`, pluralize(targetType), targetType)
	}
	buf.WriteString("  )")
	return buf.String()
}

// genEdgeField generates a GraphQL field for an edge.
func (g *Generator) genEdgeField(_ *gen.Type, e *gen.Edge) string {
	name := camel(e.Name)
	targetType := g.graphqlTypeName(e.Type)

	if e.Unique {
		// Unique edge: returns single entity
		// Required edges are non-null, optional edges are nullable per Relay spec
		if !e.Optional {
			return fmt.Sprintf("%s: %s!", name, targetType)
		}
		return fmt.Sprintf("%s: %s", name, targetType)
	}

	// Non-unique edge: returns connection or list
	if g.config.RelayConnection && g.hasRelayConnection(e.Type) {
		orderByArg := g.orderByArg(e.Type)
		args := g.genConnectionArgs(targetType, orderByArg)
		return fmt.Sprintf("%s%s: %sConnection!", name, args, targetType)
	}
	return fmt.Sprintf("%s: [%s!]!", name, targetType)
}

// genInputsSchema generates all input types.
func (g *Generator) genInputsSchema() string {
	var buf bytes.Buffer
	buf.WriteString("# Input types\n\n")

	// OrderDirection enum with description (like Ent)
	if g.config.Ordering {
		buf.WriteString(`"""
Possible directions in which to order a list of items when provided an ` + "`orderBy`" + ` argument.
"""
enum OrderDirection {
  """
  Specifies an ascending order for a given ` + "`orderBy`" + ` argument.
  """
  ASC
  """
  Specifies a descending order for a given ` + "`orderBy`" + ` argument.
  """
  DESC
}

`)
	}

	// Use filterNodes to get nodes that should be included (like Ent)
	nodes := g.filterNodes(g.graph.Nodes, SkipType)
	for _, t := range nodes {
		// WhereInput - use filterNodes with SkipWhereInput
		if g.config.WhereInputs && g.wantsWhereInput(t) {
			buf.WriteString(g.genWhereInput(t))
			buf.WriteString("\n")
		}

		// OrderBy - use filterNodes with SkipOrderField
		if g.config.Ordering && g.wantsOrderField(t) {
			buf.WriteString(g.genOrderBy(t))
			buf.WriteString("\n")
		}

		// Generate mutation input types (CreateXXXInput, UpdateXXXInput)
		// These are needed for gqlgen schema validation even though Go structs are bound via gqlgen.yml
		if g.config.Mutations {
			if g.wantsMutationCreate(t) {
				buf.WriteString(g.genCreateInput(t))
				buf.WriteString("\n")
			}
			if g.wantsMutationUpdate(t) {
				buf.WriteString(g.genUpdateInput(t))
				buf.WriteString("\n")
			}
		}
	}

	return buf.String()
}

// genCreateInput generates the CreateXXXInput type for a mutation.
func (g *Generator) genCreateInput(t *gen.Type) string {
	var buf bytes.Buffer
	typeName := g.graphqlTypeName(t)
	inputName := "Create" + typeName + "Input"

	// Add @goModel directive for autobind (like Ent)
	if g.config.ORMPackage != "" {
		fmt.Fprintf(&buf, "input %s @goModel(model: \"%s.%s\") {\n", inputName, g.config.ORMPackage, inputName)
	} else {
		fmt.Fprintf(&buf, "input %s {\n", inputName)
	}

	// Include fields that should be in create input
	for _, f := range t.Fields {
		if !g.fieldInCreateInput(f) {
			continue
		}
		fieldName := g.graphqlFieldName(f)
		fieldType := g.graphqlInputFieldType(t, f)

		// Required fields (not optional/nillable and no default)
		required := !f.Optional && !f.Nillable && !f.Default
		if required {
			fmt.Fprintf(&buf, "  %s: %s!\n", fieldName, fieldType)
		} else {
			fmt.Fprintf(&buf, "  %s: %s\n", fieldName, fieldType)
		}
	}

	// Note: Edge FK fields are already included via t.Fields (they have field references)
	// so we don't need to add them separately from edges

	buf.WriteString("}\n")
	return buf.String()
}

// genUpdateInput generates the UpdateXXXInput type for a mutation.
func (g *Generator) genUpdateInput(t *gen.Type) string {
	var buf bytes.Buffer
	typeName := g.graphqlTypeName(t)
	inputName := "Update" + typeName + "Input"

	// Add @goModel directive for autobind (like Ent)
	if g.config.ORMPackage != "" {
		fmt.Fprintf(&buf, "input %s @goModel(model: \"%s.%s\") {\n", inputName, g.config.ORMPackage, inputName)
	} else {
		fmt.Fprintf(&buf, "input %s {\n", inputName)
	}

	// Track if we've added any fields
	hasFields := false

	// All fields are optional in update input
	for _, f := range t.Fields {
		// Skip immutable fields (like Go struct generation does)
		if f.Immutable || !g.fieldInUpdateInput(f) {
			continue
		}
		fieldName := g.graphqlFieldName(f)
		fieldType := g.graphqlInputFieldType(t, f)

		// Nillable fields get a clear option
		if f.Nillable {
			fmt.Fprintf(&buf, "  %s: %s\n", fieldName, fieldType)
			fmt.Fprintf(&buf, "  clear%s: Boolean\n", pascal(f.Name))
		} else {
			fmt.Fprintf(&buf, "  %s: %s\n", fieldName, fieldType)
		}
		hasFields = true
	}

	// Note: Edge FK fields are already included via t.Fields

	// If no fields were added, add a placeholder to avoid invalid empty input type
	// Empty input types are not valid in GraphQL
	if !hasFields {
		buf.WriteString("  # This entity has no updatable fields\n")
		buf.WriteString("  _placeholder: Boolean\n")
	}

	buf.WriteString("}\n")
	return buf.String()
}

// genWhereInput generates WhereInput for an entity.
func (g *Generator) genWhereInput(t *gen.Type) string {
	var buf bytes.Buffer
	typeName := g.graphqlTypeName(t)
	inputName := typeName + "WhereInput"

	// WhereInput type description (like Ent)
	fmt.Fprintf(&buf, `"""%s is used for filtering %s objects.
Input was generated by velox.
"""
`, inputName, typeName)

	// Add @goModel directive for autobind (like Ent)
	if g.config.ORMPackage != "" {
		fmt.Fprintf(&buf, "input %s @goModel(model: \"%s.%s\") {\n", inputName, g.config.ORMPackage, inputName)
	} else {
		fmt.Fprintf(&buf, "input %s {\n", inputName)
	}

	// Logical operators (Ent order: not, and, or)
	fmt.Fprintf(&buf, "  not: %sWhereInput\n", typeName)
	fmt.Fprintf(&buf, "  and: [%sWhereInput!]\n", typeName)
	fmt.Fprintf(&buf, "  or: [%sWhereInput!]\n", typeName)

	// ID filters - use WhereOps for consistent behavior with Go code generation
	if t.ID != nil && !g.skipFieldInWhereInput(t.ID) {
		buf.WriteString(g.genFieldFiltersSDL(t.ID, "ID"))
	}

	// Field filters - use filterFields helper (like Ent)
	fields := g.filterFields(t.Fields, SkipWhereInput)
	for _, f := range fields {
		buf.WriteString(g.genFieldFilters(t, f))
	}

	// Edge filters (use filterEdges helper like Ent)
	edges := g.filterEdges(t.Edges, SkipWhereInput)
	for _, e := range edges {
		// Check if this edge has WhereInput enabled
		if !g.hasWhereInput(e) {
			continue
		}
		targetType := g.graphqlTypeName(e.Type)
		edgeName := pascal(e.Name)
		// Edge predicate comment (Ent style, using GraphQL field name)
		fmt.Fprintf(&buf, `  """
  %s edge predicates
  """
`, camel(e.Name))
		fmt.Fprintf(&buf, "  has%s: Boolean\n", edgeName)
		fmt.Fprintf(&buf, "  has%sWith: [%sWhereInput!]\n", edgeName, targetType)
	}

	buf.WriteString("}\n")
	return buf.String()
}

// genFieldFilters generates filter fields for a field.
func (g *Generator) genFieldFilters(t *gen.Type, f *gen.Field) string {
	gqlType := g.graphqlFieldType(t, f)
	return g.genFieldFiltersSDL(f, gqlType)
}

// genFieldFiltersSDL generates GraphQL SDL filter fields for a field using the WhereOp system.
// This ensures consistent behavior between SDL generation and Go code generation.
func (g *Generator) genFieldFiltersSDL(f *gen.Field, gqlType string) string {
	// JSON fields don't support standard predicates
	if f.IsJSON() {
		return ""
	}

	var buf bytes.Buffer
	name := camel(f.Name)

	// Get effective WhereOps (same logic as Go code generation)
	whereOps := g.getEffectiveWhereOps(f)

	// Field predicate comment (Ent style, using GraphQL field name)
	fmt.Fprintf(&buf, `  """
  %s field predicates
  """
`, name)

	// EQ, NEQ
	if whereOps.HasEQ() {
		fmt.Fprintf(&buf, "  %s: %s\n", name, gqlType)
	}
	if whereOps.HasNEQ() {
		fmt.Fprintf(&buf, "  %sNEQ: %s\n", name, gqlType)
	}

	// In, NotIn (variadic)
	if whereOps.HasIn() {
		fmt.Fprintf(&buf, "  %sIn: [%s!]\n", name, gqlType)
	}
	if whereOps.HasNotIn() {
		fmt.Fprintf(&buf, "  %sNotIn: [%s!]\n", name, gqlType)
	}

	// GT, GTE, LT, LTE (ordering)
	if whereOps.HasGT() {
		fmt.Fprintf(&buf, "  %sGT: %s\n", name, gqlType)
	}
	if whereOps.HasGTE() {
		fmt.Fprintf(&buf, "  %sGTE: %s\n", name, gqlType)
	}
	if whereOps.HasLT() {
		fmt.Fprintf(&buf, "  %sLT: %s\n", name, gqlType)
	}
	if whereOps.HasLTE() {
		fmt.Fprintf(&buf, "  %sLTE: %s\n", name, gqlType)
	}

	// String operations (substring matching)
	if whereOps.HasContains() {
		fmt.Fprintf(&buf, "  %sContains: %s\n", name, gqlType)
	}
	if whereOps.HasHasPrefix() {
		fmt.Fprintf(&buf, "  %sHasPrefix: %s\n", name, gqlType)
	}
	if whereOps.HasHasSuffix() {
		fmt.Fprintf(&buf, "  %sHasSuffix: %s\n", name, gqlType)
	}

	// Case-insensitive operations
	if whereOps.HasEqualFold() {
		fmt.Fprintf(&buf, "  %sEqualFold: %s\n", name, gqlType)
	}
	if whereOps.HasContainsFold() {
		fmt.Fprintf(&buf, "  %sContainsFold: %s\n", name, gqlType)
	}

	// Nullable operations
	if whereOps.HasIsNil() {
		fmt.Fprintf(&buf, "  %sIsNil: Boolean\n", name)
	}
	if whereOps.HasNotNil() {
		fmt.Fprintf(&buf, "  %sNotNil: Boolean\n", name)
	}

	return buf.String()
}

// genOrderBy generates OrderBy input for an entity.
func (g *Generator) genOrderBy(t *gen.Type) string {
	var buf bytes.Buffer
	typeName := g.graphqlTypeName(t)
	orderName := typeName + "Order"
	orderFieldName := typeName + "OrderField"

	// Order input with descriptions and default value (matching Ent)
	// Add @goModel directive for autobind
	fmt.Fprintf(&buf, `"""
Ordering options for %s connections
"""
`, typeName)
	if g.config.ORMPackage != "" {
		fmt.Fprintf(&buf, "input %s @goModel(model: \"%s.%s\") {\n", orderName, g.config.ORMPackage, orderName)
	} else {
		fmt.Fprintf(&buf, "input %s {\n", orderName)
	}
	fmt.Fprintf(&buf, `  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order %s.
  """
  field: %s!
}
`, pluralize(typeName), orderFieldName)

	// OrderField enum with description
	// Add @goModel directive for autobind
	fmt.Fprintf(&buf, `"""
Properties by which %s connections can be ordered.
"""
`, typeName)
	if g.config.ORMPackage != "" {
		fmt.Fprintf(&buf, "enum %s @goModel(model: \"%s.%s\") {\n", orderFieldName, g.config.ORMPackage, orderFieldName)
	} else {
		fmt.Fprintf(&buf, "enum %s {\n", orderFieldName)
	}

	// Use filterFields helper (like Ent) - filter by SkipOrderField
	fields := g.filterFields(t.Fields, SkipOrderField)
	for _, f := range fields {
		orderName := g.getOrderFieldName(f)
		fmt.Fprintf(&buf, "  %s\n", orderName)
	}

	// Edge count ordering - only when explicitly annotated with OrderField (like Ent)
	for _, e := range t.Edges {
		if !e.Unique {
			ann := g.getEdgeAnnotation(e)
			if orderField := ann.GetOrderField(); orderField != "" {
				fmt.Fprintf(&buf, "  %s\n", orderField)
			}
		}
	}

	buf.WriteString("}\n")
	return buf.String()
}

// Note: genCreateInput and genUpdateInput removed.
// Following Ent's pattern, mutation inputs are generated as Go structs only
// (see mutation_input.go), not GraphQL SDL. Users configure gqlgen.yml to bind models.

// genConnectionsSchema generates Relay connection types.
func (g *Generator) genConnectionsSchema() string {
	var buf bytes.Buffer
	buf.WriteString("# Relay connection types\n\n")

	// PageInfo type with documentation and Relay spec link (matching Ent)
	// Add @goModel directive for autobind
	buf.WriteString(`"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
`)
	if g.config.ORMPackage != "" {
		fmt.Fprintf(&buf, "type PageInfo @goModel(model: \"%s.PageInfo\") {\n", g.config.ORMPackage)
	} else {
		buf.WriteString("type PageInfo {\n")
	}
	buf.WriteString(`  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}

`)

	// Connection types for each entity - use filterNodes (like Ent)
	nodes := g.filterNodes(g.graph.Nodes, SkipType)
	for _, t := range nodes {
		if !g.hasRelayConnection(t) {
			continue
		}

		typeName := g.graphqlTypeName(t)
		connName := typeName + "Connection"
		edgeName := typeName + "Edge"

		// Connection type with documentation (nullable edges like Ent)
		// Add @goModel directive for autobind
		buf.WriteString(`"""
A connection to a list of items.
"""
`)
		if g.config.ORMPackage != "" {
			fmt.Fprintf(&buf, "type %s @goModel(model: \"%s.%s\") {\n", connName, g.config.ORMPackage, connName)
		} else {
			fmt.Fprintf(&buf, "type %s {\n", connName)
		}
		fmt.Fprintf(&buf, `  """
  A list of edges.
  """
  edges: [%s]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
`, edgeName)

		// Edge type with documentation (nullable node like Ent)
		// Add @goModel directive for autobind
		buf.WriteString(`"""
An edge in a connection.
"""
`)
		if g.config.ORMPackage != "" {
			fmt.Fprintf(&buf, "type %s @goModel(model: \"%s.%s\") {\n", edgeName, g.config.ORMPackage, edgeName)
		} else {
			fmt.Fprintf(&buf, "type %s {\n", edgeName)
		}
		fmt.Fprintf(&buf, `  """
  The item at the end of the edge.
  """
  node: %s
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}

`, typeName)
	}

	return buf.String()
}

// genQueryType generates the Query type.
func (g *Generator) genQueryType() string {
	var buf bytes.Buffer
	buf.WriteString("type Query {\n")

	// Node query (Relay) with documentation
	if g.config.RelaySpec {
		buf.WriteString(`  """
  Fetches an object given its ID.
  """
  node(
    """
    ID of the object.
    """
    id: ID!
  ): Node
  """
  Lookup nodes by a list of IDs.
  """
  nodes(
    """
    The list of node IDs.
    """
    ids: [ID!]!
  ): [Node]!
`)
	}

	// Entity queries (no individual entity queries like Ent - use node() instead)
	// Use filterNodes helper (like Ent)
	nodes := g.filterNodes(g.graph.Nodes, SkipType)
	for _, t := range nodes {
		typeName := g.graphqlTypeName(t)
		pluralName := camel(pluralize(typeName))

		// List/connection query
		if g.config.RelayConnection && g.hasRelayConnection(t) {
			orderByArg := g.orderByArg(t)
			args := g.genQueryConnectionArgs(t, typeName, orderByArg)
			fmt.Fprintf(&buf, "  %s%s: %sConnection!\n", pluralName, args, typeName)
		} else {
			// Simple list query for QueryField-only entities (no args like Ent)
			fmt.Fprintf(&buf, "  %s: [%s!]!\n", pluralName, typeName)
		}
	}

	buf.WriteString("}\n")
	return buf.String()
}

// genQueryConnectionArgs generates documented connection arguments for Query type.
func (g *Generator) genQueryConnectionArgs(t *gen.Type, typeName string, orderByArg string) string {
	var buf bytes.Buffer
	buf.WriteString("(\n")
	buf.WriteString(`    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

`)
	// Ent order: orderBy before where
	if g.config.Ordering && g.wantsOrderField(t) {
		fmt.Fprintf(&buf, `    """
    Ordering options for %s returned from the connection.
    """
    %s

`, pluralize(typeName), orderByArg)
	}
	if g.config.WhereInputs && g.wantsWhereInput(t) {
		fmt.Fprintf(&buf, `    """
    Filtering options for %s returned from the connection.
    """
    where: %sWhereInput
`, pluralize(typeName), typeName)
	}
	buf.WriteString("  )")
	return buf.String()
}

// genMutationType generates the Mutation type.
// Returns empty string if no mutations are defined (opt-in style).
func (g *Generator) genMutationType() string {
	var mutations []string

	// Use filterNodes helper (like Ent)
	nodes := g.filterNodes(g.graph.Nodes, SkipType)
	for _, t := range nodes {
		typeName := g.graphqlTypeName(t)

		// Create mutation
		if g.wantsMutationCreate(t) {
			mutations = append(mutations, fmt.Sprintf("  create%s(input: Create%sInput!): %s!", typeName, typeName, typeName))
		}

		// Update mutation
		if g.wantsMutationUpdate(t) {
			mutations = append(mutations, fmt.Sprintf("  update%s(id: ID!, input: Update%sInput!): %s!", typeName, typeName, typeName))
		}

		// Delete mutation
		if g.wantsMutationDelete(t) {
			mutations = append(mutations, fmt.Sprintf("  delete%s(id: ID!): ID!", typeName))
		}
	}

	// Don't generate empty Mutation type - GraphQL requires at least one field
	if len(mutations) == 0 {
		return ""
	}

	var buf bytes.Buffer
	buf.WriteString("type Mutation {\n")
	for _, m := range mutations {
		buf.WriteString(m)
		buf.WriteString("\n")
	}
	buf.WriteString("}\n")
	return buf.String()
}

// Note: Go models and resolver interfaces (models_gen.go, resolvers.go) are
// generated by gqlgen, not by this package. Run gqlgen after velox generate.

// =============================================================================
// File writing
// =============================================================================

func (g *Generator) writeSchema(content, subdir, filename string) error {
	// Use SchemaOutDir for schema files, fallback to OutDir
	baseDir := g.config.SchemaOutDir
	if baseDir == "" {
		baseDir = g.config.OutDir
	}
	dir := baseDir
	if subdir != "" {
		dir = filepath.Join(baseDir, subdir)
	}
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return err
	}
	path := filepath.Join(dir, filename)
	return os.WriteFile(path, []byte(content), 0o644)
}

func (g *Generator) writeFile(f *jen.File, filename string) error {
	path := filepath.Join(g.config.OutDir, filename)
	out, err := os.Create(path)
	if err != nil {
		return err
	}
	defer out.Close()
	return f.Render(out)
}

// =============================================================================
// Helper methods
// =============================================================================

func (g *Generator) graphqlTypeName(t *gen.Type) string {
	if t == nil {
		return ""
	}
	ann := g.getTypeAnnotation(t)
	if name := ann.GetType(); name != "" {
		return name
	}
	return t.Name
}

func (g *Generator) graphqlFieldName(f *gen.Field) string {
	ann := g.getFieldAnnotation(f)
	if name := ann.GetFieldName(); name != "" {
		return name
	}
	return camel(f.Name)
}

// graphqlFieldType returns the GraphQL type for a field.
// If t is provided and the field is an edge FK field, returns ID type.
func (g *Generator) graphqlFieldType(t *gen.Type, f *gen.Field) string {
	ann := g.getFieldAnnotation(f)
	if customType := ann.GetType(); customType != "" {
		return customType
	}

	// Check custom scalar mapping function
	if g.config.MapScalarFunc != nil {
		if scalar := g.config.MapScalarFunc(t, f); scalar != "" {
			return scalar
		}
	}

	// If this is an edge FK field, return ID type (like Ent does)
	if t != nil && g.isEdgeFKField(t, f) {
		return "ID"
	}

	if f.Type == nil {
		return "String"
	}

	// Check field type constant directly for special types
	if f.IsTime() {
		return "Time"
	}
	if f.IsUUID() {
		return "UUID"
	}
	if f.IsJSON() {
		// Try to infer GraphQL list type for slice types (e.g., []string -> [String!])
		if inferredType := g.inferGraphQLSliceType(f); inferredType != "" {
			return inferredType
		}
		// Use custom scalar for typed JSON fields (structs), generic JSON for untyped
		if scalarName := g.getTypedJSONScalarName(f); scalarName != "" {
			return scalarName
		}
		return "JSON"
	}
	if f.IsEnum() {
		// Enum type name is EntityFieldName format (e.g., CategoryStatus, TodoStatus)
		if t != nil {
			return t.Name + pascal(f.Name)
		}
		return pascal(f.Name)
	}
	// Use field.Type enum constants for robust type matching
	switch f.Type.Type {
	case field.TypeString:
		return "String"
	case field.TypeInt, field.TypeInt8, field.TypeInt16, field.TypeInt32, field.TypeInt64,
		field.TypeUint, field.TypeUint8, field.TypeUint16, field.TypeUint32, field.TypeUint64:
		return "Int"
	case field.TypeFloat32, field.TypeFloat64:
		return "Float"
	case field.TypeBool:
		return "Boolean"
	case field.TypeBytes:
		return "Bytes"
	default:
		return "String"
	}
}

// graphqlInputFieldType returns the GraphQL type for a field in input contexts.
// For input types, custom object types must fall back to JSON scalar since GraphQL
// only allows scalars, enums, and input objects in input types.
func (g *Generator) graphqlInputFieldType(t *gen.Type, f *gen.Field) string {
	ann := g.getFieldAnnotation(f)
	if customType := ann.GetType(); customType != "" {
		// Check if this custom type is valid in input context
		// Known valid scalars and standard types
		if g.isValidInputType(customType) {
			return customType
		}
		// Custom type references an object type - fall back to JSON for input
		return "JSON"
	}
	// No custom type - use standard field type (which handles scalars correctly)
	return g.graphqlFieldType(t, f)
}

// isValidInputType checks if a GraphQL type name is valid in input context.
// Valid types include: scalars, enums (all caps convention), and known types.
func (g *Generator) isValidInputType(typeName string) bool {
	// Strip list markers for inner type check
	innerType := strings.TrimPrefix(typeName, "[")
	innerType = strings.TrimSuffix(innerType, "!")
	innerType = strings.TrimSuffix(innerType, "]")
	innerType = strings.TrimSuffix(innerType, "!")

	// Known GraphQL scalars
	knownScalars := map[string]bool{
		"ID": true, "String": true, "Int": true, "Float": true, "Boolean": true,
		"Time": true, "UUID": true, "JSON": true, "Bytes": true, "Decimal": true,
		"Cursor": true, "Map": true, "Any": true,
	}
	if knownScalars[innerType] {
		return true
	}

	// Check if it ends with "Input" (explicit input type)
	if strings.HasSuffix(innerType, "Input") {
		return true
	}

	// Check if it's all uppercase (likely an enum)
	if strings.ToUpper(innerType) == innerType && innerType != "" {
		return true
	}

	// Check if it's a generated enum type (EntityFieldName format)
	// These are valid for input since enums are both input and output types
	for _, node := range g.graph.Nodes {
		for _, f := range node.Fields {
			if f.IsEnum() {
				enumName := node.Name + pascal(f.Name)
				// Check for custom enum name from annotation
				fieldAnn := g.getFieldAnnotation(f)
				if customEnumName := fieldAnn.GetType(); customEnumName != "" {
					if innerType == customEnumName {
						return true
					}
				}
				if innerType == enumName {
					return true
				}
			}
		}
	}

	// Unknown type - likely an object type, not valid for input
	return false
}

// extractGraphQLAnnotation extracts a Annotation from an annotations map.
// It handles direct value, pointer, and JSON-marshaled interface types.
func extractGraphQLAnnotation(annotations map[string]any) Annotation {
	if annotations == nil {
		return Annotation{}
	}
	ann, ok := annotations[AnnotationName]
	if !ok {
		return Annotation{}
	}
	// Direct type assertion
	if a, ok := ann.(Annotation); ok {
		return a
	}
	// Pointer type assertion
	if a, ok := ann.(*Annotation); ok && a != nil {
		return *a
	}
	// Try to extract from schema.Annotation interface
	// This handles the case where the annotation was stored as schema.Annotation
	v := reflect.ValueOf(ann)
	// Handle interface values - get the underlying element
	if v.Kind() == reflect.Interface {
		v = v.Elem()
	}
	if v.Kind() == reflect.Struct {
		if skipField := v.FieldByName("Skip"); skipField.IsValid() && skipField.CanUint() {
			return Annotation{Skip: SkipMode(skipField.Uint())}
		}
	}
	// Try JSON marshaling fallback for interface types
	if data, err := json.Marshal(ann); err == nil {
		var a Annotation
		if json.Unmarshal(data, &a) == nil {
			return a
		}
	}
	return Annotation{}
}

func (g *Generator) getTypeAnnotation(t *gen.Type) Annotation {
	return extractGraphQLAnnotation(t.Annotations)
}

func (g *Generator) getFieldAnnotation(f *gen.Field) Annotation {
	return extractGraphQLAnnotation(f.Annotations)
}

func (g *Generator) getEdgeAnnotation(e *gen.Edge) Annotation {
	return extractGraphQLAnnotation(e.Annotations)
}

func (g *Generator) hasRelayConnection(t *gen.Type) bool {
	if !g.config.RelayConnection {
		return false
	}
	ann := g.getTypeAnnotation(t)
	// If RelayConnection is explicitly enabled, use it
	if ann.HasRelayConnection() {
		return true
	}
	// If QueryField is explicitly set but RelayConnection is not, use simple list
	if ann.HasQueryField() {
		return false
	}
	// Default: use connection if not skipped
	return !ann.IsSkipType()
}

func (g *Generator) wantsWhereInput(t *gen.Type) bool {
	ann := g.getTypeAnnotation(t)
	return ann.WantsWhereInputs()
}

func (g *Generator) wantsOrderField(t *gen.Type) bool {
	ann := g.getTypeAnnotation(t)
	return ann.WantsOrderField()
}

// hasMultiOrder returns true if the entity supports multi-column ordering.
func (g *Generator) hasMultiOrder(t *gen.Type) bool {
	ann := g.getTypeAnnotation(t)
	return ann.HasMultiOrder()
}

// orderByArg returns the orderBy argument string for a type (array or single).
func (g *Generator) orderByArg(t *gen.Type) string {
	typeName := g.graphqlTypeName(t)
	if g.hasMultiOrder(t) {
		return fmt.Sprintf("orderBy: [%sOrder!]", typeName)
	}
	return fmt.Sprintf("orderBy: %sOrder", typeName)
}

func (g *Generator) wantsMutationCreate(t *gen.Type) bool {
	ann := g.getTypeAnnotation(t)
	return ann.WantsMutationCreate() && !ann.IsSkipMutationCreate()
}

func (g *Generator) wantsMutationUpdate(t *gen.Type) bool {
	ann := g.getTypeAnnotation(t)
	return ann.WantsMutationUpdate() && !ann.IsSkipMutationUpdate()
}

func (g *Generator) wantsMutationDelete(t *gen.Type) bool {
	ann := g.getTypeAnnotation(t)
	return ann.WantsMutationDelete() && !ann.IsSkipMutationDelete()
}

func (g *Generator) fieldInCreateInput(f *gen.Field) bool {
	// Check annotation first
	ann := g.getFieldAnnotation(f)
	if ann.HasFieldMutationOpsSet() {
		return ann.InCreateInput()
	}
	// Auto-exclude system-managed fields
	if g.isSystemManagedField(f) {
		return false
	}
	return ann.InCreateInput()
}

func (g *Generator) fieldInUpdateInput(f *gen.Field) bool {
	// Check annotation first
	ann := g.getFieldAnnotation(f)
	if ann.HasFieldMutationOpsSet() {
		return ann.InUpdateInput()
	}
	// Auto-exclude system-managed fields
	if g.isSystemManagedField(f) {
		return false
	}
	// Also exclude fields with UpdateDefault (auto-updated timestamps)
	if f.UpdateDefault {
		return false
	}
	return ann.InUpdateInput()
}

// isSystemManagedField returns true if this field is typically managed by the system
// and should not appear in mutation inputs (unless explicitly configured via annotations).
// This includes common timestamp fields like created_at, updated_at, deleted_at.
func (g *Generator) isSystemManagedField(f *gen.Field) bool {
	// Fields with function-based defaults (like time.Now) are typically system-managed
	// Note: f.Default is true for both literal defaults and function defaults
	// We specifically want to exclude time fields with defaults (typically time.Now)
	if f.IsTime() && f.Default {
		return true
	}
	// Common system field names
	name := strings.ToLower(f.Name)
	systemFields := []string{
		"created_at", "createdat", "created",
		"updated_at", "updatedat", "updated",
		"deleted_at", "deletedat",
	}
	return slices.Contains(systemFields, name)
}

func (g *Generator) getOrderFieldName(f *gen.Field) string {
	ann := g.getFieldAnnotation(f)
	if name := ann.GetOrderField(); name != "" {
		return name
	}
	return strings.ToUpper(toSnakeCase(f.Name))
}

func (g *Generator) typeDirectives(t *gen.Type) string {
	ann := g.getTypeAnnotation(t)
	dirs := ann.GetDirectives()
	if len(dirs) == 0 {
		return ""
	}

	var parts []string
	for _, d := range dirs {
		if len(d.Args) == 0 {
			parts = append(parts, "@"+d.Name)
		} else {
			var args []string
			for k, v := range d.Args {
				args = append(args, fmt.Sprintf("%s: %v", k, v))
			}
			parts = append(parts, fmt.Sprintf("@%s(%s)", d.Name, strings.Join(args, ", ")))
		}
	}
	return " " + strings.Join(parts, " ")
}

// =============================================================================
// ORM type reference helpers
// =============================================================================

// ormType returns a jen.Code that references an ORM type.
// If generating into the same package, it returns an unqualified Id.
// Otherwise, it returns a qualified reference with import.
func (g *Generator) ormType(typeName string) jen.Code {
	if g.samePackage {
		return jen.Id(typeName)
	}
	return jen.Qual(g.config.ORMPackage, typeName)
}

// ormTypePtr returns a pointer to an ORM type.
func (g *Generator) ormTypePtr(typeName string) jen.Code {
	if g.samePackage {
		return jen.Op("*").Id(typeName)
	}
	return jen.Op("*").Qual(g.config.ORMPackage, typeName)
}

// =============================================================================
// String utilities
// =============================================================================

// Common acronyms that should be all uppercase
// IMPORTANT: Must match the ORM generator's acronym list in compiler/gen/func.go
// The ORM uses: ACL, API, ASCII, AWS, CPU, CSS, DNS, EOF, GB, GUID, HCL, HTML, HTTP, HTTPS, ID, IP, JSON, KB, LHS, MAC, MB, QPS, RAM, RHS, RPC, SLA, SMTP, SQL, SSH, SSO, TCP, TLS, TTL, UDP, UI, UID, URI, URL, UTF8, UUID, VM, XML, XMPP, XSRF, XSS
var acronyms = map[string]string{
	"acl":   "ACL",
	"api":   "API",
	"ascii": "ASCII",
	"aws":   "AWS",
	"cpu":   "CPU",
	"css":   "CSS",
	"dns":   "DNS",
	"eof":   "EOF",
	"gb":    "GB",
	"guid":  "GUID",
	"hcl":   "HCL",
	"html":  "HTML",
	"http":  "HTTP",
	"https": "HTTPS",
	"id":    "ID",
	"ip":    "IP",
	"json":  "JSON",
	"kb":    "KB",
	"lhs":   "LHS",
	"mac":   "MAC",
	"mb":    "MB",
	"qps":   "QPS",
	"ram":   "RAM",
	"rhs":   "RHS",
	"rpc":   "RPC",
	"sla":   "SLA",
	"smtp":  "SMTP",
	"sql":   "SQL",
	"ssh":   "SSH",
	"sso":   "SSO",
	"tcp":   "TCP",
	"tls":   "TLS",
	"ttl":   "TTL",
	"udp":   "UDP",
	"ui":    "UI",
	"uid":   "UID",
	"uri":   "URI",
	"url":   "URL",
	"utf8":  "UTF8",
	"uuid":  "UUID",
	"vm":    "VM",
	"xml":   "XML",
	"xmpp":  "XMPP",
	"xsrf":  "XSRF",
	"xss":   "XSS",
}

func pascal(s string) string {
	words := strings.Split(strings.ReplaceAll(s, "_", " "), " ")
	for i, w := range words {
		if w != "" {
			lower := strings.ToLower(w)
			if acronym, ok := acronyms[lower]; ok {
				words[i] = acronym
			} else {
				words[i] = strings.ToUpper(w[:1]) + w[1:]
			}
		}
	}
	return strings.Join(words, "")
}

func camel(s string) string {
	// Split by underscore first
	parts := strings.Split(s, "_")
	var words []string
	for _, part := range parts {
		// Split PascalCase into words
		words = append(words, splitPascal(part)...)
	}
	if len(words) == 0 {
		return ""
	}
	var result strings.Builder
	for i, w := range words {
		if w == "" {
			continue
		}
		lower := strings.ToLower(w)
		if i == 0 {
			// First word: always lowercase (even acronyms like ID → id)
			result.WriteString(lower)
		} else {
			// Subsequent words: use acronym if applicable, else capitalize
			if acronym, ok := acronyms[lower]; ok {
				result.WriteString(acronym)
			} else {
				result.WriteString(strings.ToUpper(w[:1]) + strings.ToLower(w[1:]))
			}
		}
	}
	return result.String()
}

// splitPascal splits a PascalCase string into words.
// e.g., "UserName" → ["User", "Name"], "HTTPServer" → ["HTTP", "Server"]
func splitPascal(s string) []string {
	if s == "" {
		return nil
	}
	var words []string
	var word strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			// Check if this is part of an acronym (consecutive uppercase)
			if word.Len() > 0 {
				prev := s[i-1]
				if prev >= 'A' && prev <= 'Z' {
					// Previous was also uppercase - might be end of acronym
					// Look ahead to see if next is lowercase
					if i+1 < len(s) && s[i+1] >= 'a' && s[i+1] <= 'z' {
						// End of acronym, start new word
						words = append(words, word.String())
						word.Reset()
					}
				} else {
					// Previous was lowercase, this starts a new word
					words = append(words, word.String())
					word.Reset()
				}
			}
		}
		word.WriteRune(r)
	}
	if word.Len() > 0 {
		words = append(words, word.String())
	}
	return words
}

func pluralize(s string) string {
	if strings.HasSuffix(s, "s") || strings.HasSuffix(s, "x") ||
		strings.HasSuffix(s, "ch") || strings.HasSuffix(s, "sh") {
		return s + "es"
	}
	if strings.HasSuffix(s, "y") && len(s) > 1 {
		c := s[len(s)-2]
		if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {
			return s[:len(s)-1] + "ies"
		}
	}
	return s + "s"
}

// Note: Transaction middleware is generated by genTransaction() in transaction.go.
// Mutation and query resolvers are implemented by the user with gqlgen.
// This package generates helper utilities (field collection, pagination, etc.)
// that can be used in resolver implementations.
