package graphql

import (
	"github.com/dave/jennifer/jen"
)

// genTransaction generates gql_transaction.go with transaction support.
// This follows entgql's transaction.tmpl pattern and provides:
//   - txCtxKey type for context storage
//   - WithTx() function for wrapping operations in transactions
//   - NewTxContext() and TxFromContext() for context management
//   - OpenTx() method on Client for opening transactions
//   - OpenTxFromContext() function for opening from context
//   - Transactioner interface for abstraction
func (g *Generator) genTransaction() *jen.File {
	if g.config.ORMPackage == "" {
		return nil
	}

	f := jen.NewFile(g.config.Package)
	f.HeaderComment("Code generated by velox. DO NOT EDIT.")

	// Import statements
	f.ImportName("context", "context")
	f.ImportName("fmt", "fmt")
	f.ImportName("errors", "errors")
	// Note: ORM types (Client, Tx) are in the same package, no import needed

	// TxKey for context
	f.Comment("txCtxKey is the context key for storing transactions.")
	f.Type().Id("txCtxKey").Struct()
	f.Line()

	// WithTx wraps a resolver function in a transaction
	f.Comment("WithTx wraps a resolver function in a database transaction.")
	f.Comment("If the function returns an error, the transaction is rolled back.")
	f.Comment("Otherwise, the transaction is committed.")
	f.Func().Id("WithTx").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("client").Op("*").Id("Client"),
		jen.Id("fn").Func().Params(jen.Id("tx").Op("*").Id("Tx")).Error(),
	).Error().Block(
		jen.List(jen.Id("tx"), jen.Id("err")).Op(":=").Id("client").Dot("Tx").Call(jen.Id("ctx")),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("starting transaction: %w"), jen.Id("err"))),
		),
		jen.Line(),
		jen.Id("ctx").Op("=").Id("NewTxContext").Call(jen.Id("ctx"), jen.Id("tx")),
		jen.Line(),
		jen.Defer().Func().Params().Block(
			jen.If(jen.Id("r").Op(":=").Recover().Op(";").Id("r").Op("!=").Nil()).Block(
				jen.Id("_").Op("=").Id("tx").Dot("Rollback").Call(),
				jen.Panic(jen.Id("r")),
			),
		).Call(),
		jen.Line(),
		jen.If(jen.Id("err").Op(":=").Id("fn").Call(jen.Id("tx")).Op(";").Id("err").Op("!=").Nil()).Block(
			jen.If(jen.Id("rerr").Op(":=").Id("tx").Dot("Rollback").Call().Op(";").Id("rerr").Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("rolling back transaction: %w"), jen.Id("rerr"))),
			),
			jen.Return(jen.Id("err")),
		),
		jen.Line(),
		jen.If(jen.Id("err").Op(":=").Id("tx").Dot("Commit").Call().Op(";").Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("committing transaction: %w"), jen.Id("err"))),
		),
		jen.Return(jen.Nil()),
	)
	f.Line()

	// NewTxContext creates a new context with the transaction
	f.Comment("NewTxContext returns a new context with the given transaction.")
	f.Func().Id("NewTxContext").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("tx").Op("*").Id("Tx"),
	).Qual("context", "Context").Block(
		jen.Return(jen.Qual("context", "WithValue").Call(jen.Id("ctx"), jen.Id("txCtxKey").Values(), jen.Id("tx"))),
	)
	f.Line()

	// TxFromContext extracts the transaction from context
	f.Comment("TxFromContext returns the transaction from the context, if present.")
	f.Func().Id("TxFromContext").Params(
		jen.Id("ctx").Qual("context", "Context"),
	).Params(jen.Op("*").Id("Tx"), jen.Bool()).Block(
		jen.List(jen.Id("tx"), jen.Id("ok")).Op(":=").Id("ctx").Dot("Value").Call(jen.Id("txCtxKey").Values()).Assert(jen.Op("*").Id("Tx")),
		jen.Return(jen.Id("tx"), jen.Id("ok")),
	)
	f.Line()

	// OpenTx method on Client
	f.Comment("OpenTx opens a transaction and returns a transactional")
	f.Comment("context along with the created transaction.")
	f.Func().Params(
		jen.Id("c").Add(g.ormTypePtr("Client")),
	).Id("OpenTx").Params(
		jen.Id("ctx").Qual("context", "Context"),
	).Params(
		jen.Qual("context", "Context"),
		jen.Op("*").Id("Tx"),
		jen.Error(),
	).Block(
		jen.List(jen.Id("tx"), jen.Id("err")).Op(":=").Id("c").Dot("Tx").Call(jen.Id("ctx")),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Nil(), jen.Id("err")),
		),
		jen.Id("ctx").Op("=").Id("NewTxContext").Call(jen.Id("ctx"), jen.Id("tx")),
		jen.Id("ctx").Op("=").Id("NewContext").Call(jen.Id("ctx"), jen.Id("tx").Dot("Client").Call()),
		jen.Return(jen.Id("ctx"), jen.Id("tx"), jen.Nil()),
	)
	f.Line()

	// OpenTxFromContext function
	f.Comment("OpenTxFromContext opens a transaction from client stored in context.")
	f.Func().Id("OpenTxFromContext").Params(
		jen.Id("ctx").Qual("context", "Context"),
	).Params(
		jen.Qual("context", "Context"),
		jen.Op("*").Id("Tx"),
		jen.Error(),
	).Block(
		jen.Id("client").Op(":=").Id("FromContext").Call(jen.Id("ctx")),
		jen.If(jen.Id("client").Op("==").Nil()).Block(
			jen.Return(
				jen.Nil(),
				jen.Nil(),
				jen.Qual("errors", "New").Call(jen.Lit("no client attached to context")),
			),
		),
		jen.Return(jen.Id("client").Dot("OpenTx").Call(jen.Id("ctx"))),
	)
	f.Line()

	// Transactioner interface
	f.Comment("Transactioner is the interface for types that support transactions.")
	f.Type().Id("Transactioner").Interface(
		jen.Id("Tx").Params(jen.Qual("context", "Context")).Params(jen.Op("*").Id("Tx"), jen.Error()),
	)
	f.Line()

	return f
}
