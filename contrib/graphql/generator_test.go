package graphql

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	entgen "github.com/syssam/velox/compiler/gen"
	"github.com/syssam/velox/schema/field"
)

// mockGraph creates a test graph with sample types.
// Note: Uses opt-in mutations following Ent-style (graphql.Mutations() required for mutation inputs).
func mockGraph() *entgen.Graph {
	// Default mutation annotation for test entities
	mutationAnnotation := map[string]any{
		"graphql": Annotation{
			Mutations:       mutCreate | mutUpdate | mutDelete,
			HasMutationsSet: true,
		},
	}

	userType := &entgen.Type{
		Name: "User",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields: []*entgen.Field{
			{
				Name: "email",
				Type: &field.TypeInfo{Type: field.TypeString},
			},
			{
				Name: "name",
				Type: &field.TypeInfo{Type: field.TypeString},
			},
			{
				Name:     "age",
				Type:     &field.TypeInfo{Type: field.TypeInt},
				Optional: true,
			},
			{
				Name: "created_at",
				Type: &field.TypeInfo{Type: field.TypeTime},
			},
			{
				Name: "status",
				Type: &field.TypeInfo{Type: field.TypeEnum},
				Enums: []entgen.Enum{
					{Name: "Active", Value: "active"},
					{Name: "Inactive", Value: "inactive"},
					{Name: "Pending", Value: "pending"},
				},
			},
		},
		Annotations: mutationAnnotation,
	}

	postType := &entgen.Type{
		Name: "Post",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields: []*entgen.Field{
			{
				Name: "title",
				Type: &field.TypeInfo{Type: field.TypeString},
			},
			{
				Name: "content",
				Type: &field.TypeInfo{Type: field.TypeString},
			},
		},
		Annotations: mutationAnnotation,
	}

	// Set up edges
	userType.Edges = []*entgen.Edge{
		{
			Name:   "posts",
			Type:   postType,
			Unique: false,
		},
	}

	postType.Edges = []*entgen.Edge{
		{
			Name:    "author",
			Type:    userType,
			Unique:  true,
			Inverse: "posts",
		},
	}

	return &entgen.Graph{
		Config: &entgen.Config{
			Package: "example/ent",
			Target:  "/tmp/test-ent",
		},
		Nodes: []*entgen.Type{userType, postType},
	}
}

func TestGenerator_GenFullSchema(t *testing.T) {
	g := mockGraph()
	gen := NewGenerator(g, Config{
		Package:         "graphql",
		RelayConnection: true,
		WhereInputs:     true,
		Mutations:       true,
		Ordering:        true,
		RelaySpec:       true,
	})

	schema := gen.genFullSchema()

	// Check for required elements
	checks := []string{
		"# Code generated by velox",
		"scalar Time",
		"scalar Cursor",
		"interface Node",
		"type User implements Node",
		"type Post implements Node",
		"id: ID!",
		"email: String!",
		"name: String!",
		"age: Int",
		"type Query",
		"type Mutation",
		"input UserWhereInput",
		"input PostWhereInput",
		"enum OrderDirection",
		"type PageInfo",
		"type UserConnection",
		"type PostConnection",
		"createUser",
		"updateUser",
		"deleteUser",
	}

	for _, check := range checks {
		if !strings.Contains(schema, check) {
			t.Errorf("schema missing expected content: %q", check)
		}
	}
}

func TestGenerator_GenTypesSchema(t *testing.T) {
	g := mockGraph()
	gen := NewGenerator(g, Config{
		Package:   "graphql",
		RelaySpec: true,
	})

	schema := gen.genTypesSchema()

	// Check User type
	if !strings.Contains(schema, "type User") {
		t.Error("schema should contain User type")
	}
	if !strings.Contains(schema, "email: String!") {
		t.Error("User type should have email field")
	}

	// Check Post type
	if !strings.Contains(schema, "type Post") {
		t.Error("schema should contain Post type")
	}
}

func TestGenerator_GenWhereInput(t *testing.T) {
	g := mockGraph()
	gen := NewGenerator(g, Config{
		Package:     "graphql",
		WhereInputs: true,
	})

	userType := g.Nodes[0] // User
	whereInput := gen.genWhereInput(userType)

	// Check logical operators
	checks := []string{
		"input UserWhereInput",
		"and: [UserWhereInput!]",
		"or: [UserWhereInput!]",
		"not: UserWhereInput",
		"id: ID",
		"idNEQ: ID",
		"email: String",
		"emailNEQ: String",
	}

	for _, check := range checks {
		if !strings.Contains(whereInput, check) {
			t.Errorf("WhereInput missing: %q", check)
		}
	}
}

// TestGenerator_GenWhereInputSDLWithWhereOps tests SDL generation respects WhereOps annotation.
func TestGenerator_GenWhereInputSDLWithWhereOps(t *testing.T) {
	t.Run("IDFieldsHaveMinimalPredicates", func(t *testing.T) {
		userType := &entgen.Type{
			Name: "User",
			ID: &entgen.Field{
				Name: "id",
				Type: &field.TypeInfo{Type: field.TypeString},
			},
			Fields: []*entgen.Field{
				{Name: "customer_id", Type: &field.TypeInfo{Type: field.TypeString}},
			},
			Annotations: map[string]any{},
		}

		g := &entgen.Graph{
			Config: &entgen.Config{Package: "example/ent"},
			Nodes:  []*entgen.Type{userType},
		}

		gen := NewGenerator(g, Config{
			Package:     "graphql",
			WhereInputs: true,
		})

		whereInput := gen.genWhereInput(userType)

		// ID should have EQ, NEQ, In, NotIn
		if !strings.Contains(whereInput, "id: ID") {
			t.Error("should have id: ID")
		}
		if !strings.Contains(whereInput, "idNEQ: ID") {
			t.Error("should have idNEQ: ID")
		}
		if !strings.Contains(whereInput, "idIn: [ID!]") {
			t.Error("should have idIn: [ID!]")
		}

		// ID should NOT have GT, LT, Contains, etc. by default
		if strings.Contains(whereInput, "idGT: ID") {
			t.Error("should NOT have idGT: ID")
		}
		if strings.Contains(whereInput, "idContains: ID") {
			t.Error("should NOT have idContains: ID")
		}

		// FK (customer_id) should also have minimal predicates
		// Note: camel("customer_id") = "customerID" (ID is kept uppercase)
		if !strings.Contains(whereInput, "customerID: String") {
			t.Error("should have customerID: String")
		}
		if strings.Contains(whereInput, "customerIDContains: String") {
			t.Error("should NOT have customerIDContains: String")
		}
	})

	t.Run("StringFieldsHaveFullPredicates", func(t *testing.T) {
		userType := &entgen.Type{
			Name: "User",
			ID: &entgen.Field{
				Name: "id",
				Type: &field.TypeInfo{Type: field.TypeInt64},
			},
			Fields: []*entgen.Field{
				{Name: "name", Type: &field.TypeInfo{Type: field.TypeString}},
			},
			Annotations: map[string]any{},
		}

		g := &entgen.Graph{
			Config: &entgen.Config{Package: "example/ent"},
			Nodes:  []*entgen.Type{userType},
		}

		gen := NewGenerator(g, Config{
			Package:     "graphql",
			WhereInputs: true,
		})

		whereInput := gen.genWhereInput(userType)

		// String field should have string predicates (no GT/GTE/LT/LTE)
		// Total 9 ops: EQ, NEQ, In, NotIn, Contains, ContainsFold, EqualFold, HasPrefix, HasSuffix
		stringOps := []string{
			"name: String",
			"nameNEQ: String",
			"nameIn: [String!]",
			"nameNotIn: [String!]",
			"nameContains: String",
			"nameContainsFold: String",
			"nameHasPrefix: String",
			"nameHasSuffix: String",
			"nameEqualFold: String",
		}

		for _, op := range stringOps {
			if !strings.Contains(whereInput, op) {
				t.Errorf("string field should have %s", op)
			}
		}

		// String fields should NOT have comparison operators
		excludedOps := []string{
			"nameGT: String",
			"nameGTE: String",
			"nameLT: String",
			"nameLTE: String",
		}

		for _, op := range excludedOps {
			if strings.Contains(whereInput, op) {
				t.Errorf("string field should NOT have %s", op)
			}
		}
	})

	t.Run("ExplicitWhereOpsInSDL", func(t *testing.T) {
		userType := &entgen.Type{
			Name: "User",
			ID: &entgen.Field{
				Name: "id",
				Type: &field.TypeInfo{Type: field.TypeInt64},
			},
			Fields: []*entgen.Field{
				{
					// Restrict email to equality + EqualFold only
					Name: "email",
					Type: &field.TypeInfo{Type: field.TypeString},
					Annotations: map[string]any{
						AnnotationName: &Annotation{
							WhereOps:    OpsEquality | OpEqualFold,
							HasWhereOps: true,
						},
					},
				},
			},
			Annotations: map[string]any{},
		}

		g := &entgen.Graph{
			Config: &entgen.Config{Package: "example/ent"},
			Nodes:  []*entgen.Type{userType},
		}

		gen := NewGenerator(g, Config{
			Package:     "graphql",
			WhereInputs: true,
		})

		whereInput := gen.genWhereInput(userType)

		// Email should have EQ, NEQ, In, NotIn, EqualFold
		if !strings.Contains(whereInput, "email: String") {
			t.Error("should have email: String")
		}
		if !strings.Contains(whereInput, "emailEqualFold: String") {
			t.Error("should have emailEqualFold: String")
		}

		// Email should NOT have Contains, HasPrefix (restricted)
		if strings.Contains(whereInput, "emailContains: String") {
			t.Error("should NOT have emailContains (restricted)")
		}
		if strings.Contains(whereInput, "emailHasPrefix: String") {
			t.Error("should NOT have emailHasPrefix (restricted)")
		}
	})
}

func TestGenerator_GenOrderBy(t *testing.T) {
	g := mockGraph()
	gen := NewGenerator(g, Config{
		Package:  "graphql",
		Ordering: true,
	})

	userType := g.Nodes[0] // User
	orderBy := gen.genOrderBy(userType)

	checks := []string{
		"input UserOrder",
		"field: UserOrderField!",
		"direction: OrderDirection!",
		"enum UserOrderField",
		"EMAIL",
		"NAME",
		"AGE",
	}

	for _, check := range checks {
		if !strings.Contains(orderBy, check) {
			t.Errorf("OrderBy missing: %q", check)
		}
	}
}

func TestGenerator_GenConnectionsSchema(t *testing.T) {
	g := mockGraph()
	gen := NewGenerator(g, Config{
		Package:         "graphql",
		RelayConnection: true,
	})

	schema := gen.genConnectionsSchema()

	checks := []string{
		"type PageInfo",
		"hasNextPage: Boolean!",
		"hasPreviousPage: Boolean!",
		"startCursor: Cursor",
		"endCursor: Cursor",
		"type UserConnection",
		"edges: [UserEdge]",
		"pageInfo: PageInfo!",
		"totalCount: Int!",
		"type UserEdge",
		"node: User",
		"cursor: Cursor!",
	}

	for _, check := range checks {
		if !strings.Contains(schema, check) {
			t.Errorf("Connections schema missing: %q", check)
		}
	}
}

func TestGenerator_GenMutationInputs(t *testing.T) {
	g := mockGraph()
	gen := NewGenerator(g, Config{
		Package:    "graphql",
		ORMPackage: "example.com/ent",
		Mutations:  true,
	})

	// Test that genMutationInput generates Go structs (not SDL)
	// Following Ent's pattern, mutation inputs are Go structs only
	f := gen.genMutationInput()
	if f == nil {
		t.Error("genMutationInput should return a file")
		return
	}

	// The generated file should be a Go package
	// Actual struct verification would require rendering the file
	// This test just verifies the generator doesn't panic
}

func TestGenerator_GraphqlFieldType(t *testing.T) {
	generator := &Generator{}

	tests := []struct {
		field    *entgen.Field
		expected string
	}{
		{
			field:    &entgen.Field{Type: &field.TypeInfo{Type: field.TypeString}},
			expected: "String",
		},
		{
			field:    &entgen.Field{Type: &field.TypeInfo{Type: field.TypeInt}},
			expected: "Int",
		},
		{
			field:    &entgen.Field{Type: &field.TypeInfo{Type: field.TypeInt64}},
			expected: "Int",
		},
		{
			field:    &entgen.Field{Type: &field.TypeInfo{Type: field.TypeFloat64}},
			expected: "Float",
		},
		{
			field:    &entgen.Field{Type: &field.TypeInfo{Type: field.TypeBool}},
			expected: "Boolean",
		},
		{
			field:    &entgen.Field{Type: &field.TypeInfo{Type: field.TypeTime}},
			expected: "Time",
		},
		{
			field:    &entgen.Field{Type: &field.TypeInfo{Type: field.TypeUUID}},
			expected: "UUID",
		},
		{
			field:    &entgen.Field{Type: &field.TypeInfo{Type: field.TypeJSON}},
			expected: "JSON",
		},
	}

	for _, tt := range tests {
		result := generator.graphqlFieldType(nil, tt.field)
		if result != tt.expected {
			t.Errorf("graphqlFieldType() = %v, want %v", result, tt.expected)
		}
	}
}

func TestGenerator_Pluralize(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"User", "Users"},
		{"Post", "Posts"},
		{"Category", "Categories"},
		{"Box", "Boxes"},
		{"Bus", "Buses"},
		{"Match", "Matches"},
		{"Dish", "Dishes"},
		{"Day", "Days"},
	}

	for _, tt := range tests {
		result := pluralize(tt.input)
		if result != tt.expected {
			t.Errorf("pluralize(%q) = %q, want %q", tt.input, result, tt.expected)
		}
	}
}

func TestGenerator_Pascal(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"user", "User"},
		{"user_name", "UserName"},
		{"created_at", "CreatedAt"},
		{"ID", "ID"},
	}

	for _, tt := range tests {
		result := pascal(tt.input)
		if result != tt.expected {
			t.Errorf("pascal(%q) = %q, want %q", tt.input, result, tt.expected)
		}
	}
}

func TestGenerator_Camel(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"User", "user"},
		{"UserName", "userName"},
		{"user_name", "userName"},
		{"ID", "id"},
		{"UserID", "userID"},
		{"HTTPServer", "httpServer"},
		{"api_key", "apiKey"},
	}

	for _, tt := range tests {
		result := camel(tt.input)
		if result != tt.expected {
			t.Errorf("camel(%q) = %q, want %q", tt.input, result, tt.expected)
		}
	}
}

func TestGenerator_ToSnakeCase(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"User", "user"},
		{"UserName", "user_name"},
		{"createdAt", "created_at"},
	}

	for _, tt := range tests {
		result := toSnakeCase(tt.input)
		if result != tt.expected {
			t.Errorf("toSnakeCase(%q) = %q, want %q", tt.input, result, tt.expected)
		}
	}
}

func TestNewExtension(t *testing.T) {
	ext, err := NewExtension(
		WithSchemaPath("./gql"),
		WithPackage("mygql"),
		WithRelayConnection(true),
		WithWhereInputs(true),
		WithMutations(true),
		WithOrdering(true),
		WithRelaySpec(true),
	)
	if err != nil {
		t.Fatalf("NewExtension() error = %v", err)
	}

	if ext.config.SchemaOutDir != "./gql" {
		t.Errorf("SchemaOutDir = %q, want %q", ext.config.SchemaOutDir, "./gql")
	}
	if ext.config.Package != "mygql" {
		t.Errorf("Package = %q, want %q", ext.config.Package, "mygql")
	}
	if !ext.config.RelayConnection {
		t.Error("RelayConnection should be true")
	}
	if !ext.config.WhereInputs {
		t.Error("WhereInputs should be true")
	}
	if !ext.config.Mutations {
		t.Error("Mutations should be true")
	}
	if !ext.config.Ordering {
		t.Error("Ordering should be true")
	}
	if !ext.config.RelaySpec {
		t.Error("RelaySpec should be true")
	}
}

func TestExtension_Hooks(t *testing.T) {
	ext, err := NewExtension()
	if err != nil {
		t.Fatalf("NewExtension() error = %v", err)
	}

	hooks := ext.Hooks()
	if len(hooks) != 1 {
		t.Errorf("expected 1 hook, got %d", len(hooks))
	}
}

func TestExtension_Annotations(t *testing.T) {
	ext, err := NewExtension()
	if err != nil {
		t.Fatalf("NewExtension() error = %v", err)
	}

	annotations := ext.Annotations()
	if len(annotations) != 1 {
		t.Errorf("expected 1 annotation, got %d", len(annotations))
	}

	if annotations[0].Name() != "GraphQL" {
		t.Errorf("annotation name = %q, want %q", annotations[0].Name(), "GraphQL")
	}
}

func TestExtension_WithMapScalarFunc(t *testing.T) {
	// Custom scalar mapping function
	mapFn := func(_ *entgen.Type, f *entgen.Field) string {
		if f.Name == "special" {
			return "SpecialScalar"
		}
		return ""
	}

	ext, err := NewExtension(WithMapScalarFunc(mapFn))
	if err != nil {
		t.Fatalf("NewExtension() error = %v", err)
	}

	if ext.config.MapScalarFunc == nil {
		t.Error("MapScalarFunc should not be nil")
	}

	// Test that the function works correctly
	result := ext.config.MapScalarFunc(nil, &entgen.Field{Name: "special"})
	if result != "SpecialScalar" {
		t.Errorf("MapScalarFunc(special) = %q, want %q", result, "SpecialScalar")
	}

	result = ext.config.MapScalarFunc(nil, &entgen.Field{Name: "other"})
	if result != "" {
		t.Errorf("MapScalarFunc(other) = %q, want empty", result)
	}
}

func TestExtension_WithTemplates(t *testing.T) {
	tmpl := entgen.NewTemplate("test-template")

	ext, err := NewExtension(WithTemplates(tmpl))
	if err != nil {
		t.Fatalf("NewExtension() error = %v", err)
	}

	templates := ext.Templates()
	if len(templates) != 1 {
		t.Errorf("expected 1 template, got %d", len(templates))
	}

	if templates[0] != tmpl {
		t.Error("template should match the one passed to WithTemplates")
	}
}

func TestExtension_WithRelaySpec_BackwardCompatibility(t *testing.T) {
	// Test that WithNodeInterface still works for backward compatibility
	ext, err := NewExtension(WithNodeInterface(true))
	if err != nil {
		t.Fatalf("NewExtension() error = %v", err)
	}

	if !ext.config.RelaySpec {
		t.Error("RelaySpec should be true when using deprecated WithNodeInterface")
	}
}

func TestExtension_WithSchemaGenerator(t *testing.T) {
	// By default, schemaGenerator should be false
	ext, err := NewExtension()
	if err != nil {
		t.Fatalf("NewExtension() error = %v", err)
	}

	if ext.schemaGenerator {
		t.Error("schemaGenerator should be false by default")
	}

	// When WithSchemaGenerator is used, it should be true
	ext2, err := NewExtension(WithSchemaGenerator())
	if err != nil {
		t.Fatalf("NewExtension() error = %v", err)
	}

	if !ext2.schemaGenerator {
		t.Error("schemaGenerator should be true when WithSchemaGenerator is used")
	}
}

func TestGenerator_Generate_Integration(t *testing.T) {
	// Create temp directory
	tmpDir, err := os.MkdirTemp("", "graphql-test-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	g := mockGraph()
	gen := NewGenerator(g, Config{
		OutDir:          tmpDir,
		Package:         "graphql",
		RelayConnection: true,
		WhereInputs:     true,
		Mutations:       true,
		Ordering:        true,
		RelaySpec:       true,
		SchemaGenerator: true,
		ORMPackage:      "example/ent",
	})

	if genErr := gen.Generate(context.Background()); genErr != nil {
		t.Fatalf("Generate() error = %v", genErr)
	}

	// Check that expected files were created
	// Note: models_gen.go, resolvers.go are generated by gqlgen
	// gqlgen.yml is user-created (not generated)
	// Note: gql_transaction.go is NOT generated - users implement their own transaction middleware
	// Note: gql_node_resolver.go is NOT generated - node resolution is in gql_node.go
	expectedFiles := []string{
		"schema.graphql",
		"gql_where_input.go",
		"gql_node.go",
		"gql_collection.go",
		"gql_edge.go",
		"gql_pagination.go",
		"gql_mutation_input.go",
	}

	for _, file := range expectedFiles {
		path := filepath.Join(tmpDir, file)
		if _, statErr := os.Stat(path); os.IsNotExist(statErr) {
			t.Errorf("expected file %q was not created", file)
		}
	}

	// Verify schema.graphql content
	schemaContent, err := os.ReadFile(filepath.Join(tmpDir, "schema.graphql"))
	if err != nil {
		t.Fatalf("failed to read schema.graphql: %v", err)
	}

	if !strings.Contains(string(schemaContent), "type User") {
		t.Error("schema.graphql should contain User type")
	}
	if !strings.Contains(string(schemaContent), "type Post") {
		t.Error("schema.graphql should contain Post type")
	}

	// Verify gql_node.go content
	nodeContent, err := os.ReadFile(filepath.Join(tmpDir, "gql_node.go"))
	if err != nil {
		t.Fatalf("failed to read gql_node.go: %v", err)
	}
	nodeStr := string(nodeContent)
	if !strings.Contains(nodeStr, "type Noder interface") {
		t.Error("gql_node.go should contain Noder interface")
	}
	if !strings.Contains(nodeStr, "IsNode()") {
		t.Error("gql_node.go should contain IsNode() method")
	}
}

func TestGenerator_GenTransaction(t *testing.T) {
	g := mockGraph()
	gen := NewGenerator(g, Config{
		Package:    "graphql",
		ORMPackage: "example/ent",
		Mutations:  true,
	})

	f := gen.genTransaction()
	if f == nil {
		t.Fatal("genTransaction should return a file")
	}

	// Render the generated code to string
	var buf strings.Builder
	if err := f.Render(&buf); err != nil {
		t.Fatalf("failed to render transaction middleware: %v", err)
	}
	code := buf.String()

	// Check for WithTx function
	if !strings.Contains(code, "func WithTx") {
		t.Error("should generate WithTx function")
	}

	// Check for NewTxContext function
	if !strings.Contains(code, "func NewTxContext") {
		t.Error("should generate NewTxContext function")
	}

	// Check for TxFromContext function
	if !strings.Contains(code, "func TxFromContext") {
		t.Error("should generate TxFromContext function")
	}

	// Check for Transactioner interface
	if !strings.Contains(code, "type Transactioner interface") {
		t.Error("should generate Transactioner interface")
	}

	// Check for proper import of ORM package
	if !strings.Contains(code, "example/ent") {
		t.Error("should import ORM package")
	}

	// Check for OpenTx function (consolidated from transaction.go)
	// Uses qualified type when ORM package differs from graphql package
	if !strings.Contains(code, "func (c *ent.Client) OpenTx") {
		t.Error("should generate OpenTx method on Client")
	}

	// Check for OpenTxFromContext function
	if !strings.Contains(code, "func OpenTxFromContext") {
		t.Error("should generate OpenTxFromContext function")
	}
}

// Note: Tests for complexity, dataloaders, error handling removed
// These are handled by gqlgen or external libraries (graph-gophers/dataloader)

func TestGenerator_SystemManagedFieldFiltering(t *testing.T) {
	// Create a graph with system-managed fields
	// Note: Uses opt-in mutations (Annotation with Mutations set)
	mutationAnnotation := map[string]any{
		"graphql": Annotation{
			Mutations:       mutCreate | mutUpdate | mutDelete,
			HasMutationsSet: true,
		},
	}
	g := &entgen.Graph{
		Config: &entgen.Config{
			Package: "example/ent",
		},
		Nodes: []*entgen.Type{
			{
				Name: "Post",
				ID: &entgen.Field{
					Name: "id",
					Type: &field.TypeInfo{Type: field.TypeInt64},
				},
				Fields: []*entgen.Field{
					{Name: "title", Type: &field.TypeInfo{Type: field.TypeString}},
					{Name: "content", Type: &field.TypeInfo{Type: field.TypeString}},
					// System-managed time fields with defaults
					{Name: "created_at", Type: &field.TypeInfo{Type: field.TypeTime}, Default: true},
					{Name: "updated_at", Type: &field.TypeInfo{Type: field.TypeTime}, UpdateDefault: true},
					// Optional field that should be included
					{Name: "published_at", Type: &field.TypeInfo{Type: field.TypeTime}, Optional: true},
				},
				Annotations: mutationAnnotation,
			},
		},
	}

	gen := NewGenerator(g, Config{
		Package:    "graphql",
		ORMPackage: "example/ent",
		Mutations:  true,
	})

	// Generate mutation input Go structs
	f := gen.genMutationInput()
	if f == nil {
		t.Fatal("genMutationInput returned nil")
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		t.Fatalf("failed to render mutation input: %v", err)
	}
	code := buf.String()

	// Test CreatePostInput - should exclude created_at (time with default)
	if strings.Contains(code, "CreatePostInput") {
		// Check that CreatedAt is NOT in the struct
		if strings.Contains(code, "CreatedAt") && strings.Contains(code, "CreatePostInput") {
			// Make sure CreatedAt isn't between CreatePostInput and the next type
			createInputIdx := strings.Index(code, "type CreatePostInput struct")
			updateInputIdx := strings.Index(code, "type UpdatePostInput struct")
			if createInputIdx >= 0 && updateInputIdx > createInputIdx {
				createSection := code[createInputIdx:updateInputIdx]
				if strings.Contains(createSection, "CreatedAt") {
					t.Error("CreatePostInput should NOT contain CreatedAt (system-managed)")
				}
			}
		}

		if !strings.Contains(code, "Title") {
			t.Error("CreatePostInput should contain Title")
		}
		if !strings.Contains(code, "PublishedAt") {
			t.Error("CreatePostInput should contain PublishedAt (optional time, not system-managed)")
		}
	} else {
		t.Error("should generate CreatePostInput struct")
	}

	// Test UpdatePostInput - should exclude updated_at (has UpdateDefault)
	if strings.Contains(code, "UpdatePostInput") {
		updateInputIdx := strings.Index(code, "type UpdatePostInput struct")
		if updateInputIdx >= 0 {
			// Get section from UpdatePostInput to end or next major type
			updateSection := code[updateInputIdx:]
			nextTypeIdx := strings.Index(updateSection[1:], "\ntype ")
			if nextTypeIdx > 0 {
				updateSection = updateSection[:nextTypeIdx+1]
			}

			if strings.Contains(updateSection, "UpdatedAt") {
				t.Error("UpdatePostInput should NOT contain UpdatedAt (has UpdateDefault)")
			}
			if strings.Contains(updateSection, "CreatedAt") {
				t.Error("UpdatePostInput should NOT contain CreatedAt (system-managed)")
			}
		}

		if !strings.Contains(code, "Title") {
			t.Error("UpdatePostInput should contain Title")
		}
	} else {
		t.Error("should generate UpdatePostInput struct")
	}
}

// TestGenerator_MutationInputEdges tests edge handling in mutation inputs.
// This includes:
// - Inverse edges that own FK (M2O) should be included
// - Required unique edges should use non-pointer types
// - Optional unique edges should use pointer types
// - Non-unique edges should use Add/Remove patterns
func TestGenerator_MutationInputEdges(t *testing.T) {
	// Note: Uses opt-in mutations (Annotation with Mutations set)
	mutationAnnotation := map[string]any{
		"graphql": Annotation{
			Mutations:       mutCreate | mutUpdate | mutDelete,
			HasMutationsSet: true,
		},
	}

	// Create a graph with various edge types
	userType := &entgen.Type{
		Name: "User",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields:      []*entgen.Field{},
		Annotations: map[string]any{},
	}

	categoryType := &entgen.Type{
		Name: "Category",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields:      []*entgen.Field{},
		Annotations: map[string]any{},
	}

	tagType := &entgen.Type{
		Name: "Tag",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields:      []*entgen.Field{},
		Annotations: map[string]any{},
	}

	postType := &entgen.Type{
		Name: "Post",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields: []*entgen.Field{
			{Name: "title", Type: &field.TypeInfo{Type: field.TypeString}},
		},
		Annotations: mutationAnnotation,
	}

	// Set up edge relationships
	// 1. User -> Posts (O2M, owner side)
	userType.Edges = []*entgen.Edge{
		{
			Name:   "posts",
			Type:   postType,
			Unique: false,
		},
	}

	// 2. Post -> Author (M2O, inverse side, OwnFK=true)
	// 3. Post -> Category (M2O, optional)
	// 4. Post -> Tags (M2M)
	authorEdge := &entgen.Edge{
		Name:     "author",
		Type:     userType,
		Unique:   true,
		Optional: false, // Required
		Inverse:  "posts",
		Rel: entgen.Relation{
			Type: entgen.M2O,
		},
	}

	categoryEdge := &entgen.Edge{
		Name:     "category",
		Type:     categoryType,
		Unique:   true,
		Optional: true, // Optional
		Inverse:  "posts",
		Rel: entgen.Relation{
			Type: entgen.M2O,
		},
	}

	tagsEdge := &entgen.Edge{
		Name:   "tags",
		Type:   tagType,
		Unique: false,
		Rel: entgen.Relation{
			Type: entgen.M2M,
		},
	}

	postType.Edges = []*entgen.Edge{authorEdge, categoryEdge, tagsEdge}

	g := &entgen.Graph{
		Config: &entgen.Config{
			Package: "example/ent",
		},
		Nodes: []*entgen.Type{userType, postType, categoryType, tagType},
	}

	gen := NewGenerator(g, Config{
		Package:    "graphql",
		ORMPackage: "example/ent",
		Mutations:  true,
	})

	f := gen.genMutationInput()
	if f == nil {
		t.Fatal("genMutationInput returned nil")
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		t.Fatalf("failed to render mutation input: %v", err)
	}
	code := buf.String()

	// Test CreatePostInput
	t.Run("CreatePostInput", func(t *testing.T) {
		// Extract CreatePostInput struct section
		createIdx := strings.Index(code, "type CreatePostInput struct")
		if createIdx < 0 {
			t.Fatal("CreatePostInput not found")
		}
		nextTypeIdx := strings.Index(code[createIdx+1:], "\ntype ")
		endIdx := createIdx + 1 + nextTypeIdx
		if nextTypeIdx < 0 {
			endIdx = len(code)
		}
		createSection := code[createIdx:endIdx]

		// 1. Should include AuthorID (M2O edge that owns FK)
		if !strings.Contains(createSection, "AuthorID") {
			t.Error("CreatePostInput should contain AuthorID (M2O edge with OwnFK)")
		}

		// 2. AuthorID should be non-pointer (required edge)
		// Look for "AuthorID int64" (non-pointer) not "AuthorID *int64" (pointer)
		if strings.Contains(createSection, "AuthorID *") {
			t.Error("AuthorID should be non-pointer in CreatePostInput (required edge)")
		}
		// Check for AuthorID followed by int64 (with possible whitespace/tabs)
		if !strings.Contains(createSection, "AuthorID") {
			t.Error("CreatePostInput should contain AuthorID")
		}

		// 3. Should include CategoryID (optional M2O edge)
		if !strings.Contains(createSection, "CategoryID") {
			t.Error("CreatePostInput should contain CategoryID (optional M2O edge)")
		}

		// 4. CategoryID should be pointer (optional edge)
		if !strings.Contains(createSection, "CategoryID *int64") {
			t.Error("CategoryID should be *int64 (pointer) in CreatePostInput for optional edge")
		}

		// 5. Should include TagIDs (M2M edge)
		if !strings.Contains(createSection, "TagIDs") {
			t.Error("CreatePostInput should contain TagIDs (M2M edge)")
		}
	})

	t.Run("UpdatePostInput", func(t *testing.T) {
		// Extract UpdatePostInput struct section
		updateIdx := strings.Index(code, "type UpdatePostInput struct")
		if updateIdx < 0 {
			t.Fatal("UpdatePostInput not found")
		}
		nextTypeIdx := strings.Index(code[updateIdx+1:], "\ntype ")
		endIdx := updateIdx + 1 + nextTypeIdx
		if nextTypeIdx < 0 {
			endIdx = len(code)
		}
		updateSection := code[updateIdx:endIdx]

		// 1. Should NOT include ClearAuthor (required edge cannot be cleared)
		if strings.Contains(updateSection, "ClearAuthor") {
			t.Error("UpdatePostInput should NOT contain ClearAuthor (required edge)")
		}

		// 2. Should include ClearCategory (optional edge can be cleared)
		if !strings.Contains(updateSection, "ClearCategory") {
			t.Error("UpdatePostInput should contain ClearCategory")
		}

		// 3. AuthorID should be pointer in update input (all fields optional in updates)
		if !strings.Contains(updateSection, "AuthorID") {
			t.Error("UpdatePostInput should contain AuthorID")
		}
		// Check that AuthorID is followed by a pointer type (*int64)
		// The generated code formats as "AuthorID    *int64" with tabs/spaces
		authorIdx := strings.Index(updateSection, "AuthorID")
		if authorIdx >= 0 {
			// Get the text after "AuthorID" up to the newline
			afterAuthor := updateSection[authorIdx+len("AuthorID"):]
			newlineIdx := strings.Index(afterAuthor, "\n")
			if newlineIdx > 0 {
				afterAuthor = afterAuthor[:newlineIdx]
			}
			if !strings.Contains(afterAuthor, "*") {
				t.Error("AuthorID should be a pointer type in UpdatePostInput")
			}
		}

		// 4. Should include AddTagIDs and RemoveTagIDs for M2M
		if !strings.Contains(updateSection, "AddTagIDs") {
			t.Error("UpdatePostInput should contain AddTagIDs")
		}
		if !strings.Contains(updateSection, "RemoveTagIDs") {
			t.Error("UpdatePostInput should contain RemoveTagIDs")
		}
	})

	t.Run("MutateMethod", func(t *testing.T) {
		// Check that Mutate method is generated for CreatePostInput
		if !strings.Contains(code, "func (i *CreatePostInput) Mutate(m *ent.PostMutation)") {
			t.Error("CreatePostInput should have Mutate method")
		}

		// Check that Mutate method is generated for UpdatePostInput
		if !strings.Contains(code, "func (i *UpdatePostInput) Mutate(m *ent.PostMutation)") {
			t.Error("UpdatePostInput should have Mutate method")
		}
	})
}

// TestGenerator_MutationInputSkipInverseEdges tests that inverse edges without OwnFK are skipped.
func TestGenerator_MutationInputSkipInverseEdges(t *testing.T) {
	// Note: Uses opt-in mutations (Annotation with Mutations set)
	mutationAnnotation := map[string]any{
		"graphql": Annotation{
			Mutations:       mutCreate | mutUpdate | mutDelete,
			HasMutationsSet: true,
		},
	}

	// Create a simple O2M relationship where the FK is NOT on this table
	parentType := &entgen.Type{
		Name: "Parent",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields:      []*entgen.Field{},
		Annotations: mutationAnnotation,
	}

	childType := &entgen.Type{
		Name: "Child",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields:      []*entgen.Field{},
		Annotations: mutationAnnotation,
	}

	// Parent -> Children (O2M, owner side) - should include ChildIDs
	parentType.Edges = []*entgen.Edge{
		{
			Name:   "children",
			Type:   childType,
			Unique: false,
			Rel: entgen.Relation{
				Type: entgen.O2M,
			},
		},
	}

	// Child -> Parent (M2O, inverse side with OwnFK) - should include ParentID
	childType.Edges = []*entgen.Edge{
		{
			Name:    "parent",
			Type:    parentType,
			Unique:  true,
			Inverse: "children",
			Rel: entgen.Relation{
				Type: entgen.M2O,
			},
		},
	}

	g := &entgen.Graph{
		Config: &entgen.Config{
			Package: "example/ent",
		},
		Nodes: []*entgen.Type{parentType, childType},
	}

	gen := NewGenerator(g, Config{
		Package:    "graphql",
		ORMPackage: "example/ent",
		Mutations:  true,
	})

	f := gen.genMutationInput()
	if f == nil {
		t.Fatal("genMutationInput returned nil")
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		t.Fatalf("failed to render mutation input: %v", err)
	}
	code := buf.String()

	// CreateParentInput should have ChildIDs (O2M owner side)
	createParentIdx := strings.Index(code, "type CreateParentInput struct")
	if createParentIdx < 0 {
		t.Fatal("CreateParentInput not found")
	}
	nextIdx := strings.Index(code[createParentIdx+1:], "\ntype ")
	createParentSection := code[createParentIdx : createParentIdx+1+nextIdx]

	if !strings.Contains(createParentSection, "ChildIDs") {
		t.Error("CreateParentInput should contain ChildIDs (O2M owner side)")
	}

	// CreateChildInput should have ParentID (M2O inverse with OwnFK)
	createChildIdx := strings.Index(code, "type CreateChildInput struct")
	if createChildIdx < 0 {
		t.Fatal("CreateChildInput not found")
	}
	nextIdx = strings.Index(code[createChildIdx+1:], "\ntype ")
	var createChildSection string
	if nextIdx < 0 {
		createChildSection = code[createChildIdx:]
	} else {
		createChildSection = code[createChildIdx : createChildIdx+1+nextIdx]
	}

	if !strings.Contains(createChildSection, "ParentID") {
		t.Error("CreateChildInput should contain ParentID (M2O inverse with OwnFK)")
	}
}

// TestGenerator_MutationInputFieldOrdering tests that fields are ordered correctly.
func TestGenerator_MutationInputFieldOrdering(t *testing.T) {
	// Note: Uses opt-in mutations (Annotation with Mutations set)
	mutationAnnotation := map[string]any{
		"graphql": Annotation{
			Mutations:       mutCreate | mutUpdate | mutDelete,
			HasMutationsSet: true,
		},
	}

	// Create a type with nillable fields to test Clear/Set/Append ordering
	todoType := &entgen.Type{
		Name: "Todo",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields: []*entgen.Field{
			{Name: "title", Type: &field.TypeInfo{Type: field.TypeString}},
			{Name: "description", Type: &field.TypeInfo{Type: field.TypeString}, Optional: true, Nillable: true},
		},
		Annotations: mutationAnnotation,
	}

	g := &entgen.Graph{
		Config: &entgen.Config{
			Package: "example/ent",
		},
		Nodes: []*entgen.Type{todoType},
	}

	gen := NewGenerator(g, Config{
		Package:    "graphql",
		ORMPackage: "example/ent",
		Mutations:  true,
	})

	f := gen.genMutationInput()
	if f == nil {
		t.Fatal("genMutationInput returned nil")
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		t.Fatalf("failed to render mutation input: %v", err)
	}
	code := buf.String()

	// For UpdateTodoInput, Clear should come before Set
	updateIdx := strings.Index(code, "type UpdateTodoInput struct")
	if updateIdx < 0 {
		t.Fatal("UpdateTodoInput not found")
	}
	nextIdx := strings.Index(code[updateIdx+1:], "\ntype ")
	var updateSection string
	if nextIdx < 0 {
		updateSection = code[updateIdx:]
	} else {
		updateSection = code[updateIdx : updateIdx+1+nextIdx]
	}

	clearIdx := strings.Index(updateSection, "ClearDescription")
	// Look for "Description" followed by pointer marker - could be "Description *" or "Description\t*"
	descIdx := strings.Index(updateSection, "\n\tDescription")
	if descIdx < 0 {
		descIdx = strings.Index(updateSection, "Description ")
	}

	if clearIdx < 0 {
		t.Error("UpdateTodoInput should contain ClearDescription")
	}
	if descIdx < 0 {
		t.Error("UpdateTodoInput should contain Description field")
	}
	if clearIdx >= 0 && descIdx >= 0 && clearIdx >= descIdx {
		t.Error("ClearDescription should come before Description field in UpdateTodoInput")
	}
}

// TestGenerator_WhereInputGoStruct tests the Go WhereInput struct generation.
func TestGenerator_WhereInputGoStruct(t *testing.T) {
	userType := &entgen.Type{
		Name: "User",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields: []*entgen.Field{
			{Name: "name", Type: &field.TypeInfo{Type: field.TypeString}},
			{Name: "email", Type: &field.TypeInfo{Type: field.TypeString}},
			{Name: "age", Type: &field.TypeInfo{Type: field.TypeInt}, Optional: true},
			{Name: "score", Type: &field.TypeInfo{Type: field.TypeFloat64}},
			{Name: "is_active", Type: &field.TypeInfo{Type: field.TypeBool}},
			{Name: "nickname", Type: &field.TypeInfo{Type: field.TypeString}, Nillable: true},
		},
		Annotations: map[string]any{},
	}

	postType := &entgen.Type{
		Name: "Post",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields: []*entgen.Field{
			{Name: "title", Type: &field.TypeInfo{Type: field.TypeString}},
		},
		Annotations: map[string]any{},
	}

	// Set up edges
	userType.Edges = []*entgen.Edge{
		{
			Name:   "posts",
			Type:   postType,
			Unique: false,
		},
	}

	g := &entgen.Graph{
		Config: &entgen.Config{
			Package: "example/ent",
		},
		Nodes: []*entgen.Type{userType, postType},
	}

	gen := NewGenerator(g, Config{
		Package:     "graphql",
		ORMPackage:  "example/ent",
		WhereInputs: true,
	})

	f := gen.genWhereInputGo()
	if f == nil {
		t.Fatal("genWhereInputGo returned nil")
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		t.Fatalf("failed to render where input: %v", err)
	}
	code := buf.String()

	t.Run("StructGeneration", func(t *testing.T) {
		// Check UserWhereInput struct exists
		if !strings.Contains(code, "type UserWhereInput struct") {
			t.Error("should generate UserWhereInput struct")
		}

		// Check PostWhereInput struct exists
		if !strings.Contains(code, "type PostWhereInput struct") {
			t.Error("should generate PostWhereInput struct")
		}
	})

	t.Run("LogicalOperators", func(t *testing.T) {
		// Check for Not, Or, And fields (with flexible spacing)
		if !strings.Contains(code, "Not") || !strings.Contains(code, "*UserWhereInput") {
			t.Error("UserWhereInput should have Not field")
		}
		if !strings.Contains(code, "Or") || !strings.Contains(code, "[]*UserWhereInput") {
			t.Error("UserWhereInput should have Or field")
		}
		if !strings.Contains(code, "And") {
			t.Error("UserWhereInput should have And field")
		}
	})

	t.Run("FieldPredicates", func(t *testing.T) {
		// Check ID predicates (should be uppercase) - with flexible spacing
		if !strings.Contains(code, "ID ") && !strings.Contains(code, "ID\t") {
			t.Error("should have ID field")
		}
		if !strings.Contains(code, "IDNEQ") {
			t.Error("should have IDNEQ field")
		}
		if !strings.Contains(code, "IDIn") {
			t.Error("should have IDIn field")
		}

		// Check string field predicates
		if !strings.Contains(code, "NameContains") {
			t.Error("should have NameContains for string field")
		}
		if !strings.Contains(code, "NameHasPrefix") {
			t.Error("should have NameHasPrefix for string field")
		}

		// Check numeric field predicates
		if !strings.Contains(code, "AgeGT") {
			t.Error("should have AgeGT for numeric field")
		}
		if !strings.Contains(code, "AgeLTE") {
			t.Error("should have AgeLTE for numeric field")
		}
	})

	t.Run("NillableFieldPredicates", func(t *testing.T) {
		// Nillable fields should have IsNil/NotNil
		if !strings.Contains(code, "NicknameIsNil") {
			t.Error("should have NicknameIsNil for nillable field")
		}
		if !strings.Contains(code, "NicknameNotNil") {
			t.Error("should have NicknameNotNil for nillable field")
		}
	})

	t.Run("EdgePredicates", func(t *testing.T) {
		// Check edge predicates
		if !strings.Contains(code, "HasPosts") {
			t.Error("should have HasPosts edge predicate")
		}
		if !strings.Contains(code, "HasPostsWith") {
			t.Error("should have HasPostsWith edge predicate")
		}
	})

	t.Run("Methods", func(t *testing.T) {
		// Check AddPredicates method
		if !strings.Contains(code, "func (i *UserWhereInput) AddPredicates") {
			t.Error("should have AddPredicates method")
		}

		// Check Filter method
		if !strings.Contains(code, "func (i *UserWhereInput) Filter") {
			t.Error("should have Filter method")
		}

		// Check P method
		if !strings.Contains(code, "func (i *UserWhereInput) P()") {
			t.Error("should have P method")
		}

		// Check error variable
		if !strings.Contains(code, "ErrEmptyUserWhereInput") {
			t.Error("should have ErrEmptyUserWhereInput error variable")
		}
	})
}

// TestGenerator_PaginationTypes tests the pagination type generation.
func TestGenerator_PaginationTypes(t *testing.T) {
	userType := &entgen.Type{
		Name: "User",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields: []*entgen.Field{
			{Name: "name", Type: &field.TypeInfo{Type: field.TypeString}},
			{Name: "created_at", Type: &field.TypeInfo{Type: field.TypeTime}},
			{Name: "age", Type: &field.TypeInfo{Type: field.TypeInt}},
		},
		Annotations: map[string]any{},
	}

	g := &entgen.Graph{
		Config: &entgen.Config{
			Package: "example/ent",
		},
		Nodes: []*entgen.Type{userType},
	}

	gen := NewGenerator(g, Config{
		Package:         "graphql",
		ORMPackage:      "example/ent",
		RelayConnection: true,
		Ordering:        true,
	})

	f := gen.genPagination()
	if f == nil {
		t.Fatal("genPagination returned nil")
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		t.Fatalf("failed to render pagination: %v", err)
	}
	code := buf.String()

	t.Run("TypeAliases", func(t *testing.T) {
		// Check pagination base types (non-generic, velox-specific)
		if !strings.Contains(code, "type Cursor struct") {
			t.Error("should have Cursor type")
		}
		if !strings.Contains(code, "type PageInfo struct") {
			t.Error("should have PageInfo type")
		}
		if !strings.Contains(code, "type OrderDirection string") {
			t.Error("should have OrderDirection type")
		}
	})

	t.Run("ConnectionTypes", func(t *testing.T) {
		// Check UserEdge struct
		if !strings.Contains(code, "type UserEdge struct") {
			t.Error("should generate UserEdge struct")
		}

		// Check UserConnection struct
		if !strings.Contains(code, "type UserConnection struct") {
			t.Error("should generate UserConnection struct")
		}
	})

	t.Run("OrderTypes", func(t *testing.T) {
		// Check UserOrder struct
		if !strings.Contains(code, "type UserOrder struct") {
			t.Error("should generate UserOrder struct")
		}

		// Check UserOrderField struct
		if !strings.Contains(code, "type UserOrderField struct") {
			t.Error("should generate UserOrderField struct")
		}

		// Check DefaultUserOrder variable
		if !strings.Contains(code, "DefaultUserOrder") {
			t.Error("should generate DefaultUserOrder variable")
		}
	})

	t.Run("OrderFieldVariables", func(t *testing.T) {
		// Check orderable field variables
		if !strings.Contains(code, "userByName") {
			t.Error("should generate userByName order field for string field")
		}
		if !strings.Contains(code, "userByCreatedAt") {
			t.Error("should generate userByCreatedAt order field for time field")
		}
		if !strings.Contains(code, "userByAge") {
			t.Error("should generate userByAge order field for int field")
		}
	})

	t.Run("PaginateMethod", func(t *testing.T) {
		// Check Paginate method
		if !strings.Contains(code, "func (u *UserQuery) Paginate") {
			t.Error("should generate Paginate method on query")
		}
	})

	t.Run("WithOptions", func(t *testing.T) {
		// Check WithOrder function
		if !strings.Contains(code, "WithUserOrder") {
			t.Error("should generate WithUserOrder function")
		}

		// Check WithFilter function
		if !strings.Contains(code, "WithUserFilter") {
			t.Error("should generate WithUserFilter function")
		}
	})

	t.Run("ToEdgeMethod", func(t *testing.T) {
		// Check ToEdge method on entity
		if !strings.Contains(code, "func (u *User) ToEdge") {
			t.Error("should generate ToEdge method on entity")
		}
	})

	t.Run("HelperFunctions", func(t *testing.T) {
		// Check helper functions
		if !strings.Contains(code, "func orderFunc") {
			t.Error("should generate orderFunc helper")
		}
		if !strings.Contains(code, "func validateFirstLast") {
			t.Error("should generate validateFirstLast helper")
		}
		if !strings.Contains(code, "func collectedField") {
			t.Error("should generate collectedField helper")
		}
		if !strings.Contains(code, "func paginateLimit") {
			t.Error("should generate paginateLimit helper")
		}
		if !strings.Contains(code, "func LimitPerRow") {
			t.Error("should generate LimitPerRow helper")
		}
	})
}

// TestGenerator_HelpersFilterFunctions tests the helper filter functions.
func TestGenerator_HelpersFilterFunctions(t *testing.T) {
	// Test filterNodes by checking behavior with annotations
	// Since the annotation parsing depends on the actual Annotation type,
	// we test the basic filtering logic
	visibleType := &entgen.Type{
		Name:        "Visible",
		ID:          &entgen.Field{Name: "id", Type: &field.TypeInfo{Type: field.TypeInt64}},
		Annotations: map[string]any{},
	}

	// Type without annotations (should be included)
	anotherVisible := &entgen.Type{
		Name:        "AnotherVisible",
		ID:          &entgen.Field{Name: "id", Type: &field.TypeInfo{Type: field.TypeInt64}},
		Annotations: map[string]any{},
	}

	g := &entgen.Graph{
		Config: &entgen.Config{
			Package: "example/ent",
		},
		Nodes: []*entgen.Type{visibleType, anotherVisible},
	}

	gen := NewGenerator(g, Config{
		Package: "graphql",
	})

	t.Run("FilterNodesNoSkip", func(t *testing.T) {
		// When no types have skip annotations, all should be included
		nodes := gen.filterNodes(g.Nodes, SkipType)
		if len(nodes) != 2 {
			t.Errorf("expected 2 nodes when none are skipped, got %d", len(nodes))
		}
	})

	t.Run("FilterNodesWithSkipMask", func(t *testing.T) {
		// Test that filter function is called with correct mask
		nodes := gen.filterNodes(g.Nodes, SkipType|SkipWhereInput)
		// Both should be included since neither has skip annotations
		if len(nodes) != 2 {
			t.Errorf("expected 2 nodes, got %d", len(nodes))
		}
	})
}

// TestGenerator_OrderFieldOperators tests that field operators are correctly generated.
func TestGenerator_OrderFieldOperators(t *testing.T) {
	gen := &Generator{}

	tests := []struct {
		name          string
		field         *entgen.Field
		expectCompare bool // Whether we expect GT/GTE/LT/LTE (numeric/time only)
		expectString  bool // Whether we expect Contains/HasPrefix/etc
		expectNiladic bool // Whether we expect IsNil/NotNil
	}{
		{
			name:          "string field",
			field:         &entgen.Field{Type: &field.TypeInfo{Type: field.TypeString}},
			expectCompare: false, // strings do NOT have GT/GTE/LT/LTE (lexicographic comparison rarely useful)
			expectString:  true,
			expectNiladic: false,
		},
		{
			name:          "int field",
			field:         &entgen.Field{Type: &field.TypeInfo{Type: field.TypeInt}},
			expectCompare: true,
			expectString:  false,
			expectNiladic: false,
		},
		{
			name:          "bool field",
			field:         &entgen.Field{Type: &field.TypeInfo{Type: field.TypeBool}},
			expectCompare: false,
			expectString:  false,
			expectNiladic: false,
		},
		{
			name:          "nillable string field",
			field:         &entgen.Field{Type: &field.TypeInfo{Type: field.TypeString}, Nillable: true},
			expectCompare: false, // strings do NOT have GT/GTE/LT/LTE
			expectString:  true,
			expectNiladic: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ops := gen.getWhereInputFieldOps(tt.field)

			// Check for comparison operators (GT/GTE/LT/LTE)
			hasGT := false
			for _, op := range ops {
				if op.Name == "GT" {
					hasGT = true
					break
				}
			}
			if hasGT != tt.expectCompare {
				t.Errorf("GT operator: got %v, want %v", hasGT, tt.expectCompare)
			}

			// Check for string operators
			hasContains := false
			for _, op := range ops {
				if op.Name == "Contains" {
					hasContains = true
					break
				}
			}
			if hasContains != tt.expectString {
				t.Errorf("Contains operator: got %v, want %v", hasContains, tt.expectString)
			}

			// Check for niladic operators
			hasIsNil := false
			for _, op := range ops {
				if op.Name == "IsNil" {
					hasIsNil = true
					break
				}
			}
			if hasIsNil != tt.expectNiladic {
				t.Errorf("IsNil operator: got %v, want %v", hasIsNil, tt.expectNiladic)
			}
		})
	}
}

// TestGenerator_SingleVsMultiOrder tests that single order vs multi-order generates correct code.
func TestGenerator_SingleVsMultiOrder(t *testing.T) {
	// Test single order (default - no MultiOrder annotation)
	t.Run("SingleOrder", func(t *testing.T) {
		userType := &entgen.Type{
			Name: "User",
			ID: &entgen.Field{
				Name: "id",
				Type: &field.TypeInfo{Type: field.TypeInt64},
			},
			Fields: []*entgen.Field{
				{Name: "name", Type: &field.TypeInfo{Type: field.TypeString}},
			},
			Annotations: map[string]any{},
		}

		g := &entgen.Graph{
			Config: &entgen.Config{
				Package: "example/ent",
			},
			Nodes: []*entgen.Type{userType},
		}

		gen := NewGenerator(g, Config{
			Package:         "graphql",
			ORMPackage:      "example/ent",
			RelayConnection: true,
			Ordering:        true,
		})

		f := gen.genPagination()
		var buf bytes.Buffer
		if err := f.Render(&buf); err != nil {
			t.Fatalf("failed to render pagination: %v", err)
		}
		code := buf.String()

		// Single order: WithUserOrder should take *UserOrder (not slice)
		if !strings.Contains(code, "func WithUserOrder(order *UserOrder)") {
			t.Error("single order: WithUserOrder should take *UserOrder, not slice")
		}

		// Single order: pager should have order *UserOrder (not slice)
		if !strings.Contains(code, "order *UserOrder") {
			t.Error("single order: pager should have 'order *UserOrder' field")
		}

		// Should NOT have slice syntax for single order
		if strings.Contains(code, "order []*UserOrder") {
			t.Error("single order: should not have slice 'order []*UserOrder'")
		}

		// Schema generation - single order should not have array
		orderByArg := gen.orderByArg(userType)
		if strings.Contains(orderByArg, "[UserOrder!]") {
			t.Error("single order schema: should not have array syntax")
		}
		if !strings.Contains(orderByArg, "orderBy: UserOrder") {
			t.Error("single order schema: should have 'orderBy: UserOrder'")
		}
	})

	// Test multi-order (with MultiOrder annotation)
	t.Run("MultiOrder", func(t *testing.T) {
		userType := &entgen.Type{
			Name: "User",
			ID: &entgen.Field{
				Name: "id",
				Type: &field.TypeInfo{Type: field.TypeInt64},
			},
			Fields: []*entgen.Field{
				{Name: "name", Type: &field.TypeInfo{Type: field.TypeString}},
			},
			Annotations: map[string]any{
				AnnotationName: &Annotation{
					MultiOrder: true,
				},
			},
		}

		g := &entgen.Graph{
			Config: &entgen.Config{
				Package: "example/ent",
			},
			Nodes: []*entgen.Type{userType},
		}

		gen := NewGenerator(g, Config{
			Package:         "graphql",
			ORMPackage:      "example/ent",
			RelayConnection: true,
			Ordering:        true,
		})

		f := gen.genPagination()
		var buf bytes.Buffer
		if err := f.Render(&buf); err != nil {
			t.Fatalf("failed to render pagination: %v", err)
		}
		code := buf.String()

		// Multi-order: WithUserOrder should take []*UserOrder (slice)
		if !strings.Contains(code, "func WithUserOrder(order []*UserOrder)") {
			t.Error("multi-order: WithUserOrder should take []*UserOrder slice")
		}

		// Multi-order: pager should have order []*UserOrder (slice)
		if !strings.Contains(code, "order []*UserOrder") {
			t.Error("multi-order: pager should have 'order []*UserOrder' field")
		}

		// Schema generation should have array syntax
		orderByArg := gen.orderByArg(userType)
		if !strings.Contains(orderByArg, "orderBy: [UserOrder!]") {
			t.Error("multi-order schema: should have array syntax [UserOrder!]")
		}
	})
}

// TestGenerator_WhereOps tests the WhereOps annotation for fine-grained filter control.
func TestGenerator_WhereOps(t *testing.T) {
	t.Run("IDFieldDefaults", func(t *testing.T) {
		// ID field should default to OpsEquality (EQ, NEQ, In, NotIn only)
		userType := &entgen.Type{
			Name: "User",
			ID: &entgen.Field{
				Name: "id",
				Type: &field.TypeInfo{Type: field.TypeString},
			},
			Fields:      []*entgen.Field{},
			Annotations: map[string]any{},
		}

		g := &entgen.Graph{
			Config: &entgen.Config{Package: "example/ent"},
			Nodes:  []*entgen.Type{userType},
		}

		gen := NewGenerator(g, Config{
			Package:     "graphql",
			ORMPackage:  "example/ent",
			WhereInputs: true,
		})

		f := gen.genWhereInputGo()
		var buf bytes.Buffer
		if err := f.Render(&buf); err != nil {
			t.Fatalf("failed to render: %v", err)
		}
		code := buf.String()

		// ID field should have EQ, NEQ, In, NotIn
		if !strings.Contains(code, "IDNEQ") {
			t.Error("ID field should have IDNEQ")
		}
		if !strings.Contains(code, "IDIn") {
			t.Error("ID field should have IDIn")
		}
		if !strings.Contains(code, "IDNotIn") {
			t.Error("ID field should have IDNotIn")
		}

		// ID field should NOT have string operations (Contains, HasPrefix, etc.)
		if strings.Contains(code, "IDContains") {
			t.Error("ID field should NOT have IDContains")
		}
		if strings.Contains(code, "IDHasPrefix") {
			t.Error("ID field should NOT have IDHasPrefix")
		}
		if strings.Contains(code, "IDEqualFold") {
			t.Error("ID field should NOT have IDEqualFold")
		}
	})

	t.Run("ForeignKeyFieldDefaults", func(t *testing.T) {
		// FK fields (ending in _id or ID) should default to OpsEquality
		userType := &entgen.Type{
			Name: "User",
			ID: &entgen.Field{
				Name: "id",
				Type: &field.TypeInfo{Type: field.TypeInt64},
			},
			Fields: []*entgen.Field{
				{Name: "customer_id", Type: &field.TypeInfo{Type: field.TypeString}},
				{Name: "organizationID", Type: &field.TypeInfo{Type: field.TypeString}},
				{Name: "owner_id", Type: &field.TypeInfo{Type: field.TypeString}, Nillable: true},
			},
			Annotations: map[string]any{},
		}

		g := &entgen.Graph{
			Config: &entgen.Config{Package: "example/ent"},
			Nodes:  []*entgen.Type{userType},
		}

		gen := NewGenerator(g, Config{
			Package:     "graphql",
			ORMPackage:  "example/ent",
			WhereInputs: true,
		})

		f := gen.genWhereInputGo()
		var buf bytes.Buffer
		if err := f.Render(&buf); err != nil {
			t.Fatalf("failed to render: %v", err)
		}
		code := buf.String()

		// customer_id should have EQ, NEQ, In, NotIn but no string ops
		if !strings.Contains(code, "CustomerIDIn") {
			t.Error("customer_id should have CustomerIDIn")
		}
		if strings.Contains(code, "CustomerIDContains") {
			t.Error("customer_id should NOT have CustomerIDContains")
		}

		// organizationID should have EQ, NEQ, In, NotIn but no string ops
		if !strings.Contains(code, "OrganizationIDIn") {
			t.Error("organizationID should have OrganizationIDIn")
		}
		if strings.Contains(code, "OrganizationIDContains") {
			t.Error("organizationID should NOT have OrganizationIDContains")
		}

		// owner_id (nullable FK) should have IsNil, NotNil
		if !strings.Contains(code, "OwnerIDIsNil") {
			t.Error("nullable FK should have OwnerIDIsNil")
		}
		if !strings.Contains(code, "OwnerIDNotNil") {
			t.Error("nullable FK should have OwnerIDNotNil")
		}
	})

	t.Run("StringFieldDefaults", func(t *testing.T) {
		// Regular string fields should have full string operations
		userType := &entgen.Type{
			Name: "User",
			ID: &entgen.Field{
				Name: "id",
				Type: &field.TypeInfo{Type: field.TypeInt64},
			},
			Fields: []*entgen.Field{
				{Name: "name", Type: &field.TypeInfo{Type: field.TypeString}},
				{Name: "email", Type: &field.TypeInfo{Type: field.TypeString}},
			},
			Annotations: map[string]any{},
		}

		g := &entgen.Graph{
			Config: &entgen.Config{Package: "example/ent"},
			Nodes:  []*entgen.Type{userType},
		}

		gen := NewGenerator(g, Config{
			Package:     "graphql",
			ORMPackage:  "example/ent",
			WhereInputs: true,
		})

		f := gen.genWhereInputGo()
		var buf bytes.Buffer
		if err := f.Render(&buf); err != nil {
			t.Fatalf("failed to render: %v", err)
		}
		code := buf.String()

		// String fields should have full operations
		if !strings.Contains(code, "NameContains") {
			t.Error("string field should have NameContains")
		}
		if !strings.Contains(code, "NameHasPrefix") {
			t.Error("string field should have NameHasPrefix")
		}
		if !strings.Contains(code, "NameEqualFold") {
			t.Error("string field should have NameEqualFold")
		}
		if !strings.Contains(code, "EmailContainsFold") {
			t.Error("string field should have EmailContainsFold")
		}
	})

	t.Run("ExplicitWhereOpsAnnotation", func(t *testing.T) {
		// Explicit WhereOps annotation should override defaults
		userType := &entgen.Type{
			Name: "User",
			ID: &entgen.Field{
				Name: "id",
				Type: &field.TypeInfo{Type: field.TypeInt64},
			},
			Fields: []*entgen.Field{
				{
					Name: "email",
					Type: &field.TypeInfo{Type: field.TypeString},
					// Restrict email to only EQ, NEQ, In, NotIn, EqualFold
					Annotations: map[string]any{
						AnnotationName: &Annotation{
							WhereOps:    OpsEquality | OpEqualFold,
							HasWhereOps: true,
						},
					},
				},
				{
					Name: "search_text",
					Type: &field.TypeInfo{Type: field.TypeString},
					// Full string ops for search
					Annotations: map[string]any{
						AnnotationName: &Annotation{
							WhereOps:    OpsString,
							HasWhereOps: true,
						},
					},
				},
			},
			Annotations: map[string]any{},
		}

		g := &entgen.Graph{
			Config: &entgen.Config{Package: "example/ent"},
			Nodes:  []*entgen.Type{userType},
		}

		gen := NewGenerator(g, Config{
			Package:     "graphql",
			ORMPackage:  "example/ent",
			WhereInputs: true,
		})

		f := gen.genWhereInputGo()
		var buf bytes.Buffer
		if err := f.Render(&buf); err != nil {
			t.Fatalf("failed to render: %v", err)
		}
		code := buf.String()

		// Email should have EQ, NEQ, In, NotIn, EqualFold
		if !strings.Contains(code, "EmailIn") {
			t.Error("email should have EmailIn")
		}
		if !strings.Contains(code, "EmailEqualFold") {
			t.Error("email should have EmailEqualFold")
		}
		// Email should NOT have Contains, HasPrefix (restricted)
		if strings.Contains(code, "EmailContains") {
			t.Error("email should NOT have EmailContains (restricted by annotation)")
		}
		if strings.Contains(code, "EmailHasPrefix") {
			t.Error("email should NOT have EmailHasPrefix (restricted by annotation)")
		}

		// search_text should have full string ops
		if !strings.Contains(code, "SearchTextContains") {
			t.Error("search_text should have SearchTextContains")
		}
		if !strings.Contains(code, "SearchTextContainsFold") {
			t.Error("search_text should have SearchTextContainsFold")
		}
	})

	t.Run("BoolFieldDefaults", func(t *testing.T) {
		// Bool fields should only have EQ and NEQ
		userType := &entgen.Type{
			Name: "User",
			ID: &entgen.Field{
				Name: "id",
				Type: &field.TypeInfo{Type: field.TypeInt64},
			},
			Fields: []*entgen.Field{
				{Name: "is_active", Type: &field.TypeInfo{Type: field.TypeBool}},
			},
			Annotations: map[string]any{},
		}

		g := &entgen.Graph{
			Config: &entgen.Config{Package: "example/ent"},
			Nodes:  []*entgen.Type{userType},
		}

		gen := NewGenerator(g, Config{
			Package:     "graphql",
			ORMPackage:  "example/ent",
			WhereInputs: true,
		})

		f := gen.genWhereInputGo()
		var buf bytes.Buffer
		if err := f.Render(&buf); err != nil {
			t.Fatalf("failed to render: %v", err)
		}
		code := buf.String()

		// Bool should have EQ, NEQ
		if !strings.Contains(code, "IsActiveNEQ") {
			t.Error("bool field should have IsActiveNEQ")
		}
		// Bool should NOT have In, NotIn (doesn't make sense for bool)
		if strings.Contains(code, "IsActiveIn") {
			t.Error("bool field should NOT have IsActiveIn")
		}
	})

	t.Run("EnumFieldDefaults", func(t *testing.T) {
		// Enum fields should have OpsEquality
		userType := &entgen.Type{
			Name: "User",
			ID: &entgen.Field{
				Name: "id",
				Type: &field.TypeInfo{Type: field.TypeInt64},
			},
			Fields: []*entgen.Field{
				{
					Name: "status",
					Type: &field.TypeInfo{Type: field.TypeEnum},
					Enums: []entgen.Enum{
						{Name: "Active", Value: "active"},
						{Name: "Inactive", Value: "inactive"},
					},
				},
			},
			Annotations: map[string]any{},
		}

		g := &entgen.Graph{
			Config: &entgen.Config{Package: "example/ent"},
			Nodes:  []*entgen.Type{userType},
		}

		gen := NewGenerator(g, Config{
			Package:     "graphql",
			ORMPackage:  "example/ent",
			WhereInputs: true,
		})

		f := gen.genWhereInputGo()
		var buf bytes.Buffer
		if err := f.Render(&buf); err != nil {
			t.Fatalf("failed to render: %v", err)
		}
		code := buf.String()

		// Enum should have EQ, NEQ, In, NotIn
		if !strings.Contains(code, "StatusNEQ") {
			t.Error("enum field should have StatusNEQ")
		}
		if !strings.Contains(code, "StatusIn") {
			t.Error("enum field should have StatusIn")
		}
		// Enum should NOT have comparison ops
		if strings.Contains(code, "StatusGT") {
			t.Error("enum field should NOT have StatusGT")
		}
	})

	t.Run("CustomGoTypeWithWhereOps", func(t *testing.T) {
		// Custom Go types (like decimal.Decimal) require explicit WhereOps annotation
		// to enable comparison operations. This is by design - we don't try to guess
		// what operations make sense for custom types.
		orderType := &entgen.Type{
			Name: "Order",
			ID: &entgen.Field{
				Name: "id",
				Type: &field.TypeInfo{Type: field.TypeInt64},
			},
			Fields: []*entgen.Field{
				{
					// Custom type WITHOUT annotation - defaults to OpsEquality
					Name: "subtotal",
					Type: &field.TypeInfo{
						Type:    field.TypeOther,
						Ident:   "decimal.Decimal",
						PkgPath: "github.com/shopspring/decimal",
					},
				},
				{
					// Custom type WITH explicit WhereOps for comparison
					Name: "total_amount",
					Type: &field.TypeInfo{
						Type:    field.TypeOther,
						Ident:   "decimal.Decimal",
						PkgPath: "github.com/shopspring/decimal",
					},
					Annotations: map[string]any{
						AnnotationName: &Annotation{
							WhereOps:    OpsComparison,
							HasWhereOps: true,
						},
					},
				},
				{
					// Custom type with full numeric ops including nullable
					Name: "discount",
					Type: &field.TypeInfo{
						Type:    field.TypeOther,
						Ident:   "decimal.Decimal",
						PkgPath: "github.com/shopspring/decimal",
					},
					Nillable: true,
					Annotations: map[string]any{
						AnnotationName: &Annotation{
							WhereOps:    OpsComparison,
							HasWhereOps: true,
						},
					},
				},
			},
			Annotations: map[string]any{},
		}

		g := &entgen.Graph{
			Config: &entgen.Config{Package: "example/ent"},
			Nodes:  []*entgen.Type{orderType},
		}

		gen := NewGenerator(g, Config{
			Package:     "graphql",
			ORMPackage:  "example/ent",
			WhereInputs: true,
		})

		f := gen.genWhereInputGo()
		var buf bytes.Buffer
		if err := f.Render(&buf); err != nil {
			t.Fatalf("failed to render: %v", err)
		}
		code := buf.String()

		// subtotal (no annotation) should only have equality ops
		if !strings.Contains(code, "SubtotalNEQ") {
			t.Error("subtotal should have SubtotalNEQ")
		}
		if strings.Contains(code, "SubtotalGT") {
			t.Error("subtotal should NOT have SubtotalGT (no annotation)")
		}

		// total_amount (with OpsComparison) should have comparison ops
		if !strings.Contains(code, "TotalAmountGT") {
			t.Error("total_amount should have TotalAmountGT")
		}
		if !strings.Contains(code, "TotalAmountLTE") {
			t.Error("total_amount should have TotalAmountLTE")
		}
		// But NOT string ops
		if strings.Contains(code, "TotalAmountContains") {
			t.Error("total_amount should NOT have TotalAmountContains")
		}

		// discount (with OpsComparison + Nillable) should have comparison + nullable ops
		if !strings.Contains(code, "DiscountGT") {
			t.Error("discount should have DiscountGT")
		}
		if !strings.Contains(code, "DiscountIsNil") {
			t.Error("discount should have DiscountIsNil (nillable)")
		}
		if !strings.Contains(code, "DiscountNotNil") {
			t.Error("discount should have DiscountNotNil (nillable)")
		}
	})
}

// TestFkZeroCheck tests the fkZeroCheck helper function for FK optimization.
func TestFkZeroCheck(t *testing.T) {
	tests := []struct {
		name     string
		field    *entgen.Field
		receiver string
		want     string // expected generated code snippet
		wantNil  bool   // expect nil result
	}{
		{
			name:     "nil field",
			field:    nil,
			receiver: "_m",
			wantNil:  true,
		},
		{
			name:     "nil type",
			field:    &entgen.Field{Name: "user_id", Type: nil},
			receiver: "_m",
			wantNil:  true,
		},
		{
			name: "optional string FK",
			field: &entgen.Field{
				Name:     "user_id",
				Type:     &field.TypeInfo{Type: field.TypeString},
				Optional: true,
			},
			receiver: "_m",
			want:     `_m.UserID == ""`,
		},
		{
			name: "optional int64 FK",
			field: &entgen.Field{
				Name:     "user_id",
				Type:     &field.TypeInfo{Type: field.TypeInt64},
				Optional: true,
			},
			receiver: "_m",
			want:     `_m.UserID == 0`,
		},
		{
			name: "optional int FK",
			field: &entgen.Field{
				Name:     "owner_id",
				Type:     &field.TypeInfo{Type: field.TypeInt},
				Optional: true,
			},
			receiver: "_m",
			want:     `_m.OwnerID == 0`,
		},
		{
			name: "optional uint64 FK",
			field: &entgen.Field{
				Name:     "category_id",
				Type:     &field.TypeInfo{Type: field.TypeUint64},
				Optional: true,
			},
			receiver: "_m",
			want:     `_m.CategoryID == 0`,
		},
		{
			name: "nillable string FK",
			field: &entgen.Field{
				Name:     "parent_id",
				Type:     &field.TypeInfo{Type: field.TypeString},
				Nillable: true,
			},
			receiver: "_m",
			want:     `_m.ParentID == nil`,
		},
		{
			name: "nillable int64 FK",
			field: &entgen.Field{
				Name:     "group_id",
				Type:     &field.TypeInfo{Type: field.TypeInt64},
				Nillable: true,
			},
			receiver: "_m",
			want:     `_m.GroupID == nil`,
		},
		{
			name: "optional UUID FK",
			field: &entgen.Field{
				Name: "ref_id",
				Type: &field.TypeInfo{
					Type:    field.TypeUUID,
					PkgPath: "github.com/google/uuid",
				},
				Optional: true,
			},
			receiver: "_m",
			want:     `_m.RefID == uuid.Nil`,
		},
		{
			name: "UUID FK without PkgPath",
			field: &entgen.Field{
				Name:     "ref_id",
				Type:     &field.TypeInfo{Type: field.TypeUUID},
				Optional: true,
			},
			receiver: "_m",
			wantNil:  true,
		},
		{
			name: "unsupported type (bool)",
			field: &entgen.Field{
				Name:     "active",
				Type:     &field.TypeInfo{Type: field.TypeBool},
				Optional: true,
			},
			receiver: "_m",
			wantNil:  true,
		},
		{
			name: "unsupported type (time)",
			field: &entgen.Field{
				Name:     "created_at",
				Type:     &field.TypeInfo{Type: field.TypeTime},
				Optional: true,
			},
			receiver: "_m",
			wantNil:  true,
		},
		{
			name: "optional float64 FK",
			field: &entgen.Field{
				Name:     "amount",
				Type:     &field.TypeInfo{Type: field.TypeFloat64},
				Optional: true,
			},
			receiver: "_m",
			want:     `_m.Amount == 0`,
		},
		{
			name: "optional float32 FK",
			field: &entgen.Field{
				Name:     "rate",
				Type:     &field.TypeInfo{Type: field.TypeFloat32},
				Optional: true,
			},
			receiver: "_m",
			want:     `_m.Rate == 0`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := fkZeroCheck(tt.field, tt.receiver)

			if tt.wantNil {
				if got != nil {
					t.Errorf("fkZeroCheck() = %v, want nil", got)
				}
				return
			}

			if got == nil {
				t.Fatalf("fkZeroCheck() = nil, want %q", tt.want)
			}

			// Convert jen.Code to string using GoString
			code := fmt.Sprintf("%#v", got)

			if !strings.Contains(code, tt.want) {
				t.Errorf("fkZeroCheck() = %q, want to contain %q", code, tt.want)
			}
		})
	}
}

// TestGenerator_SkipWhereInputInCollection tests that entities with SkipWhereInput
// don't generate WhereInput references in collection code.
func TestGenerator_SkipWhereInputInCollection(t *testing.T) {
	// Create a type with SkipWhereInput annotation
	skipWhereInputAnnotation := map[string]any{
		"graphql": Annotation{
			Skip: SkipWhereInput,
		},
	}

	// Create a type that references the skipped type
	normalAnnotation := map[string]any{
		"graphql": Annotation{},
	}
	relayAnnotation := map[string]any{
		"graphql": Annotation{
			RelayConnection: true,
		},
	}

	// User type with SkipWhereInput
	userType := &entgen.Type{
		Name: "User",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields:      []*entgen.Field{},
		Annotations: skipWhereInputAnnotation,
	}

	// Post type that has an edge to User (which has SkipWhereInput)
	postType := &entgen.Type{
		Name: "Post",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields:      []*entgen.Field{},
		Annotations: relayAnnotation,
	}

	// User -> Posts (O2M)
	userType.Edges = []*entgen.Edge{
		{
			Name:   "posts",
			Type:   postType,
			Unique: false,
			Rel: entgen.Relation{
				Type: entgen.O2M,
			},
			Annotations: normalAnnotation,
		},
	}

	// Post -> User (M2O) - edge to type with SkipWhereInput
	postType.Edges = []*entgen.Edge{
		{
			Name:    "author",
			Type:    userType,
			Unique:  true,
			Inverse: "posts",
			Rel: entgen.Relation{
				Type: entgen.M2O,
			},
			Annotations: normalAnnotation,
		},
	}

	g := &entgen.Graph{
		Config: &entgen.Config{
			Package: "example/ent",
		},
		Nodes: []*entgen.Type{userType, postType},
	}

	gen := NewGenerator(g, Config{
		Package:         "graphql",
		ORMPackage:      "example/ent",
		WhereInputs:     true,
		RelayConnection: true,
	})

	// Generate collection code
	f := gen.genCollection()
	if f == nil {
		t.Fatal("genCollectionGo returned nil")
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		t.Fatalf("failed to render collection: %v", err)
	}
	code := buf.String()

	// The code should NOT reference UserWhereInput since User has SkipWhereInput
	if strings.Contains(code, "UserWhereInput") {
		t.Error("collection code should NOT reference UserWhereInput when User has SkipWhereInput")
	}

	// The code SHOULD still reference PostWhereInput since Post doesn't have SkipWhereInput
	if !strings.Contains(code, "PostWhereInput") {
		t.Error("collection code should reference PostWhereInput since Post doesn't have SkipWhereInput")
	}
}

// TestGenerator_SkipOrderFieldInCollection tests that entities with SkipOrderField
// don't generate Order type references in collection code.
func TestGenerator_SkipOrderFieldInCollection(t *testing.T) {
	// Create a type with SkipOrderField annotation
	skipOrderFieldAnnotation := map[string]any{
		"graphql": Annotation{
			Skip:            SkipOrderField,
			RelayConnection: true,
		},
	}

	// Create a type without skip annotation
	relayAnnotation := map[string]any{
		"graphql": Annotation{
			RelayConnection: true,
		},
	}

	// User type with SkipOrderField
	userType := &entgen.Type{
		Name: "User",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields:      []*entgen.Field{},
		Annotations: skipOrderFieldAnnotation,
	}

	// Post type without SkipOrderField
	postType := &entgen.Type{
		Name: "Post",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields:      []*entgen.Field{},
		Annotations: relayAnnotation,
	}

	// User -> Posts (O2M)
	userType.Edges = []*entgen.Edge{
		{
			Name:   "posts",
			Type:   postType,
			Unique: false,
			Rel: entgen.Relation{
				Type: entgen.O2M,
			},
		},
	}

	g := &entgen.Graph{
		Config: &entgen.Config{
			Package: "example/ent",
		},
		Nodes: []*entgen.Type{userType, postType},
	}

	gen := NewGenerator(g, Config{
		Package:         "graphql",
		ORMPackage:      "example/ent",
		Ordering:        true,
		RelayConnection: true,
	})

	// Generate collection code
	f := gen.genCollection()
	if f == nil {
		t.Fatal("genCollection returned nil")
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		t.Fatalf("failed to render collection: %v", err)
	}
	code := buf.String()

	// The code should NOT reference UserOrder since User has SkipOrderField
	if strings.Contains(code, "UserOrder") {
		t.Error("collection code should NOT reference UserOrder when User has SkipOrderField")
	}

	// The code SHOULD still reference PostOrder since Post doesn't have SkipOrderField
	if !strings.Contains(code, "PostOrder") {
		t.Error("collection code should reference PostOrder since Post doesn't have SkipOrderField")
	}
}

// TestGenerator_SkipAllInCollection tests that entities with SkipAll
// don't generate any type references (WhereInput, Order) in collection code.
func TestGenerator_SkipAllInCollection(t *testing.T) {
	// Create a type with SkipAll annotation (includes SkipWhereInput, SkipOrderField, etc.)
	skipAllAnnotation := map[string]any{
		"graphql": Annotation{
			Skip:            SkipAll,
			RelayConnection: true, // Even with RelayConnection, SkipAll should prevent type generation
		},
	}

	// Create a type without skip annotation
	relayAnnotation := map[string]any{
		"graphql": Annotation{
			RelayConnection: true,
		},
	}

	// User type with SkipAll
	userType := &entgen.Type{
		Name: "User",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields:      []*entgen.Field{},
		Annotations: skipAllAnnotation,
	}

	// Post type without skip
	postType := &entgen.Type{
		Name: "Post",
		ID: &entgen.Field{
			Name: "id",
			Type: &field.TypeInfo{Type: field.TypeInt64},
		},
		Fields:      []*entgen.Field{},
		Annotations: relayAnnotation,
	}

	g := &entgen.Graph{
		Config: &entgen.Config{
			Package: "example/ent",
		},
		Nodes: []*entgen.Type{userType, postType},
	}

	gen := NewGenerator(g, Config{
		Package:         "graphql",
		ORMPackage:      "example/ent",
		WhereInputs:     true,
		Ordering:        true,
		RelayConnection: true,
	})

	// Generate collection code
	f := gen.genCollection()
	if f == nil {
		t.Fatal("genCollection returned nil")
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		t.Fatalf("failed to render collection: %v", err)
	}
	code := buf.String()

	// The code should NOT reference UserWhereInput or UserOrder since User has SkipAll
	if strings.Contains(code, "UserWhereInput") {
		t.Error("collection code should NOT reference UserWhereInput when User has SkipAll")
	}
	if strings.Contains(code, "UserOrder") {
		t.Error("collection code should NOT reference UserOrder when User has SkipAll")
	}

	// The code SHOULD still reference Post types since Post doesn't have skip
	if !strings.Contains(code, "PostWhereInput") {
		t.Error("collection code should reference PostWhereInput since Post doesn't have skip")
	}
	if !strings.Contains(code, "PostOrder") {
		t.Error("collection code should reference PostOrder since Post doesn't have skip")
	}
}
