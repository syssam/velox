package graphql

// This file generates field collection and edge resolver code.
// It includes:
//   - gql_collection.go: CollectFields for automatic eager loading based on GraphQL query
//   - gql_edge.go: Edge resolver methods on entity structs
//   - Relay connection handling with pagination args
//   - Field selection optimization to only load requested columns

import (
	"strings"
	"unicode"

	"github.com/dave/jennifer/jen"

	"github.com/syssam/velox/compiler/gen"
	"github.com/syssam/velox/schema/field"
)

// genCollection generates gql_collection.go with field collection utilities.
// This follows entgql's collection.tmpl pattern exactly:
//   - CollectFields is a METHOD on the query builder (not standalone function)
//   - collectField is a private method for recursive field collection
//   - Per-entity paginateArgs struct and newPaginateArgs function
//   - Helper constants and functions for field argument handling
func (g *Generator) genCollection() *jen.File {
	if g.config.ORMPackage == "" {
		return nil
	}

	f := jen.NewFile(g.config.Package)
	f.HeaderComment("Code generated by velox. DO NOT EDIT.")

	gqlgenPkg := "github.com/99designs/gqlgen/graphql"

	// Import statements
	f.ImportName("context", "context")
	f.ImportName("fmt", "fmt")
	f.ImportName(gqlgenPkg, "graphql")

	// Generate CollectFields method for each entity's query builder
	// Use filterNodes helper (like Ent)
	nodes := g.filterNodes(g.graph.Nodes, SkipType)
	for _, t := range nodes {
		// Always generate collectField for node resolution support
		g.genEntityCollectFields(f, t)
		// Only generate pagination-related code for entities with RelayConnection annotation
		if g.hasRelayConnection(t) {
			g.genEntityPaginateArgs(f, t)
		}
	}

	// Generate helper constants (following Ent's exact names)
	// Note: edgesField, nodeField, pageInfoField, totalCountField are in gql_pagination.go
	f.Const().DefsFunc(func(group *jen.Group) {
		for _, field := range []string{"after", "first", "before", "last", "orderBy", "direction", "field", "where"} {
			group.Id(field + "Field").Op("=").Lit(field)
		}
	})
	f.Line()

	// Generate helper functions following Ent's pattern exactly
	g.genCollectionHelpers(f)

	return f
}

// genEntityCollectFields generates CollectFields and collectField methods on a query builder.
func (g *Generator) genEntityCollectFields(f *jen.File, t *gen.Type) {
	queryType := t.Name + "Query"
	// Ent uses entity-based receiver names like "cq" for CategoryQuery, "tq" for TodoQuery
	receiver := queryReceiverName(t.Name)
	gqlgenPkg := "github.com/99designs/gqlgen/graphql"

	// CollectFields method - public entry point
	// Pattern: func (_q *CategoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*CategoryQuery, error)
	f.Comment("CollectFields tells the query-builder to eagerly load connected nodes by resolver context.")
	f.Func().Params(
		jen.Id(receiver).Add(g.ormTypePtr(queryType)),
	).Id("CollectFields").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("satisfies").Op("...").String(),
	).Params(
		g.ormTypePtr(queryType),
		jen.Error(),
	).Block(
		jen.Id("fc").Op(":=").Qual(gqlgenPkg, "GetFieldContext").Call(jen.Id("ctx")),
		jen.If(jen.Id("fc").Op("==").Nil()).Block(
			jen.Return(jen.Id(receiver), jen.Nil()),
		),
		jen.If(
			jen.Err().Op(":=").Id(receiver).Dot("collectField").Call(
				jen.Id("ctx"),
				jen.False(), // oneNode
				jen.Qual(gqlgenPkg, "GetOperationContext").Call(jen.Id("ctx")),
				jen.Id("fc").Dot("Field"),
				jen.Nil(), // path
				jen.Id("satisfies").Op("..."),
			),
			jen.Err().Op("!=").Nil(),
		).Block(
			jen.Return(jen.Nil(), jen.Err()),
		),
		jen.Return(jen.Id(receiver), jen.Nil()),
	)
	f.Line()

	// collectField method - private recursive helper
	g.genEntityCollectFieldMethod(f, t)
}

// genEntityCollectFieldMethod generates the private collectField method.
// This follows Ent's pattern with field selection optimization:
// - Track which fields are requested
// - Only select needed columns for better performance
// - Always include FK fields to support edge loading
func (g *Generator) genEntityCollectFieldMethod(f *jen.File, t *gen.Type) {
	queryType := t.Name + "Query"
	// Ent uses entity-based receiver names like "cq" for CategoryQuery, "tq" for TodoQuery
	receiver := queryReceiverName(t.Name)
	gqlgenPkg := "github.com/99designs/gqlgen/graphql"
	entityPkg := g.config.ORMPackage + "/" + strings.ToLower(t.Name)

	// Import entity package for field constants
	f.ImportName(entityPkg, strings.ToLower(t.Name))

	// Collect FK fields from edges - these must always be included for edge loading to work
	// FK fields are on edges where the FK column is stored on this entity (e.g., edge.From with Field())
	var fkFields []*gen.Field
	fkFieldsSeen := make(map[string]bool)
	for _, e := range t.Edges {
		if fkField := e.Field(); fkField != nil {
			if !fkFieldsSeen[fkField.Name] {
				fkFields = append(fkFields, fkField)
				fkFieldsSeen[fkField.Name] = true
			}
		}
	}

	// collectField method signature
	f.Func().Params(
		jen.Id(receiver).Add(g.ormTypePtr(queryType)),
	).Id("collectField").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("oneNode").Bool(),
		jen.Id("opCtx").Op("*").Qual(gqlgenPkg, "OperationContext"),
		jen.Id("collected").Qual(gqlgenPkg, "CollectedField"),
		jen.Id("path").Index().String(),
		jen.Id("satisfies").Op("...").String(),
	).Error().BlockFunc(func(group *jen.Group) {
		// path = append([]string(nil), path...) - copy path to avoid mutation
		group.Id("path").Op("=").Append(
			jen.Index().String().Parens(jen.Nil()),
			jen.Id("path").Op("..."),
		)

		// Initialize field selection tracking variables (Ent's pattern)
		// var (
		//     unknownSeen    bool
		//     fieldSeen      = make(map[string]struct{}, len(entity.Columns))
		//     selectedFields = []string{entity.FieldID, entity.FieldFKID, ...}  // Include FK fields
		// )
		group.Var().DefsFunc(func(varGroup *jen.Group) {
			varGroup.Id("unknownSeen").Bool()
			varGroup.Id("fieldSeen").Op("=").Make(
				jen.Map(jen.String()).Struct(),
				jen.Len(jen.Qual(entityPkg, "Columns")),
			)
			// Build selectedFields with FieldID and all FK fields
			selectedFieldsValues := []jen.Code{jen.Qual(entityPkg, "FieldID")}
			for _, fkField := range fkFields {
				fkFieldConst := "Field" + pascal(fkField.Name)
				selectedFieldsValues = append(selectedFieldsValues, jen.Qual(entityPkg, fkFieldConst))
			}
			varGroup.Id("selectedFields").Op("=").Index().String().Values(selectedFieldsValues...)
		})

		// for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies)
		group.For(
			jen.List(jen.Id("_"), jen.Id("field")).Op(":=").Range().Qual(gqlgenPkg, "CollectFields").Call(
				jen.Id("opCtx"),
				jen.Id("collected").Dot("Selections"),
				jen.Id("satisfies"),
			),
		).BlockFunc(func(forGroup *jen.Group) {
			forGroup.Switch(jen.Id("field").Dot("Name")).BlockFunc(func(sw *jen.Group) {
				// Generate edge cases first - use filterEdges helper (like Ent)
				edges := g.filterEdges(t.Edges, SkipType)
				for i, e := range edges {
					g.genEdgeCollectCase(sw, t, e, i, receiver)
				}

				// Generate field cases - use filterFields helper (like Ent)
				fields := g.filterFields(t.Fields, SkipType)
				for _, fld := range fields {
					fieldGQLName := camel(fld.Name)
					fieldConst := "Field" + pascal(fld.Name)

					sw.Case(jen.Lit(fieldGQLName)).Block(
						jen.If(
							jen.List(jen.Id("_"), jen.Id("ok")).Op(":=").Id("fieldSeen").Index(jen.Qual(entityPkg, fieldConst)),
							jen.Op("!").Id("ok"),
						).Block(
							jen.Id("selectedFields").Op("=").Append(jen.Id("selectedFields"), jen.Qual(entityPkg, fieldConst)),
							jen.Id("fieldSeen").Index(jen.Qual(entityPkg, fieldConst)).Op("=").Struct().Values(),
						),
					)
				}

				// id and __typename are handled without any action (GraphQL introspection fields)
				sw.Case(jen.Lit(GQLFieldID))
				sw.Case(jen.Lit(GQLFieldTypeName))

				// default: unknownSeen = true
				sw.Default().Block(
					jen.Id("unknownSeen").Op("=").True(),
				)
			})
		})

		// Apply column selection only when all requested fields are known.
		group.If(jen.Op("!").Id("unknownSeen")).Block(
			jen.Id(receiver).Dot("Select").Call(jen.Id("selectedFields").Op("...")),
		)

		group.Return(jen.Nil())
	})
	f.Line()
}

// genEdgeCollectCase generates a case statement for collecting an edge field.
func (g *Generator) genEdgeCollectCase(sw *jen.Group, t *gen.Type, e *gen.Edge, edgeIndex int, receiver string) {
	// Guard against nil edge type
	if e.Type == nil {
		return
	}
	edgeName := camel(e.Name)
	structField := pascal(e.Name)
	targetQueryType := e.Type.Name + "Query"
	targetTypeName := g.graphqlTypeName(e.Type)

	// Determine oneNode - if edge is unique, inherit parent's cardinality
	oneNode := "false"
	if e.Unique {
		oneNode = "oneNode"
	}

	sw.Case(jen.Lit(edgeName)).BlockFunc(func(c *jen.Group) {
		// Declare local variables: alias from field, extended path, and edge query builder.
		c.Var().DefsFunc(func(varGroup *jen.Group) {
			varGroup.Id("alias").Op("=").Id("field").Dot("Alias")
			varGroup.Id("path").Op("=").Append(jen.Id("path"), jen.Id("alias"))
			// Create query via client
			varGroup.Id("query").Op("=").Parens(jen.Op("&").Add(g.ormType(e.Type.Name + "Client")).Values(jen.Dict{
				jen.Id("config"): jen.Id(receiver).Dot("config"),
			})).Dot("Query").Call()
		})

		if g.config.RelayConnection && g.hasRelayConnection(e.Type) && !e.Unique {
			// Relay connection edge - complex handling with pagination
			g.genRelayConnectionCollect(c, t, e, edgeIndex, receiver, targetTypeName, oneNode)
		} else {
			// Simple edge - just recursive collect
			c.If(
				jen.Err().Op(":=").Id("query").Dot("collectField").Call(
					jen.Id("ctx"),
					jen.Id(oneNode),
					jen.Id("opCtx"),
					jen.Id("field"),
					jen.Id("path"),
					jen.Id("mayAddCondition").Call(
						jen.Id("satisfies"),
						jen.Id(nodeImplementorsVar(e.Type)),
					).Op("..."),
				),
				jen.Err().Op("!=").Nil(),
			).Block(
				jen.Return(jen.Err()),
			)
		}

		// Assign query to the appropriate eager-loading field.
		if e.Unique {
			// For unique edges, directly assign to with{Edge} field.
			c.Id(receiver).Dot("with" + structField).Op("=").Id("query")
		} else {
			// For non-unique edges, use named loading with alias.
			c.Id(receiver).Dot("WithNamed"+structField).Call(
				jen.Id("alias"),
				jen.Func().Params(jen.Id("wq").Op("*").Add(g.ormType(targetQueryType))).Block(
					jen.Op("*").Id("wq").Op("=").Op("*").Id("query"),
				),
			)
		}

		// Add FK field to selectedFields if this edge has an associated FK field
		// Pattern from Ent: if _, ok := fieldSeen[todo.FieldCategoryID]; !ok { ... }
		if fkField := e.Field(); fkField != nil {
			entityPkg := g.config.ORMPackage + "/" + strings.ToLower(t.Name)
			fkFieldConst := "Field" + pascal(fkField.Name)
			c.If(
				jen.List(jen.Id("_"), jen.Id("ok")).Op(":=").Id("fieldSeen").Index(jen.Qual(entityPkg, fkFieldConst)),
				jen.Op("!").Id("ok"),
			).Block(
				jen.Id("selectedFields").Op("=").Append(jen.Id("selectedFields"), jen.Qual(entityPkg, fkFieldConst)),
				jen.Id("fieldSeen").Index(jen.Qual(entityPkg, fkFieldConst)).Op("=").Struct().Values(),
			)
		}
	})
}

// genRelayConnectionCollect generates collection logic for a Relay connection edge.
func (g *Generator) genRelayConnectionCollect(c *jen.Group, t *gen.Type, e *gen.Edge, edgeIndex int, receiver, targetTypeName, oneNode string) {
	// Initialize pagination arguments from GraphQL field arguments.
	argsFunc := "new" + targetTypeName + "PaginateArgs"
	// Check both global config AND edge/type-level annotation (SkipWhereInput)
	if g.config.WhereInputs && g.hasWhereInput(e) {
		c.Id("args").Op(":=").Id(argsFunc).Call(
			jen.Id("fieldArgs").Call(
				jen.Id("ctx"),
				jen.New(jen.Id(targetTypeName+"WhereInput")),
				jen.Id("path").Op("..."),
			),
		)
	} else {
		c.Id("args").Op(":=").Id(argsFunc).Call(
			jen.Id("fieldArgs").Call(
				jen.Id("ctx"),
				jen.Nil(),
				jen.Id("path").Op("..."),
			),
		)
	}

	// if err := validateFirstLast(args.first, args.last); err != nil { return ... }
	c.If(
		jen.Err().Op(":=").Id("validateFirstLast").Call(jen.Id("args").Dot("first"), jen.Id("args").Dot("last")),
		jen.Err().Op("!=").Nil(),
	).Block(
		jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("validate first and last in path %q: %w"), jen.Id("path"), jen.Err())),
	)

	// Create a new pager with options and reverse flag.
	newPager := "new" + targetTypeName + "Pager"
	c.List(jen.Id("pager"), jen.Err()).Op(":=").Id(newPager).Call(
		jen.Id("args").Dot("opts"),
		jen.Id("args").Dot("last").Op("!=").Nil(),
	)
	c.If(jen.Err().Op("!=").Nil()).Block(
		jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("create new pager in path %q: %w"), jen.Id("path"), jen.Err())),
	)

	// Apply the filter from pagination options to the query.
	c.If(
		jen.List(jen.Id("query"), jen.Err()).Op("=").Id("pager").Dot("applyFilter").Call(jen.Id("query")),
		jen.Err().Op("!=").Nil(),
	).Block(
		jen.Return(jen.Err()),
	)

	// Check if edges field is not requested in the GraphQL query.
	c.Id("ignoredEdges").Op(":=").Op("!").Id("hasCollectedField").Call(
		jen.Id("ctx"),
		jen.Append(jen.Id("path"), jen.Id("edgesField")).Op("..."),
	)

	// Handle totalCount loading
	c.If(
		jen.Id("hasCollectedField").Call(
			jen.Id("ctx"),
			jen.Append(jen.Id("path"), jen.Id("totalCountField")).Op("..."),
		).Op("||").Id("hasCollectedField").Call(
			jen.Id("ctx"),
			jen.Append(jen.Id("path"), jen.Id("pageInfoField")).Op("..."),
		),
	).BlockFunc(func(ifGroup *jen.Group) {
		// Check if any pagination arguments were provided.
		ifGroup.Id("hasPagination").Op(":=").
			Id("args").Dot("after").Op("!=").Nil().Op("||").
			Id("args").Dot("first").Op("!=").Nil().Op("||").
			Id("args").Dot("before").Op("!=").Nil().Op("||").
			Id("args").Dot("last").Op("!=").Nil()

		ifGroup.If(jen.Id("hasPagination").Op("||").Id("ignoredEdges")).BlockFunc(func(paginationGroup *jen.Group) {
			// Load total with separate query
			g.genLoadTotal(paginationGroup, t, e, edgeIndex, receiver)
		}).Else().BlockFunc(func(elseGroup *jen.Group) {
			// All records will be loaded, just count them
			elseGroup.Id(receiver).Dot("loadTotal").Op("=").Append(
				jen.Id(receiver).Dot("loadTotal"),
				jen.Func().Params(
					jen.Id("_").Qual("context", "Context"),
					jen.Id("nodes").Index().Op("*").Add(g.ormType(t.Name)),
				).Error().Block(
					jen.For(jen.Id("i").Op(":=").Range().Id("nodes")).Block(
						jen.Id("n").Op(":=").Len(jen.Id("nodes").Index(jen.Id("i")).Dot("Edges").Dot(pascal(e.Name))),
						jen.If(jen.Id("nodes").Index(jen.Id("i")).Dot("Edges").Dot("totalCount").Index(jen.Lit(edgeIndex)).Op("==").Nil()).Block(
							jen.Id("nodes").Index(jen.Id("i")).Dot("Edges").Dot("totalCount").Index(jen.Lit(edgeIndex)).Op("=").Make(jen.Map(jen.String()).Int()),
						),
						jen.Id("nodes").Index(jen.Id("i")).Dot("Edges").Dot("totalCount").Index(jen.Lit(edgeIndex)).Index(jen.Id("alias")).Op("=").Id("n"),
					),
					jen.Return(jen.Nil()),
				),
			)
		})
	})

	// Skip querying edges if not requested or first/last is 0 - use continue, not return
	c.If(
		jen.Id("ignoredEdges").Op("||").
			Parens(jen.Id("args").Dot("first").Op("!=").Nil().Op("&&").Op("*").Id("args").Dot("first").Op("==").Lit(0)).Op("||").
			Parens(jen.Id("args").Dot("last").Op("!=").Nil().Op("&&").Op("*").Id("args").Dot("last").Op("==").Lit(0)),
	).Block(
		jen.Continue(),
	)

	// Apply cursor-based pagination constraints.
	c.If(
		jen.List(jen.Id("query"), jen.Err()).Op("=").Id("pager").Dot("applyCursors").Call(
			jen.Id("query"),
			jen.Id("args").Dot("after"),
			jen.Id("args").Dot("before"),
		),
		jen.Err().Op("!=").Nil(),
	).Block(
		jen.Return(jen.Err()),
	)

	// Extend path to include edges and node fields for nested collection.
	c.Id("path").Op("=").Append(jen.Id("path"), jen.Id("edgesField"), jen.Id("nodeField"))

	// Recursive collect for nodes
	c.If(
		jen.Id("field").Op(":=").Id("collectedField").Call(jen.Id("ctx"), jen.Id("path").Op("...")),
		jen.Id("field").Op("!=").Nil(),
	).Block(
		jen.If(
			jen.Err().Op(":=").Id("query").Dot("collectField").Call(
				jen.Id("ctx"),
				jen.Id(oneNode),
				jen.Id("opCtx"),
				jen.Op("*").Id("field"),
				jen.Id("path"),
				jen.Id("mayAddCondition").Call(
					jen.Id("satisfies"),
					jen.Id(nodeImplementorsVar(e.Type)),
				).Op("..."),
			),
			jen.Err().Op("!=").Nil(),
		).Block(
			jen.Return(jen.Err()),
		),
	)

	// Target entity package path for FK column constant reference (FK is on target table)
	targetEntityPkg := g.config.ORMPackage + "/" + strings.ToLower(e.Type.Name)
	// Get FK column code (handles both O2M and M2M edges)
	fkColumnCode := g.edgeFKColumnCode(e, t, targetEntityPkg)

	// Apply limit
	c.If(
		jen.Id("limit").Op(":=").Id("paginateLimit").Call(jen.Id("args").Dot("first"), jen.Id("args").Dot("last")),
		jen.Id("limit").Op(">").Lit(0),
	).BlockFunc(func(limitGroup *jen.Group) {
		limitGroup.If(jen.Id("oneNode")).Block(
			jen.Id("pager").Dot("applyOrder").Call(jen.Id("query").Dot("Limit").Call(jen.Id("limit"))),
		).Else().Block(
			// Use LimitPerRow for multi-node queries - uses target entity package FK column constant
			// Note: Using local LimitPerRow function which uses velox SQL types
			jen.Id("modify").Op(":=").Id("LimitPerRow").Call(
				fkColumnCode,
				jen.Id("limit"),
				jen.Id("pager").Dot("orderExpr").Call(jen.Id("query")),
			),
			jen.Id("query").Dot("modifiers").Op("=").Append(jen.Id("query").Dot("modifiers"), jen.Id("modify")),
		)
	}).Else().Block(
		jen.Id("query").Op("=").Id("pager").Dot("applyOrder").Call(jen.Id("query")),
	)
}

// genLoadTotal generates the loadTotal callback for totalCount queries.
func (g *Generator) genLoadTotal(group *jen.Group, t *gen.Type, e *gen.Edge, edgeIndex int, receiver string) {
	// SQL package path for dialect/sql types
	sqlPkg := "github.com/syssam/velox/dialect/sql"
	// Target entity package for FK column constant (FK is on the target table)
	targetEntityPkg := g.config.ORMPackage + "/" + strings.ToLower(e.Type.Name)
	// FK column code - handles both O2M and M2M edges
	fkColumnCode := g.edgeFKColumnCode(e, t, targetEntityPkg)

	// Clone the query to avoid modifying the original.
	group.Id("query").Op(":=").Id("query").Dot("Clone").Call()

	// Append loadTotal callback
	group.Id(receiver).Dot("loadTotal").Op("=").Append(
		jen.Id(receiver).Dot("loadTotal"),
		jen.Func().Params(
			jen.Id("ctx").Qual("context", "Context"),
			jen.Id("nodes").Index().Op("*").Add(g.ormType(t.Name)),
		).Error().BlockFunc(func(funcGroup *jen.Group) {
			// Collect node IDs for the count query.
			funcGroup.Id("ids").Op(":=").Make(
				jen.Index().Qual("database/sql/driver", "Value"),
				jen.Len(jen.Id("nodes")),
			)
			funcGroup.For(jen.Id("i").Op(":=").Range().Id("nodes")).Block(
				jen.Id("ids").Index(jen.Id("i")).Op("=").Id("nodes").Index(jen.Id("i")).Dot("ID"),
			)

			// Use the actual ID type for the NodeID field in the scan struct
			idType := g.idType(t)

			// var v []struct { NodeID <idType> `sql:"..."` Count int `sql:"count"` }
			funcGroup.Var().Id("v").Index().StructFunc(func(structGroup *jen.Group) {
				structGroup.Id("NodeID").Add(idType).Tag(map[string]string{"sql": g.edgeFKColumn(e)})
				structGroup.Id("Count").Int().Tag(map[string]string{"sql": "count"})
			})

			// query.Where(...) - uses target entity package constant
			funcGroup.Id("query").Dot("Where").Call(
				jen.Func().Params(jen.Id("s").Op("*").Qual(sqlPkg, "Selector")).Block(
					jen.Id("s").Dot("Where").Call(
						jen.Qual(sqlPkg, "InValues").Call(
							jen.Id("s").Dot("C").Call(fkColumnCode),
							jen.Id("ids").Op("..."),
						),
					),
				),
			)

			// if err := query.GroupBy(...).Aggregate(Count()).Scan(ctx, &v); err != nil
			funcGroup.If(
				jen.Err().Op(":=").Id("query").Dot("GroupBy").Call(
					fkColumnCode,
				).Dot("Aggregate").Call(jen.Id("Count").Call()).Dot("Scan").Call(jen.Id("ctx"), jen.Op("&").Id("v")),
				jen.Err().Op("!=").Nil(),
			).Block(
				jen.Return(jen.Err()),
			)

			// m := make(map[<idType>]int, len(v))
			funcGroup.Id("m").Op(":=").Make(jen.Map(idType).Int(), jen.Len(jen.Id("v")))
			funcGroup.For(jen.Id("i").Op(":=").Range().Id("v")).Block(
				jen.Id("m").Index(jen.Id("v").Index(jen.Id("i")).Dot("NodeID")).Op("=").Id("v").Index(jen.Id("i")).Dot("Count"),
			)

			// Populate totalCount on nodes
			funcGroup.For(jen.Id("i").Op(":=").Range().Id("nodes")).Block(
				jen.Id("n").Op(":=").Id("m").Index(jen.Id("nodes").Index(jen.Id("i")).Dot("ID")),
				jen.If(jen.Id("nodes").Index(jen.Id("i")).Dot("Edges").Dot("totalCount").Index(jen.Lit(edgeIndex)).Op("==").Nil()).Block(
					jen.Id("nodes").Index(jen.Id("i")).Dot("Edges").Dot("totalCount").Index(jen.Lit(edgeIndex)).Op("=").Make(jen.Map(jen.String()).Int()),
				),
				jen.Id("nodes").Index(jen.Id("i")).Dot("Edges").Dot("totalCount").Index(jen.Lit(edgeIndex)).Index(jen.Id("alias")).Op("=").Id("n"),
			)

			funcGroup.Return(jen.Nil())
		}),
	)
}

// genEntityPaginateArgs generates the paginateArgs struct and constructor for an entity.
func (g *Generator) genEntityPaginateArgs(f *jen.File, t *gen.Type) {
	typeName := g.graphqlTypeName(t)
	argsType := camel(typeName) + "PaginateArgs"
	newArgsFunc := "new" + typeName + "PaginateArgs"
	optType := typeName + "PaginateOption"
	orderType := typeName + "Order"
	orderFieldType := typeName + "OrderField"
	whereInputType := typeName + "WhereInput"
	multiOrder := g.hasMultiOrder(t)

	// paginateArgs struct
	f.Type().Id(argsType).Struct(
		jen.Id("first").Op(",").Id("last").Op("*").Int(),
		jen.Id("after").Op(",").Id("before").Op("*").Id("Cursor"),
		jen.Id("opts").Index().Id(optType),
	)
	f.Line()

	// newPaginateArgs function
	f.Func().Id(newArgsFunc).Params(
		jen.Id("rv").Map(jen.String()).Any(),
	).Op("*").Id(argsType).BlockFunc(func(group *jen.Group) {
		group.Id("args").Op(":=").Op("&").Id(argsType).Values()
		group.If(jen.Id("rv").Op("==").Nil()).Block(
			jen.Return(jen.Id("args")),
		)

		// first (with safe type assertion)
		group.If(
			jen.List(jen.Id("v"), jen.Id("ok")).Op(":=").Id("rv").Index(jen.Id("firstField")).Assert(jen.Op("*").Int()),
			jen.Id("ok"),
		).Block(
			jen.Id("args").Dot("first").Op("=").Id("v"),
		)
		// last (with safe type assertion)
		group.If(
			jen.List(jen.Id("v"), jen.Id("ok")).Op(":=").Id("rv").Index(jen.Id("lastField")).Assert(jen.Op("*").Int()),
			jen.Id("ok"),
		).Block(
			jen.Id("args").Dot("last").Op("=").Id("v"),
		)
		// after (with safe type assertion)
		group.If(
			jen.List(jen.Id("v"), jen.Id("ok")).Op(":=").Id("rv").Index(jen.Id("afterField")).Assert(jen.Op("*").Id("Cursor")),
			jen.Id("ok"),
		).Block(
			jen.Id("args").Dot("after").Op("=").Id("v"),
		)
		// before (with safe type assertion)
		group.If(
			jen.List(jen.Id("v"), jen.Id("ok")).Op(":=").Id("rv").Index(jen.Id("beforeField")).Assert(jen.Op("*").Id("Cursor")),
			jen.Id("ok"),
		).Block(
			jen.Id("args").Dot("before").Op("=").Id("v"),
		)

		// orderBy handling - different based on MultiOrder
		// Check both global config AND entity-level annotation (SkipOrderField)
		if g.config.Ordering && g.wantsOrderField(t) {
			group.If(
				jen.List(jen.Id("v"), jen.Id("ok")).Op(":=").Id("rv").Index(jen.Id("orderByField")),
				jen.Id("ok"),
			).BlockFunc(func(orderGroup *jen.Group) {
				orderGroup.Switch(jen.Id("v").Op(":=").Id("v").Assert(jen.Type())).BlockFunc(func(sw *jen.Group) {
					if multiOrder {
						// Multi-order case: []*XxxOrder
						sw.Case(jen.Index().Op("*").Id(orderType)).Block(
							jen.Id("args").Dot("opts").Op("=").Append(
								jen.Id("args").Dot("opts"),
								jen.Id("With"+orderType).Call(jen.Id("v")),
							),
						)
						// []any case - need to convert to slice
						sw.Case(jen.Index().Any()).BlockFunc(func(anyCase *jen.Group) {
							anyCase.Var().Id("orders").Index().Op("*").Id(orderType)
							anyCase.For(jen.Id("i").Op(":=").Range().Id("v")).BlockFunc(func(forGroup *jen.Group) {
								forGroup.List(jen.Id("mv"), jen.Id("ok")).Op(":=").Id("v").Index(jen.Id("i")).Assert(jen.Map(jen.String()).Any())
								forGroup.If(jen.Op("!").Id("ok")).Block(jen.Continue())
								forGroup.Var().DefsFunc(func(varGroup *jen.Group) {
									varGroup.List(jen.Id("err1"), jen.Id("err2")).Error()
									varGroup.Id("order").Op("=").Op("&").Id(orderType).Values(jen.Dict{
										jen.Id("Field"):     jen.Op("&").Id(orderFieldType).Values(),
										jen.Id("Direction"): jen.Id("OrderDirectionAsc"),
									})
								})
								forGroup.If(
									jen.List(jen.Id("d"), jen.Id("ok")).Op(":=").Id("mv").Index(jen.Id("directionField")),
									jen.Id("ok"),
								).Block(
									jen.Id("err1").Op("=").Id("order").Dot("Direction").Dot("UnmarshalGQL").Call(jen.Id("d")),
								)
								forGroup.If(
									jen.List(jen.Id("f"), jen.Id("ok")).Op(":=").Id("mv").Index(jen.Id("fieldField")),
									jen.Id("ok"),
								).Block(
									jen.Id("err2").Op("=").Id("order").Dot("Field").Dot("UnmarshalGQL").Call(jen.Id("f")),
								)
								forGroup.If(jen.Id("err1").Op("==").Nil().Op("&&").Id("err2").Op("==").Nil()).Block(
									jen.Id("orders").Op("=").Append(jen.Id("orders"), jen.Id("order")),
								)
							})
							anyCase.Id("args").Dot("opts").Op("=").Append(
								jen.Id("args").Dot("opts"),
								jen.Id("With"+orderType).Call(jen.Id("orders")),
							)
						})
					} else {
						// Single order case: *XxxOrder
						sw.Case(jen.Op("*").Id(orderType)).Block(
							jen.Id("args").Dot("opts").Op("=").Append(
								jen.Id("args").Dot("opts"),
								jen.Id("With"+orderType).Call(jen.Id("v")),
							),
						)
						// map[string]any case - need to convert to single order
						sw.Case(jen.Map(jen.String()).Any()).BlockFunc(func(mapCase *jen.Group) {
							mapCase.Var().DefsFunc(func(varGroup *jen.Group) {
								varGroup.List(jen.Id("err1"), jen.Id("err2")).Error()
								varGroup.Id("order").Op("=").Op("&").Id(orderType).Values(jen.Dict{
									jen.Id("Field"):     jen.Op("&").Id(orderFieldType).Values(),
									jen.Id("Direction"): jen.Id("OrderDirectionAsc"),
								})
							})
							mapCase.If(
								jen.List(jen.Id("d"), jen.Id("ok")).Op(":=").Id("v").Index(jen.Id("directionField")),
								jen.Id("ok"),
							).Block(
								jen.Id("err1").Op("=").Id("order").Dot("Direction").Dot("UnmarshalGQL").Call(jen.Id("d")),
							)
							mapCase.If(
								jen.List(jen.Id("f"), jen.Id("ok")).Op(":=").Id("v").Index(jen.Id("fieldField")),
								jen.Id("ok"),
							).Block(
								jen.Id("err2").Op("=").Id("order").Dot("Field").Dot("UnmarshalGQL").Call(jen.Id("f")),
							)
							mapCase.If(jen.Id("err1").Op("==").Nil().Op("&&").Id("err2").Op("==").Nil()).Block(
								jen.Id("args").Dot("opts").Op("=").Append(
									jen.Id("args").Dot("opts"),
									jen.Id("With"+orderType).Call(jen.Id("order")),
								),
							)
						})
					}
				})
			})
		}

		// where handling - check both global config AND entity-level annotation (SkipWhereInput)
		if g.config.WhereInputs && g.wantsWhereInput(t) {
			group.If(
				jen.List(jen.Id("v"), jen.Id("ok")).Op(":=").Id("rv").Index(jen.Id("whereField")).Assert(jen.Op("*").Id(whereInputType)),
				jen.Id("ok"),
			).Block(
				jen.Id("args").Dot("opts").Op("=").Append(
					jen.Id("args").Dot("opts"),
					jen.Id("With"+typeName+"Filter").Call(jen.Id("v").Dot("Filter")),
				),
			)
		}

		group.Return(jen.Id("args"))
	})
	f.Line()
}

// genCollectionHelpers generates helper functions following Ent's pattern.
// Note: collectedField, hasCollectedField, paginateLimit are generated in gql_pagination.go
func (g *Generator) genCollectionHelpers(f *jen.File) {
	gqlgenPkg := "github.com/99designs/gqlgen/graphql"

	// fieldArgs - extracts field arguments from context
	f.Comment("fieldArgs extracts the field arguments from the resolver context.")
	f.Func().Id("fieldArgs").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("whereInput").Any(),
		jen.Id("path").Op("...").String(),
	).Map(jen.String()).Any().Block(
		jen.Id("field").Op(":=").Id("collectedField").Call(jen.Id("ctx"), jen.Id("path").Op("...")),
		jen.If(jen.Id("field").Op("==").Nil().Op("||").Id("field").Dot("Arguments").Op("==").Nil()).Block(
			jen.Return(jen.Nil()),
		),
		jen.Id("oc").Op(":=").Qual(gqlgenPkg, "GetOperationContext").Call(jen.Id("ctx")),
		jen.Id("args").Op(":=").Id("field").Dot("ArgumentMap").Call(jen.Id("oc").Dot("Variables")),
		jen.Return(jen.Id("unmarshalArgs").Call(jen.Id("ctx"), jen.Id("whereInput"), jen.Id("args"))),
	)
	f.Line()

	// unmarshalArgs - unmarshals field arguments
	f.Comment("unmarshalArgs allows extracting the field arguments from their raw representation.")
	f.Func().Id("unmarshalArgs").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("whereInput").Any(),
		jen.Id("args").Map(jen.String()).Any(),
	).Map(jen.String()).Any().BlockFunc(func(group *jen.Group) {
		// Unmarshal first/last as *int
		group.For(jen.List(jen.Id("_"), jen.Id("k")).Op(":=").Range().Index().String().Values(jen.Id("firstField"), jen.Id("lastField"))).Block(
			jen.List(jen.Id("v"), jen.Id("ok")).Op(":=").Id("args").Index(jen.Id("k")),
			jen.If(jen.Op("!").Id("ok").Op("||").Id("v").Op("==").Nil()).Block(jen.Continue()),
			jen.List(jen.Id("i"), jen.Id("err")).Op(":=").Qual(gqlgenPkg, "UnmarshalInt").Call(jen.Id("v")),
			jen.If(jen.Id("err").Op("==").Nil()).Block(
				jen.Id("args").Index(jen.Id("k")).Op("=").Op("&").Id("i"),
			),
		)
		// Unmarshal before/after as *Cursor
		group.For(jen.List(jen.Id("_"), jen.Id("k")).Op(":=").Range().Index().String().Values(jen.Id("beforeField"), jen.Id("afterField"))).Block(
			jen.List(jen.Id("v"), jen.Id("ok")).Op(":=").Id("args").Index(jen.Id("k")),
			jen.If(jen.Op("!").Id("ok")).Block(jen.Continue()),
			jen.Id("c").Op(":=").Op("&").Id("Cursor").Values(),
			jen.If(jen.Id("c").Dot("UnmarshalGQL").Call(jen.Id("v")).Op("==").Nil()).Block(
				jen.Id("args").Index(jen.Id("k")).Op("=").Id("c"),
			),
		)
		// Unmarshal where input
		group.If(
			jen.List(jen.Id("v"), jen.Id("ok")).Op(":=").Id("args").Index(jen.Id("whereField")),
			jen.Id("ok").Op("&&").Id("whereInput").Op("!=").Nil(),
		).Block(
			jen.If(jen.Qual(gqlgenPkg, "UnmarshalInputFromContext").Call(jen.Id("ctx"), jen.Id("v"), jen.Id("whereInput")).Op("==").Nil()).Block(
				jen.Id("args").Index(jen.Id("whereField")).Op("=").Id("whereInput"),
			),
		)
		group.Return(jen.Id("args"))
	})
	f.Line()

	// mayAddCondition - appends type conditions to satisfies list
	f.Comment("mayAddCondition appends another type condition to the satisfies list if it does not exist.")
	f.Func().Id("mayAddCondition").Params(
		jen.Id("satisfies").Index().String(),
		jen.Id("typeCond").Index().String(),
	).Index().String().Block(
		jen.Id("Cond").Op(":"),
		jen.For(jen.List(jen.Id("_"), jen.Id("c")).Op(":=").Range().Id("typeCond")).Block(
			jen.For(jen.List(jen.Id("_"), jen.Id("s")).Op(":=").Range().Id("satisfies")).Block(
				jen.If(jen.Id("c").Op("==").Id("s")).Block(
					jen.Continue().Id("Cond"),
				),
			),
			jen.Id("satisfies").Op("=").Append(jen.Id("satisfies"), jen.Id("c")),
		),
		jen.Return(jen.Id("satisfies")),
	)
	f.Line()
}

// nodeImplementorsVar returns the variable name for a type's implementors slice.
// Must match the variable naming in node.go (lowercase first letter only, not full camelCase).
func nodeImplementorsVar(t *gen.Type) string {
	// Same logic as node.go: lowercase first letter + rest of name
	return strings.ToLower(t.Name[:1]) + t.Name[1:] + "Implementors"
}

// edgeFKColumn returns the FK column name for an edge.
func (g *Generator) edgeFKColumn(e *gen.Edge) string {
	// Return the actual column name
	// For a one-to-many edge like Category->todos, the FK is on the todo table
	// and is named after the source type (e.g., category_id)
	if e.Ref != nil && e.Ref.Name != "" {
		return toSnakeCase(e.Ref.Name) + "_id"
	}
	// FK column is named after the owner of the edge (the source type)
	if e.Owner != nil {
		return toSnakeCase(e.Owner.Name) + "_id"
	}
	// Fallback to edge type name (with nil guard)
	if e.Type != nil {
		return toSnakeCase(e.Type.Name) + "_id"
	}
	return toSnakeCase(e.Name) + "_id"
}

// edgeFKColumnConstant returns the FK column constant name for an edge.
// This is the constant in the target entity package that references the FK column.
// For example, for Category->todos edge, this returns "CategoryColumn" which would be defined in the todo package.
// For M2M edges, returns empty string since M2M edges use PrimaryKey array.
func (g *Generator) edgeFKColumnConstant(e *gen.Edge) string {
	// M2M edges use {EdgeName}PrimaryKey[0] instead of a simple column constant
	if e.M2M() {
		return ""
	}
	// In ent, the FK column constant is named after the back-reference edge or the FK field
	// For a Category->todos edge, the constant in todo package would be:
	// - CategoryColumn (if there's a "category" back-reference edge)
	// - FieldCategoryID (if it's just a FK field)
	if e.Ref != nil && e.Ref.Name != "" {
		// Back-reference edge exists, use its name
		return pascal(e.Ref.Name) + "Column"
	}
	// Use the owner type name as the FK field name
	if e.Owner != nil {
		return "Field" + pascal(e.Owner.Name) + "ID"
	}
	// Fallback to edge type name (with nil guard)
	if e.Type != nil {
		return "Field" + pascal(e.Type.Name) + "ID"
	}
	return "Field" + pascal(e.Name) + "ID"
}

// edgeFKColumnCode returns the Jennifer code for the FK column reference.
// For O2M edges, returns Qual(targetPkg, "XxxColumn")
// For M2M edges, returns Qual(currentPkg, "XxxPrimaryKey").Index(Lit(0))
// The currentType parameter is the entity type where we're generating code.
// Note: M2M edges have their PrimaryKey constants in the entity package where the edge is defined,
// which is the currentType (not necessarily the Owner for back-reference edges).
func (g *Generator) edgeFKColumnCode(e *gen.Edge, currentType *gen.Type, targetEntityPkg string) jen.Code {
	// Guard against nil currentType (defensive programming)
	if currentType == nil {
		return jen.Qual(targetEntityPkg, g.edgeFKColumnConstant(e))
	}
	if e.M2M() {
		// M2M edges use {EdgeName}PrimaryKey[0]
		// The PrimaryKey constant is in the current entity's package where the edge is defined,
		// NOT the Owner's package (Owner is where edge.To is defined, which may differ for edge.From back-references)
		currentEntityPkg := g.config.ORMPackage + "/" + strings.ToLower(currentType.Name)
		return jen.Qual(currentEntityPkg, pascal(e.Name)+"PrimaryKey").Index(jen.Lit(0))
	}
	// O2M edges use the column constant directly
	return jen.Qual(targetEntityPkg, g.edgeFKColumnConstant(e))
}

// =============================================================================
// Edge resolvers - separate from collection
// =============================================================================

// genEdgeResolvers generates gql_edge.go with edge resolver methods on entity structs.
// This follows entgql's edge.tmpl pattern:
//   - Methods are defined on the entity struct (e.g., *User), NOT a separate resolver
//   - Uses Edges.XxxOrErr() to check if edge is loaded
//   - Uses IsNotLoaded(err) to determine if lazy loading is needed
//   - For optional edges, uses MaskNotFound(err) to return nil instead of not found error
func (g *Generator) genEdgeResolvers() *jen.File {
	if g.config.ORMPackage == "" {
		return nil
	}

	f := jen.NewFile(g.config.Package)
	f.HeaderComment("Code generated by velox. DO NOT EDIT.")

	// Import gqlgen graphql for GetFieldContext
	f.ImportName("github.com/99designs/gqlgen/graphql", "graphql")

	// Generate edge resolver methods for each entity
	// Use filterNodes helper (like Ent)
	nodes := g.filterNodes(g.graph.Nodes, SkipType)
	for _, t := range nodes {
		// Track edge index for totalCount array access
		edgeIndex := 0

		// Generate edge resolver methods directly on entity struct
		// Use filterEdges helper (like Ent)
		edges := g.filterEdges(t.Edges, SkipType)
		for _, e := range edges {
			g.genEdgeResolver(f, t, e, edgeIndex)
			edgeIndex++
		}
	}

	return f
}

// genEdgeResolver generates a resolver method for a single edge on the entity struct.
// Following entgql's edge.tmpl pattern exactly.
func (g *Generator) genEdgeResolver(f *jen.File, t *gen.Type, e *gen.Edge, edgeIndex int) {
	// Guard against nil edge type
	if e.Type == nil {
		return
	}
	// Ent uses "_m" as receiver for all entity edge resolvers
	receiver := "_m"
	methodName := pascal(e.Name)

	switch {
	case g.config.RelayConnection && g.hasRelayConnection(e.Type) && !e.Unique:
		// Relay connection edge - complex paginated resolver
		g.genRelayConnectionEdgeResolver(f, t, e, edgeIndex)
	case e.Unique:
		// Unique edge - returns single entity
		// Pattern: func (_m *Todo) Parent(ctx context.Context) (*Todo, error)
		f.Func().Params(
			jen.Id(receiver).Add(g.ormTypePtr(t.Name)),
		).Id(methodName).Params(
			jen.Id("ctx").Qual("context", "Context"),
		).Params(
			g.ormTypePtr(e.Type.Name),
			jen.Error(),
		).BlockFunc(func(group *jen.Group) {
			// Optimization: Skip DB query if optional FK is empty/zero (no relationship).
			if fkField := e.Field(); fkField != nil && e.Optional {
				if cond := fkZeroCheck(fkField, receiver); cond != nil {
					group.If(cond).Block(jen.Return(jen.Nil(), jen.Nil()))
				}
			}

			// First try to get the edge from the loaded edges struct.
			group.List(jen.Id("result"), jen.Id("err")).Op(":=").
				Id(receiver).Dot("Edges").Dot(methodName + "OrErr").Call()

			// If not loaded, fall back to querying the database.
			group.If(jen.Id("IsNotLoaded").Call(jen.Id("err"))).Block(
				jen.List(jen.Id("result"), jen.Id("err")).Op("=").
					Id(receiver).Dot("Query" + methodName).Call().Dot("Only").Call(jen.Id("ctx")),
			)

			// return result, MaskNotFound(err) - Ent always masks for unique edges
			group.Return(jen.Id("result"), jen.Id("MaskNotFound").Call(jen.Id("err")))
		})
	default:
		// Non-unique edge (list) - returns slice
		// Pattern: func (_m *Category) Todos(ctx context.Context) (result []*Todo, err error)
		f.Func().Params(
			jen.Id(receiver).Add(g.ormTypePtr(t.Name)),
		).Id(methodName).Params(
			jen.Id("ctx").Qual("context", "Context"),
		).Params(
			// Ent uses named return: (result []*Todo, err error)
			jen.Id("result").Index().Add(g.ormTypePtr(e.Type.Name)),
			jen.Id("err").Error(),
		).BlockFunc(func(group *jen.Group) {
			// Use named edge if available (supports multiple edge instances with aliases),
			// otherwise fall back to the standard edge accessor.
			group.If(
				jen.Id("fc").Op(":=").Qual("github.com/99designs/gqlgen/graphql", "GetFieldContext").Call(jen.Id("ctx")),
				jen.Id("fc").Op("!=").Nil().Op("&&").Id("fc").Dot("Field").Dot("Alias").Op("!=").Lit(""),
			).Block(
				jen.List(jen.Id("result"), jen.Id("err")).Op("=").
					Id(receiver).Dot("Named" + methodName).Call(
					jen.Qual("github.com/99designs/gqlgen/graphql", "GetFieldContext").Call(jen.Id("ctx")).Dot("Field").Dot("Alias"),
				),
			).Else().Block(
				jen.List(jen.Id("result"), jen.Id("err")).Op("=").
					Id(receiver).Dot("Edges").Dot(methodName + "OrErr").Call(),
			)

			// If not loaded, fall back to querying the database.
			group.If(jen.Id("IsNotLoaded").Call(jen.Id("err"))).Block(
				jen.List(jen.Id("result"), jen.Id("err")).Op("=").
					Id(receiver).Dot("Query" + methodName).Call().Dot("All").Call(jen.Id("ctx")),
			)

			group.Return(jen.Id("result"), jen.Id("err"))
		})
	}
	f.Line()
}

// genRelayConnectionEdgeResolver generates a Relay connection resolver for an edge.
// Pattern: func (_m *Category) Todos(ctx, after, first, before, last, orderBy, where) (*TodoConnection, error)
func (g *Generator) genRelayConnectionEdgeResolver(f *jen.File, t *gen.Type, e *gen.Edge, edgeIndex int) {
	// Guard against nil edge type
	if e.Type == nil {
		return
	}
	// Ent uses "_m" as receiver for all entity edge resolvers
	receiver := "_m"
	methodName := pascal(e.Name)
	targetTypeName := g.graphqlTypeName(e.Type)
	multiOrder := g.hasMultiOrder(e.Type)

	// Build parameter list matching Ent's exact order
	params := []jen.Code{
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("after").Op("*").Id("Cursor"),
		jen.Id("first").Op("*").Int(),
		jen.Id("before").Op("*").Id("Cursor"),
		jen.Id("last").Op("*").Int(),
	}

	// Add orderBy if ordering is enabled - check both global config AND edge/type-level annotation
	wantsOrder := g.config.Ordering && g.hasOrderField(e)
	if wantsOrder {
		if multiOrder {
			params = append(params, jen.Id("orderBy").Index().Op("*").Id(targetTypeName+"Order"))
		} else {
			params = append(params, jen.Id("orderBy").Op("*").Id(targetTypeName+"Order"))
		}
	}

	// Add where if where inputs are enabled - check both global config AND edge/type-level annotation
	wantsWhere := g.config.WhereInputs && g.hasWhereInput(e)
	if wantsWhere {
		params = append(params, jen.Id("where").Op("*").Id(targetTypeName+"WhereInput"))
	}

	f.Func().Params(
		jen.Id(receiver).Add(g.ormTypePtr(t.Name)),
	).Id(methodName).Params(params...).Params(
		jen.Op("*").Id(targetTypeName+"Connection"),
		jen.Error(),
	).BlockFunc(func(group *jen.Group) {
		// Build opts slice
		group.Id("opts").Op(":=").Index().Id(targetTypeName + "PaginateOption").ValuesFunc(func(opts *jen.Group) {
			if wantsOrder {
				opts.Id("With" + targetTypeName + "Order").Call(jen.Id("orderBy"))
			}
			if wantsWhere {
				opts.Id("With" + targetTypeName + "Filter").Call(jen.Id("where").Dot("Filter"))
			}
		})

		// Get field alias for named edges
		group.Id("alias").Op(":=").Qual("github.com/99designs/gqlgen/graphql", "GetFieldContext").Call(jen.Id("ctx")).Dot("Field").Dot("Alias")

		// Get totalCount from Edges.totalCount[edgeIndex][alias]
		group.List(jen.Id("totalCount"), jen.Id("hasTotalCount")).Op(":=").
			Id(receiver).Dot("Edges").Dot("totalCount").Index(jen.Lit(edgeIndex)).Index(jen.Id("alias"))

		// Check if nodes were loaded via named edge OR totalCount was loaded
		group.If(
			jen.List(jen.Id("nodes"), jen.Id("err")).Op(":=").Id(receiver).Dot("Named"+methodName).Call(jen.Id("alias")),
			jen.Id("err").Op("==").Nil().Op("||").Id("hasTotalCount"),
		).BlockFunc(func(ifGroup *jen.Group) {
			// Nodes were loaded, build connection from them
			ifGroup.List(jen.Id("pager"), jen.Id("err")).Op(":=").Id("new"+targetTypeName+"Pager").Call(jen.Id("opts"), jen.Id("last").Op("!=").Nil())
			ifGroup.If(jen.Id("err").Op("!=").Nil()).Block(
				jen.Return(jen.Nil(), jen.Id("err")),
			)
			// Ensure "edges" field is marshaled as "[]" in case it is empty
			ifGroup.Id("conn").Op(":=").Op("&").Id(targetTypeName + "Connection").Values(jen.Dict{
				jen.Id("Edges"):      jen.Index().Op("*").Id(targetTypeName + "Edge").Values(),
				jen.Id("TotalCount"): jen.Id("totalCount"),
			})
			ifGroup.Id("conn").Dot("build").Call(
				jen.Id("nodes"), jen.Id("pager"), jen.Id("after"), jen.Id("first"), jen.Id("before"), jen.Id("last"),
			)
			ifGroup.Return(jen.Id("conn"), jen.Nil())
		})

		// Fall back to query with pagination
		group.Return(
			jen.Id(receiver).Dot("Query"+methodName).Call().Dot("Paginate").Call(
				jen.Id("ctx"), jen.Id("after"), jen.Id("first"), jen.Id("before"), jen.Id("last"), jen.Id("opts").Op("..."),
			),
		)
	})
}

// typeReceiver generates a receiver name for a type following Ent's convention.
// Examples:
//
//	User      => u
//	Category  => c
//	OneToMany => otm
//	Group     => gr (avoids conflict with 'g')
func typeReceiver(name string) string {
	// Convert to snake_case and split
	s := toSnakeCase(name)
	parts := strings.Split(s, "_")

	// Take first character of each part
	var r strings.Builder
	for _, part := range parts {
		if part != "" {
			r.WriteByte(part[0])
		}
	}

	result := r.String()
	if result == "" {
		return strings.ToLower(name[:1])
	}

	// Handle single-letter conflicts (e.g., 'g' for Group might conflict)
	// If it's a single letter, keep it; otherwise return abbreviation
	return result
}

// toSnakeCase converts a PascalCase string to snake_case.
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if unicode.IsUpper(r) {
			if i > 0 {
				result.WriteByte('_')
			}
			result.WriteRune(unicode.ToLower(r))
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

// fkZeroCheck returns the zero-value check condition for a FK field as jen.Code.
// For Nillable fields (pointer types): checks field == nil
// For Optional fields (value types): checks field == zero value
// Returns nil if the field type doesn't support zero-value optimization.
func fkZeroCheck(f *gen.Field, receiver string) jen.Code {
	if f == nil || f.Type == nil {
		return nil
	}
	// Nillable fields are pointers - check for nil
	if f.Nillable {
		return jen.Id(receiver).Dot(f.StructField()).Op("==").Nil()
	}
	// Optional (non-Nillable) fields - check for zero value
	switch t := f.Type.Type; {
	case t == field.TypeString:
		return jen.Id(receiver).Dot(f.StructField()).Op("==").Lit("")
	case t.Integer():
		return jen.Id(receiver).Dot(f.StructField()).Op("==").Lit(0)
	case t.Float():
		return jen.Id(receiver).Dot(f.StructField()).Op("==").Lit(0)
	case t == field.TypeUUID && f.Type.PkgPath != "":
		return jen.Id(receiver).Dot(f.StructField()).Op("==").Qual(f.Type.PkgPath, "Nil")
	default:
		return nil
	}
}

// queryReceiverName generates a query builder receiver name following Ent's convention.
// Takes first letter of each word in PascalCase and appends "q".
// Examples: Category → cq, Todo → tq, BillProduct → bpq, OneToMany → otmq
func queryReceiverName(name string) string {
	var result strings.Builder
	for i, r := range name {
		if unicode.IsUpper(r) {
			// First uppercase letter or new word
			result.WriteRune(unicode.ToLower(r))
		} else if i == 0 {
			// Handle names that don't start with uppercase
			result.WriteRune(r)
		}
		// Skip lowercase letters in the middle of words
	}
	result.WriteByte('q')
	return result.String()
}

// idType returns the Jennifer code for the ID field type of a type.
// Returns the appropriate Go type based on the field type.
func (g *Generator) idType(t *gen.Type) jen.Code {
	if t.ID == nil || t.ID.Type == nil {
		// Default to int64 if no ID field defined
		return jen.Int64()
	}
	switch t.ID.Type.Type {
	case field.TypeInt:
		return jen.Int()
	case field.TypeInt8:
		return jen.Int8()
	case field.TypeInt16:
		return jen.Int16()
	case field.TypeInt32:
		return jen.Int32()
	case field.TypeInt64:
		return jen.Int64()
	case field.TypeUint:
		return jen.Uint()
	case field.TypeUint8:
		return jen.Uint8()
	case field.TypeUint16:
		return jen.Uint16()
	case field.TypeUint32:
		return jen.Uint32()
	case field.TypeUint64:
		return jen.Uint64()
	case field.TypeString:
		return jen.String()
	case field.TypeUUID:
		return jen.Qual("github.com/google/uuid", "UUID")
	default:
		// Default to int64 for unknown types
		return jen.Int64()
	}
}
