package graphql

// This file generates Relay cursor-based pagination (gql_pagination.go).
// It provides:
//   - Cursor, PageInfo, and OrderDirection types
//   - XXXConnection and XXXEdge types for each entity
//   - XXXOrder and XXXOrderField for sorting
//   - Paginate method on query builders
//   - LimitPerRow helper for efficient nested pagination

import (
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/syssam/velox/compiler/gen"
)

// genPagination generates gql_pagination.go with Relay cursor-based pagination.
// This generates all pagination types locally without external dependencies.
func (g *Generator) genPagination() *jen.File {
	if g.config.ORMPackage == "" {
		return nil
	}

	f := jen.NewFile(g.config.Package)
	f.HeaderComment("Code generated by velox. DO NOT EDIT.")

	// Imports
	f.ImportName("context", "context")
	f.ImportName("io", "io")
	f.ImportName("strconv", "strconv")
	f.ImportName("encoding/base64", "base64")
	f.ImportName("errors", "errors")
	f.ImportName("fmt", "fmt")

	// Entity package imports - use filterNodes helper (like Ent)
	nodes := g.filterNodes(g.graph.Nodes, SkipType)
	for _, t := range nodes {
		if !g.hasRelayConnection(t) {
			continue
		}
		entityPkg := g.config.ORMPackage + "/" + strings.ToLower(t.Name)
		f.ImportName(entityPkg, strings.ToLower(t.Name))
	}

	// Predicate package import
	f.ImportName(g.config.ORMPackage+"/predicate", "predicate")

	// External imports
	f.ImportName("github.com/syssam/velox/dialect/sql", "sql")
	f.ImportName("github.com/99designs/gqlgen/graphql", "graphql")
	f.ImportName("github.com/vmihailenco/msgpack/v5", "msgpack")

	// Generate OrderDirection type and constants
	g.genOrderDirection(f)

	// Generate Cursor type
	g.genCursorType(f)

	// Generate PageInfo type
	g.genPageInfoType(f)

	f.Line()

	// orderFunc helper
	g.genOrderFunc(f)

	// directionOrderTerm helper
	g.genDirectionOrderTerm(f)

	// cursorsPredicate helper
	g.genCursorsPredicate(f)

	// validateFirstLast helper
	g.genValidateFirstLast(f)

	// collectedField helper
	g.genCollectedField(f)

	// hasCollectedField helper
	g.genHasCollectedField(f)

	// Field name constants
	g.genFieldConstants(f)

	// paginateLimit helper
	g.genPaginateLimit(f)

	// Generate per-entity pagination types - use filterNodes helper (like Ent)
	paginationNodes := g.filterNodes(g.graph.Nodes, SkipType)
	for _, t := range paginationNodes {
		if !g.hasRelayConnection(t) {
			continue
		}
		g.genEntityPaginationTypes(f, t)
	}

	// Generate LimitPerRow helper (velox-compatible version of entgql.LimitPerRow)
	g.genLimitPerRow(f)

	return f
}

// genOrderFunc generates the orderFunc helper.
func (g *Generator) genOrderFunc(f *jen.File) {
	f.Func().Id("orderFunc").Params(
		jen.Id("o").Id("OrderDirection"),
		jen.Id("field").String(),
	).Func().Params(jen.Op("*").Qual("github.com/syssam/velox/dialect/sql", "Selector")).Block(
		jen.If(jen.Id("o").Op("==").Id("OrderDirectionDesc")).Block(
			jen.Return(jen.Id("Desc").Call(jen.Id("field"))),
		),
		jen.Return(jen.Id("Asc").Call(jen.Id("field"))),
	)
	f.Line()
}

// genDirectionOrderTerm generates a helper to convert OrderDirection to sql.OrderTermOption.
func (g *Generator) genDirectionOrderTerm(f *jen.File) {
	f.Comment("directionOrderTerm converts OrderDirection to sql.OrderTermOption.")
	f.Func().Id("directionOrderTerm").Params(
		jen.Id("d").Id("OrderDirection"),
	).Qual("github.com/syssam/velox/dialect/sql", "OrderTermOption").Block(
		jen.If(jen.Id("d").Op("==").Id("OrderDirectionDesc")).Block(
			jen.Return(jen.Qual("github.com/syssam/velox/dialect/sql", "OrderDesc").Call()),
		),
		jen.Return(jen.Qual("github.com/syssam/velox/dialect/sql", "OrderAsc").Call()),
	)
	f.Line()
}

// genCursorsPredicate generates the cursorsPredicate helper using Velox's sql package.
// This implements proper cursor-based pagination that handles non-unique order fields
// by using a composite comparison: (field, id) > (cursor.Value, cursor.ID)
func (g *Generator) genCursorsPredicate(f *jen.File) {
	sqlPkg := "github.com/syssam/velox/dialect/sql"

	f.Comment("cursorsPredicate converts cursors to Velox-compatible predicates.")
	f.Comment("It uses composite comparison (field, id) to handle non-unique order fields correctly.")
	f.Func().Id("cursorsPredicate").Params(
		jen.Id("after").Op("*").Id("Cursor"),
		jen.Id("before").Op("*").Id("Cursor"),
		jen.Id("idField").String(),
		jen.Id("field").String(),
		jen.Id("direction").Id("OrderDirection"),
	).Index().Func().Params(jen.Op("*").Qual(sqlPkg, "Selector")).BlockFunc(func(group *jen.Group) {
		group.Var().Id("predicates").Index().Func().Params(jen.Op("*").Qual(sqlPkg, "Selector"))

		// Helper to generate composite cursor predicate
		// For ascending: (field > value) OR (field = value AND id > cursorID)
		// For descending: (field < value) OR (field = value AND id < cursorID)
		group.If(jen.Id("after").Op("!=").Nil()).BlockFunc(func(afterGroup *jen.Group) {
			afterGroup.If(jen.Id("direction").Op("==").Id("OrderDirectionAsc")).Block(
				jen.Id("predicates").Op("=").Append(
					jen.Id("predicates"),
					jen.Func().Params(jen.Id("s").Op("*").Qual(sqlPkg, "Selector")).Block(
						jen.Id("s").Dot("Where").Call(
							jen.Qual(sqlPkg, "CompositeGT").Call(
								jen.Index().String().Values(jen.Id("field"), jen.Id("idField")),
								jen.Id("after").Dot("Value"),
								jen.Id("after").Dot("ID"),
							),
						),
					),
				),
			).Else().Block(
				jen.Id("predicates").Op("=").Append(
					jen.Id("predicates"),
					jen.Func().Params(jen.Id("s").Op("*").Qual(sqlPkg, "Selector")).Block(
						jen.Id("s").Dot("Where").Call(
							jen.Qual(sqlPkg, "CompositeLT").Call(
								jen.Index().String().Values(jen.Id("field"), jen.Id("idField")),
								jen.Id("after").Dot("Value"),
								jen.Id("after").Dot("ID"),
							),
						),
					),
				),
			)
		})

		group.If(jen.Id("before").Op("!=").Nil()).BlockFunc(func(beforeGroup *jen.Group) {
			beforeGroup.If(jen.Id("direction").Op("==").Id("OrderDirectionAsc")).Block(
				jen.Id("predicates").Op("=").Append(
					jen.Id("predicates"),
					jen.Func().Params(jen.Id("s").Op("*").Qual(sqlPkg, "Selector")).Block(
						jen.Id("s").Dot("Where").Call(
							jen.Qual(sqlPkg, "CompositeLT").Call(
								jen.Index().String().Values(jen.Id("field"), jen.Id("idField")),
								jen.Id("before").Dot("Value"),
								jen.Id("before").Dot("ID"),
							),
						),
					),
				),
			).Else().Block(
				jen.Id("predicates").Op("=").Append(
					jen.Id("predicates"),
					jen.Func().Params(jen.Id("s").Op("*").Qual(sqlPkg, "Selector")).Block(
						jen.Id("s").Dot("Where").Call(
							jen.Qual(sqlPkg, "CompositeGT").Call(
								jen.Index().String().Values(jen.Id("field"), jen.Id("idField")),
								jen.Id("before").Dot("Value"),
								jen.Id("before").Dot("ID"),
							),
						),
					),
				),
			)
		})

		group.Return(jen.Id("predicates"))
	})
	f.Line()
}

// genValidateFirstLast generates the validateFirstLast helper.
// This validates:
//   - first/last aren't both passed together
//   - first/last aren't negative
//   - first/last don't exceed MaxPaginationLimit (security: prevent loading millions of rows)
func (g *Generator) genValidateFirstLast(f *jen.File) {
	// MaxPaginationLimit constant - prevents DoS attacks via excessive pagination
	f.Comment("MaxPaginationLimit is the maximum number of items that can be requested in a single page.")
	f.Comment("This prevents clients from requesting excessive amounts of data.")
	f.Const().Id("MaxPaginationLimit").Op("=").Lit(1000)
	f.Line()

	// Pagination error messages - generic to avoid leaking internal details
	f.Comment("Pagination validation errors - generic messages for security.")
	f.Var().DefsFunc(func(g *jen.Group) {
		g.Id("ErrInvalidPagination").Op("=").Qual("errors", "New").Call(jen.Lit("invalid pagination parameters"))
		g.Id("ErrPaginationLimitExceeded").Op("=").Qual("errors", "New").Call(jen.Lit("pagination limit exceeded"))
	})
	f.Line()

	f.Func().Id("validateFirstLast").Params(
		jen.Id("first").Op("*").Int(),
		jen.Id("last").Op("*").Int(),
	).Error().BlockFunc(func(group *jen.Group) {
		group.Switch().BlockFunc(func(sw *jen.Group) {
			// Both first and last passed - invalid
			sw.Case(jen.Id("first").Op("!=").Nil().Op("&&").Id("last").Op("!=").Nil()).Block(
				jen.Return(jen.Id("ErrInvalidPagination")),
			)
			// Negative values - invalid
			sw.Case(jen.Id("first").Op("!=").Nil().Op("&&").Op("*").Id("first").Op("<").Lit(0)).Block(
				jen.Return(jen.Id("ErrInvalidPagination")),
			)
			sw.Case(jen.Id("last").Op("!=").Nil().Op("&&").Op("*").Id("last").Op("<").Lit(0)).Block(
				jen.Return(jen.Id("ErrInvalidPagination")),
			)
			// Exceeds limit - security: don't reveal exact limit value
			sw.Case(jen.Id("first").Op("!=").Nil().Op("&&").Op("*").Id("first").Op(">").Id("MaxPaginationLimit")).Block(
				jen.Return(jen.Id("ErrPaginationLimitExceeded")),
			)
			sw.Case(jen.Id("last").Op("!=").Nil().Op("&&").Op("*").Id("last").Op(">").Id("MaxPaginationLimit")).Block(
				jen.Return(jen.Id("ErrPaginationLimitExceeded")),
			)
		})
		group.Return(jen.Nil())
	})
	f.Line()
}

// genCollectedField generates the collectedField helper.
func (g *Generator) genCollectedField(f *jen.File) {
	f.Func().Id("collectedField").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("path").Op("...").String(),
	).Op("*").Qual("github.com/99designs/gqlgen/graphql", "CollectedField").Block(
		jen.Id("fc").Op(":=").Qual("github.com/99designs/gqlgen/graphql", "GetFieldContext").Call(jen.Id("ctx")),
		jen.If(jen.Id("fc").Op("==").Nil()).Block(
			jen.Return(jen.Nil()),
		),
		jen.Id("field").Op(":=").Id("fc").Dot("Field"),
		jen.Id("oc").Op(":=").Qual("github.com/99designs/gqlgen/graphql", "GetOperationContext").Call(jen.Id("ctx")),
		jen.Id("walk").Op(":"),
		jen.For(jen.List(jen.Id("_"), jen.Id("name")).Op(":=").Range().Id("path")).Block(
			jen.For(jen.List(jen.Id("_"), jen.Id("f")).Op(":=").Range().Qual("github.com/99designs/gqlgen/graphql", "CollectFields").Call(
				jen.Id("oc"),
				jen.Id("field").Dot("Selections"),
				jen.Nil(),
			)).Block(
				jen.If(jen.Id("f").Dot("Alias").Op("==").Id("name")).Block(
					jen.Id("field").Op("=").Id("f"),
					jen.Continue().Id("walk"),
				),
			),
			jen.Return(jen.Nil()),
		),
		jen.Return(jen.Op("&").Id("field")),
	)
	f.Line()
}

// genHasCollectedField generates the hasCollectedField helper.
func (g *Generator) genHasCollectedField(f *jen.File) {
	f.Func().Id("hasCollectedField").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("path").Op("...").String(),
	).Bool().Block(
		jen.If(jen.Qual("github.com/99designs/gqlgen/graphql", "GetFieldContext").Call(jen.Id("ctx")).Op("==").Nil()).Block(
			jen.Return(jen.True()),
		),
		jen.Return(jen.Id("collectedField").Call(jen.Id("ctx"), jen.Id("path").Op("...")).Op("!=").Nil()),
	)
	f.Line()
}

// genFieldConstants generates the field name constants.
func (g *Generator) genFieldConstants(f *jen.File) {
	f.Const().DefsFunc(func(group *jen.Group) {
		group.Id("edgesField").Op("=").Lit("edges")
		group.Id("nodeField").Op("=").Lit("node")
		group.Id("pageInfoField").Op("=").Lit("pageInfo")
		group.Id("totalCountField").Op("=").Lit("totalCount")
	})
	f.Line()
}

// genPaginateLimit generates the paginateLimit helper.
func (g *Generator) genPaginateLimit(f *jen.File) {
	f.Func().Id("paginateLimit").Params(
		jen.Id("first").Op("*").Int(),
		jen.Id("last").Op("*").Int(),
	).Int().Block(
		jen.Var().Id("limit").Int(),
		jen.If(jen.Id("first").Op("!=").Nil()).Block(
			jen.Id("limit").Op("=").Op("*").Id("first").Op("+").Lit(1),
		).Else().If(jen.Id("last").Op("!=").Nil()).Block(
			jen.Id("limit").Op("=").Op("*").Id("last").Op("+").Lit(1),
		),
		jen.Return(jen.Id("limit")),
	)
	f.Line()
}

// genEntityPaginationTypes generates all pagination types for a single entity.
func (g *Generator) genEntityPaginationTypes(f *jen.File, t *gen.Type) {
	typeName := g.graphqlTypeName(t)
	receiver := typeReceiver(t.Name)
	queryType := t.Name + "Query"
	entityPkg := g.config.ORMPackage + "/" + strings.ToLower(t.Name)
	multiOrder := g.hasMultiOrder(t)

	edgeName := typeName + "Edge"
	connName := typeName + "Connection"
	pagerName := camel(typeName) + "Pager"
	optName := typeName + "PaginateOption"
	orderName := typeName + "Order"
	orderFieldName := typeName + "OrderField"
	defaultOrderName := "Default" + typeName + "Order"
	newPagerName := "new" + typeName + "Pager"

	// Edge struct
	f.Comment(fmt.Sprintf("// %s is the edge representation of %s.", edgeName, typeName))
	f.Type().Id(edgeName).Struct(
		jen.Id("Node").Op("*").Id(typeName).Tag(map[string]string{"json": "node"}),
		jen.Id("Cursor").Id("Cursor").Tag(map[string]string{"json": "cursor"}),
	)
	f.Line()

	// Connection struct
	f.Comment(fmt.Sprintf("// %s is the connection containing edges to %s.", connName, typeName))
	f.Type().Id(connName).Struct(
		jen.Id("Edges").Index().Op("*").Id(edgeName).Tag(map[string]string{"json": "edges"}),
		jen.Id("PageInfo").Id("PageInfo").Tag(map[string]string{"json": "pageInfo"}),
		jen.Id("TotalCount").Int().Tag(map[string]string{"json": "totalCount"}),
	)
	f.Line()

	// Connection.build method
	g.genConnectionBuild(f, typeName, edgeName, connName, pagerName)

	// PaginateOption type
	f.Comment(fmt.Sprintf("// %s enables pagination customization.", optName))
	f.Type().Id(optName).Func().Params(jen.Op("*").Id(pagerName)).Error()
	f.Line()

	// WithOrder function - single order vs multi-order based on annotation
	g.genWithOrder(f, typeName, optName, orderName, pagerName, defaultOrderName, multiOrder)

	// WithFilter function
	g.genWithFilter(f, typeName, optName, queryType, pagerName)

	// Pager struct - single order or multiple orders based on MultiOrder annotation.
	if multiOrder {
		f.Type().Id(pagerName).Struct(
			jen.Id("reverse").Bool(),
			jen.Id("order").Index().Op("*").Id(orderName),
			jen.Id("filter").Func().Params(jen.Op("*").Id(queryType)).Params(jen.Op("*").Id(queryType), jen.Error()),
		)
	} else {
		f.Type().Id(pagerName).Struct(
			jen.Id("reverse").Bool(),
			jen.Id("order").Op("*").Id(orderName),
			jen.Id("filter").Func().Params(jen.Op("*").Id(queryType)).Params(jen.Op("*").Id(queryType), jen.Error()),
		)
	}
	f.Line()

	// newPager function
	g.genNewPager(f, newPagerName, optName, pagerName, orderName, defaultOrderName, multiOrder)

	// Pager methods
	g.genPagerMethods(f, typeName, queryType, pagerName, defaultOrderName, multiOrder)

	// Paginate method on query
	g.genPaginateMethod(f, typeName, receiver, queryType, connName, edgeName, optName, newPagerName)

	// OrderField struct
	g.genOrderFieldStruct(f, t, typeName, orderFieldName, entityPkg)

	// Order struct
	f.Comment(fmt.Sprintf("// %s defines the ordering of %s.", orderName, t.Name))
	f.Type().Id(orderName).Struct(
		jen.Id("Direction").Id("OrderDirection").Tag(map[string]string{"json": "direction"}),
		jen.Id("Field").Op("*").Id(orderFieldName).Tag(map[string]string{"json": "field"}),
	)
	f.Line()

	// DefaultOrder variable
	g.genDefaultOrder(f, t, typeName, receiver, orderName, orderFieldName, defaultOrderName, entityPkg)

	// OrderField variables for each orderable field
	g.genOrderFieldVars(f, t, typeName, receiver, orderFieldName, entityPkg)

	// OrderField methods (String, MarshalGQL, UnmarshalGQL)
	g.genOrderFieldMethods(f, t, typeName, orderFieldName)

	// ToEdge method on entity
	g.genToEdge(f, typeName, receiver, edgeName, orderName, defaultOrderName)
}

// genConnectionBuild generates the Connection.build method.
func (g *Generator) genConnectionBuild(f *jen.File, typeName, edgeName, connName, pagerName string) {
	f.Func().Params(
		jen.Id("c").Op("*").Id(connName),
	).Id("build").Params(
		jen.Id("nodes").Index().Op("*").Id(typeName),
		jen.Id("pager").Op("*").Id(pagerName),
		jen.Id("after").Op("*").Id("Cursor"),
		jen.Id("first").Op("*").Int(),
		jen.Id("before").Op("*").Id("Cursor"),
		jen.Id("last").Op("*").Int(),
	).BlockFunc(func(group *jen.Group) {
		group.Id("c").Dot("PageInfo").Dot("HasNextPage").Op("=").Id("before").Op("!=").Nil()
		group.Id("c").Dot("PageInfo").Dot("HasPreviousPage").Op("=").Id("after").Op("!=").Nil()

		group.If(jen.Id("first").Op("!=").Nil().Op("&&").Op("*").Id("first").Op("+").Lit(1).Op("==").Len(jen.Id("nodes"))).Block(
			jen.Id("c").Dot("PageInfo").Dot("HasNextPage").Op("=").True(),
			jen.Id("nodes").Op("=").Id("nodes").Index(jen.Empty(), jen.Len(jen.Id("nodes")).Op("-").Lit(1)),
		).Else().If(jen.Id("last").Op("!=").Nil().Op("&&").Op("*").Id("last").Op("+").Lit(1).Op("==").Len(jen.Id("nodes"))).Block(
			jen.Id("c").Dot("PageInfo").Dot("HasPreviousPage").Op("=").True(),
			jen.Id("nodes").Op("=").Id("nodes").Index(jen.Empty(), jen.Len(jen.Id("nodes")).Op("-").Lit(1)),
		)

		group.Var().Id("nodeAt").Func().Params(jen.Int()).Op("*").Id(typeName)
		group.If(jen.Id("last").Op("!=").Nil()).Block(
			jen.Id("n").Op(":=").Len(jen.Id("nodes")).Op("-").Lit(1),
			jen.Id("nodeAt").Op("=").Func().Params(jen.Id("i").Int()).Op("*").Id(typeName).Block(
				jen.Return(jen.Id("nodes").Index(jen.Id("n").Op("-").Id("i"))),
			),
		).Else().Block(
			jen.Id("nodeAt").Op("=").Func().Params(jen.Id("i").Int()).Op("*").Id(typeName).Block(
				jen.Return(jen.Id("nodes").Index(jen.Id("i"))),
			),
		)

		group.Id("c").Dot("Edges").Op("=").Make(jen.Index().Op("*").Id(edgeName), jen.Len(jen.Id("nodes")))
		group.For(jen.Id("i").Op(":=").Range().Id("nodes")).Block(
			jen.Id("node").Op(":=").Id("nodeAt").Call(jen.Id("i")),
			jen.Id("c").Dot("Edges").Index(jen.Id("i")).Op("=").Op("&").Id(edgeName).Values(
				jen.Id("Node").Op(":").Id("node"),
				jen.Id("Cursor").Op(":").Id("pager").Dot("toCursor").Call(jen.Id("node")),
			),
		)

		group.If(jen.Id("l").Op(":=").Len(jen.Id("c").Dot("Edges")), jen.Id("l").Op(">").Lit(0)).Block(
			jen.Id("c").Dot("PageInfo").Dot("StartCursor").Op("=").Op("&").Id("c").Dot("Edges").Index(jen.Lit(0)).Dot("Cursor"),
			jen.Id("c").Dot("PageInfo").Dot("EndCursor").Op("=").Op("&").Id("c").Dot("Edges").Index(jen.Id("l").Op("-").Lit(1)).Dot("Cursor"),
		)

		// Note: TotalCount is intentionally NOT set here if it's 0.
		// Setting it to len(nodes) would be misleading since that's the page size,
		// not the total count of all matching items. If the user needs totalCount,
		// they should explicitly request it in the GraphQL query, which triggers
		// a separate count query to get the accurate total.
	})
	f.Line()
}

// genWithOrder generates the WithOrder function.
// When multiOrder is false, the function accepts a single *Order.
// When multiOrder is true, the function accepts a slice []*Order for multi-column sorting.
func (g *Generator) genWithOrder(f *jen.File, typeName, optName, orderName, pagerName, defaultOrderName string, multiOrder bool) {
	optOrderName := "With" + typeName + "Order"
	f.Comment(fmt.Sprintf("// %s configures pagination ordering.", optOrderName))

	if multiOrder {
		// Multi-order: accepts slice []*Order
		f.Func().Id(optOrderName).Params(
			jen.Id("order").Index().Op("*").Id(orderName),
		).Id(optName).Block(
			jen.Return(jen.Func().Params(jen.Id("pager").Op("*").Id(pagerName)).Error().Block(
				// Validate all orders
				jen.For(jen.List(jen.Id("_"), jen.Id("o")).Op(":=").Range().Id("order")).Block(
					jen.If(jen.Id("err").Op(":=").Id("o").Dot("Direction").Dot("Validate").Call(), jen.Id("err").Op("!=").Nil()).Block(
						jen.Return(jen.Id("err")),
					),
				),
				// Append orders to pager
				jen.Id("pager").Dot("order").Op("=").Append(jen.Id("pager").Dot("order"), jen.Id("order").Op("...")),
				jen.Return(jen.Nil()),
			)),
		)
	} else {
		// Single order: accepts *Order
		f.Func().Id(optOrderName).Params(
			jen.Id("order").Op("*").Id(orderName),
		).Id(optName).Block(
			jen.Return(jen.Func().Params(jen.Id("pager").Op("*").Id(pagerName)).Error().Block(
				// Default to default order if nil
				jen.If(jen.Id("order").Op("==").Nil()).Block(
					jen.Id("order").Op("=").Id(defaultOrderName),
				),
				// Make a copy to avoid mutating the input
				jen.Id("o").Op(":=").Op("*").Id("order"),
				// Validate direction
				jen.If(jen.Id("err").Op(":=").Id("o").Dot("Direction").Dot("Validate").Call(), jen.Id("err").Op("!=").Nil()).Block(
					jen.Return(jen.Id("err")),
				),
				// Default field if nil
				jen.If(jen.Id("o").Dot("Field").Op("==").Nil()).Block(
					jen.Id("o").Dot("Field").Op("=").Id(defaultOrderName).Dot("Field"),
				),
				// Store order
				jen.Id("pager").Dot("order").Op("=").Op("&").Id("o"),
				jen.Return(jen.Nil()),
			)),
		)
	}
	f.Line()
}

// genWithFilter generates the WithFilter function.
func (g *Generator) genWithFilter(f *jen.File, typeName, optName, queryType, pagerName string) {
	optFilterName := "With" + typeName + "Filter"
	f.Comment(fmt.Sprintf("// %s configures pagination filter.", optFilterName))
	f.Func().Id(optFilterName).Params(
		jen.Id("filter").Func().Params(jen.Op("*").Id(queryType)).Params(jen.Op("*").Id(queryType), jen.Error()),
	).Id(optName).Block(
		jen.Return(jen.Func().Params(jen.Id("pager").Op("*").Id(pagerName)).Error().Block(
			jen.If(jen.Id("filter").Op("==").Nil()).Block(
				jen.Return(jen.Qual("errors", "New").Call(jen.Lit(queryType+" filter cannot be nil"))),
			),
			jen.Id("pager").Dot("filter").Op("=").Id("filter"),
			jen.Return(jen.Nil()),
		)),
	)
	f.Line()
}

// genNewPager generates the newPager function.
func (g *Generator) genNewPager(f *jen.File, newPagerName, optName, pagerName, orderName, defaultOrderName string, multiOrder bool) {
	f.Func().Id(newPagerName).Params(
		jen.Id("opts").Index().Id(optName),
		jen.Id("reverse").Bool(),
	).Params(jen.Op("*").Id(pagerName), jen.Error()).BlockFunc(func(group *jen.Group) {
		group.Id("pager").Op(":=").Op("&").Id(pagerName).Values(jen.Id("reverse").Op(":").Id("reverse"))
		group.For(jen.List(jen.Id("_"), jen.Id("opt")).Op(":=").Range().Id("opts")).Block(
			jen.If(jen.Id("err").Op(":=").Id("opt").Call(jen.Id("pager")), jen.Id("err").Op("!=").Nil()).Block(
				jen.Return(jen.Nil(), jen.Id("err")),
			),
		)
		// Default to default order if no order specified
		if multiOrder {
			group.If(jen.Len(jen.Id("pager").Dot("order")).Op("==").Lit(0)).Block(
				jen.Id("pager").Dot("order").Op("=").Index().Op("*").Id(orderName).Values(jen.Id(defaultOrderName)),
			)
		} else {
			group.If(jen.Id("pager").Dot("order").Op("==").Nil()).Block(
				jen.Id("pager").Dot("order").Op("=").Id(defaultOrderName),
			)
		}
		group.Return(jen.Id("pager"), jen.Nil())
	})
	f.Line()
}

// genPagerMethods generates the pager methods (applyFilter, toCursor, applyCursors, applyOrder, orderExpr).
func (g *Generator) genPagerMethods(f *jen.File, typeName, queryType, pagerName, defaultOrderName string, multiOrder bool) {
	// applyFilter - same for both single and multi-order
	f.Func().Params(
		jen.Id("p").Op("*").Id(pagerName),
	).Id("applyFilter").Params(
		jen.Id("query").Op("*").Id(queryType),
	).Params(jen.Op("*").Id(queryType), jen.Error()).Block(
		jen.If(jen.Id("p").Dot("filter").Op("!=").Nil()).Block(
			jen.Return(jen.Id("p").Dot("filter").Call(jen.Id("query"))),
		),
		jen.Return(jen.Id("query"), jen.Nil()),
	)
	f.Line()

	// toCursor - uses first/only order for cursor calculation (Relay spec)
	f.Func().Params(
		jen.Id("p").Op("*").Id(pagerName),
	).Id("toCursor").Params(
		jen.Id("node").Op("*").Id(typeName),
	).Id("Cursor").BlockFunc(func(group *jen.Group) {
		if multiOrder {
			group.Return(jen.Id("p").Dot("order").Index(jen.Lit(0)).Dot("Field").Dot("toCursor").Call(jen.Id("node")))
		} else {
			group.Return(jen.Id("p").Dot("order").Dot("Field").Dot("toCursor").Call(jen.Id("node")))
		}
	})
	f.Line()

	// applyCursors - uses first/only order for cursor calculation
	f.Func().Params(
		jen.Id("p").Op("*").Id(pagerName),
	).Id("applyCursors").Params(
		jen.Id("query").Op("*").Id(queryType),
		jen.Id("after").Op("*").Id("Cursor"),
		jen.Id("before").Op("*").Id("Cursor"),
	).Params(jen.Op("*").Id(queryType), jen.Error()).BlockFunc(func(group *jen.Group) {
		if multiOrder {
			group.Id("direction").Op(":=").Id("p").Dot("order").Index(jen.Lit(0)).Dot("Direction")
		} else {
			group.Id("direction").Op(":=").Id("p").Dot("order").Dot("Direction")
		}
		group.If(jen.Id("p").Dot("reverse")).Block(
			jen.Id("direction").Op("=").Id("direction").Dot("Reverse").Call(),
		)
		if multiOrder {
			group.For(jen.List(jen.Id("_"), jen.Id("predicate")).Op(":=").Range().Id("cursorsPredicate").Call(
				jen.Id("after"),
				jen.Id("before"),
				jen.Id(defaultOrderName).Dot("Field").Dot("column"),
				jen.Id("p").Dot("order").Index(jen.Lit(0)).Dot("Field").Dot("column"),
				jen.Id("direction"),
			)).Block(
				jen.Id("query").Op("=").Id("query").Dot("Where").Call(jen.Id("predicate")),
			)
		} else {
			group.For(jen.List(jen.Id("_"), jen.Id("predicate")).Op(":=").Range().Id("cursorsPredicate").Call(
				jen.Id("after"),
				jen.Id("before"),
				jen.Id(defaultOrderName).Dot("Field").Dot("column"),
				jen.Id("p").Dot("order").Dot("Field").Dot("column"),
				jen.Id("direction"),
			)).Block(
				jen.Id("query").Op("=").Id("query").Dot("Where").Call(jen.Id("predicate")),
			)
		}
		group.Return(jen.Id("query"), jen.Nil())
	})
	f.Line()

	// applyOrder - applies order(s) to the query
	f.Func().Params(
		jen.Id("p").Op("*").Id(pagerName),
	).Id("applyOrder").Params(
		jen.Id("query").Op("*").Id(queryType),
	).Op("*").Id(queryType).BlockFunc(func(group *jen.Group) {
		if multiOrder {
			// Multi-order: Apply each order in sequence
			group.For(jen.List(jen.Id("_"), jen.Id("o")).Op(":=").Range().Id("p").Dot("order")).Block(
				jen.Id("direction").Op(":=").Id("o").Dot("Direction"),
				jen.If(jen.Id("p").Dot("reverse")).Block(
					jen.Id("direction").Op("=").Id("direction").Dot("Reverse").Call(),
				),
				jen.Id("query").Op("=").Id("query").Dot("Order").Call(
					jen.Id("o").Dot("Field").Dot("toTerm").Call(jen.Id("directionOrderTerm").Call(jen.Id("direction"))),
				),
				jen.If(jen.Len(jen.Id("query").Dot("ctx").Dot("Fields")).Op(">").Lit(0)).Block(
					jen.Id("query").Dot("ctx").Dot("AppendFieldOnce").Call(jen.Id("o").Dot("Field").Dot("column")),
				),
			)
			// Always add default order field for deterministic pagination
			group.Id("primaryOrder").Op(":=").Id("p").Dot("order").Index(jen.Lit(0))
			group.If(jen.Id("primaryOrder").Dot("Field").Op("!=").Id(defaultOrderName).Dot("Field")).Block(
				jen.Id("direction").Op(":=").Id("primaryOrder").Dot("Direction"),
				jen.If(jen.Id("p").Dot("reverse")).Block(
					jen.Id("direction").Op("=").Id("direction").Dot("Reverse").Call(),
				),
				jen.Id("query").Op("=").Id("query").Dot("Order").Call(
					jen.Id(defaultOrderName).Dot("Field").Dot("toTerm").Call(jen.Id("directionOrderTerm").Call(jen.Id("direction"))),
				),
			)
		} else {
			// Single order: Apply the single order
			group.Id("direction").Op(":=").Id("p").Dot("order").Dot("Direction")
			group.If(jen.Id("p").Dot("reverse")).Block(
				jen.Id("direction").Op("=").Id("direction").Dot("Reverse").Call(),
			)
			group.Id("query").Op("=").Id("query").Dot("Order").Call(
				jen.Id("p").Dot("order").Dot("Field").Dot("toTerm").Call(jen.Id("directionOrderTerm").Call(jen.Id("direction"))),
			)
			group.If(jen.Len(jen.Id("query").Dot("ctx").Dot("Fields")).Op(">").Lit(0)).Block(
				jen.Id("query").Dot("ctx").Dot("AppendFieldOnce").Call(jen.Id("p").Dot("order").Dot("Field").Dot("column")),
			)
			// Always add default order field for deterministic pagination
			group.If(jen.Id("p").Dot("order").Dot("Field").Op("!=").Id(defaultOrderName).Dot("Field")).Block(
				jen.Id("query").Op("=").Id("query").Dot("Order").Call(
					jen.Id(defaultOrderName).Dot("Field").Dot("toTerm").Call(jen.Id("directionOrderTerm").Call(jen.Id("direction"))),
				),
			)
		}
		group.Return(jen.Id("query"))
	})
	f.Line()

	// orderExpr - generates SQL ORDER BY expression
	f.Func().Params(
		jen.Id("p").Op("*").Id(pagerName),
	).Id("orderExpr").Params(
		jen.Id("query").Op("*").Id(queryType),
	).Qual("github.com/syssam/velox/dialect/sql", "Querier").BlockFunc(func(group *jen.Group) {
		if multiOrder {
			// Multi-order: Add all order field columns to query context
			group.For(jen.List(jen.Id("_"), jen.Id("o")).Op(":=").Range().Id("p").Dot("order")).Block(
				jen.If(jen.Len(jen.Id("query").Dot("ctx").Dot("Fields")).Op(">").Lit(0)).Block(
					jen.Id("query").Dot("ctx").Dot("AppendFieldOnce").Call(jen.Id("o").Dot("Field").Dot("column")),
				),
			)
			// Return expression function that builds ORDER BY clause
			group.Return(jen.Qual("github.com/syssam/velox/dialect/sql", "ExprFunc").Call(
				jen.Func().Params(jen.Id("b").Op("*").Qual("github.com/syssam/velox/dialect/sql", "Builder")).BlockFunc(func(innerGroup *jen.Group) {
					// Write all order columns
					innerGroup.For(jen.List(jen.Id("i"), jen.Id("o")).Op(":=").Range().Id("p").Dot("order")).Block(
						jen.Id("direction").Op(":=").Id("o").Dot("Direction"),
						jen.If(jen.Id("p").Dot("reverse")).Block(
							jen.Id("direction").Op("=").Id("direction").Dot("Reverse").Call(),
						),
						jen.If(jen.Id("i").Op(">").Lit(0)).Block(
							jen.Id("b").Dot("Comma").Call(),
						),
						jen.Id("b").Dot("Ident").Call(jen.Id("o").Dot("Field").Dot("column")).Dot("Pad").Call().Dot("WriteString").Call(jen.String().Call(jen.Id("direction"))),
					)
					// Add default order if not already included
					innerGroup.Id("primaryOrder").Op(":=").Id("p").Dot("order").Index(jen.Lit(0))
					innerGroup.If(jen.Id("primaryOrder").Dot("Field").Op("!=").Id(defaultOrderName).Dot("Field")).Block(
						jen.Id("direction").Op(":=").Id("primaryOrder").Dot("Direction"),
						jen.If(jen.Id("p").Dot("reverse")).Block(
							jen.Id("direction").Op("=").Id("direction").Dot("Reverse").Call(),
						),
						jen.Id("b").Dot("Comma").Call().Dot("Ident").Call(jen.Id(defaultOrderName).Dot("Field").Dot("column")).Dot("Pad").Call().Dot("WriteString").Call(jen.String().Call(jen.Id("direction"))),
					)
				}),
			))
		} else {
			// Single order: Add order field column to query context
			group.If(jen.Len(jen.Id("query").Dot("ctx").Dot("Fields")).Op(">").Lit(0)).Block(
				jen.Id("query").Dot("ctx").Dot("AppendFieldOnce").Call(jen.Id("p").Dot("order").Dot("Field").Dot("column")),
			)
			// Return expression function that builds ORDER BY clause
			group.Return(jen.Qual("github.com/syssam/velox/dialect/sql", "ExprFunc").Call(
				jen.Func().Params(jen.Id("b").Op("*").Qual("github.com/syssam/velox/dialect/sql", "Builder")).BlockFunc(func(innerGroup *jen.Group) {
					innerGroup.Id("direction").Op(":=").Id("p").Dot("order").Dot("Direction")
					innerGroup.If(jen.Id("p").Dot("reverse")).Block(
						jen.Id("direction").Op("=").Id("direction").Dot("Reverse").Call(),
					)
					innerGroup.Id("b").Dot("Ident").Call(jen.Id("p").Dot("order").Dot("Field").Dot("column")).Dot("Pad").Call().Dot("WriteString").Call(jen.String().Call(jen.Id("direction")))
					// Add default order if not already included
					innerGroup.If(jen.Id("p").Dot("order").Dot("Field").Op("!=").Id(defaultOrderName).Dot("Field")).Block(
						jen.Id("b").Dot("Comma").Call().Dot("Ident").Call(jen.Id(defaultOrderName).Dot("Field").Dot("column")).Dot("Pad").Call().Dot("WriteString").Call(jen.String().Call(jen.Id("direction"))),
					)
				}),
			))
		}
	})
	f.Line()
}

// genPaginateMethod generates the Paginate method on the query builder.
func (g *Generator) genPaginateMethod(f *jen.File, typeName, receiver, queryType, connName, edgeName, optName, newPagerName string) {
	f.Comment(fmt.Sprintf("// Paginate executes the query and returns a relay based cursor connection to %s.", typeName))
	f.Func().Params(
		jen.Id(receiver).Op("*").Id(queryType),
	).Id("Paginate").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("after").Op("*").Id("Cursor"),
		jen.Id("first").Op("*").Int(),
		jen.Id("before").Op("*").Id("Cursor"),
		jen.Id("last").Op("*").Int(),
		jen.Id("opts").Op("...").Id(optName),
	).Params(jen.Op("*").Id(connName), jen.Error()).BlockFunc(func(group *jen.Group) {
		group.If(jen.Id("err").Op(":=").Id("validateFirstLast").Call(jen.Id("first"), jen.Id("last")), jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Id("err")),
		)

		group.List(jen.Id("pager"), jen.Id("err")).Op(":=").Id(newPagerName).Call(jen.Id("opts"), jen.Id("last").Op("!=").Nil())
		group.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Id("err")),
		)

		group.If(jen.List(jen.Id(receiver), jen.Id("err")).Op("=").Id("pager").Dot("applyFilter").Call(jen.Id(receiver)), jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Id("err")),
		)

		// Ensure edges is empty array not nil
		group.Id("conn").Op(":=").Op("&").Id(connName).Values(
			jen.Id("Edges").Op(":").Index().Op("*").Id(edgeName).Values(),
		)
		group.Id("ignoredEdges").Op(":=").Op("!").Id("hasCollectedField").Call(jen.Id("ctx"), jen.Id("edgesField"))

		group.If(jen.Id("hasCollectedField").Call(jen.Id("ctx"), jen.Id("totalCountField")).Op("||").Id("hasCollectedField").Call(jen.Id("ctx"), jen.Id("pageInfoField"))).Block(
			jen.Id("hasPagination").Op(":=").Id("after").Op("!=").Nil().Op("||").Id("first").Op("!=").Nil().Op("||").Id("before").Op("!=").Nil().Op("||").Id("last").Op("!=").Nil(),
			jen.If(jen.Id("hasPagination").Op("||").Id("ignoredEdges")).Block(
				jen.Id("c").Op(":=").Id(receiver).Dot("Clone").Call(),
				jen.Id("c").Dot("ctx").Dot("Fields").Op("=").Nil(),
				jen.If(jen.List(jen.Id("conn").Dot("TotalCount"), jen.Id("err")).Op("=").Id("c").Dot("Count").Call(jen.Id("ctx")), jen.Id("err").Op("!=").Nil()).Block(
					jen.Return(jen.Nil(), jen.Id("err")),
				),
				jen.Id("conn").Dot("PageInfo").Dot("HasNextPage").Op("=").Id("first").Op("!=").Nil().Op("&&").Id("conn").Dot("TotalCount").Op(">").Lit(0),
				jen.Id("conn").Dot("PageInfo").Dot("HasPreviousPage").Op("=").Id("last").Op("!=").Nil().Op("&&").Id("conn").Dot("TotalCount").Op(">").Lit(0),
			),
		)

		group.If(jen.Id("ignoredEdges").Op("||").Parens(jen.Id("first").Op("!=").Nil().Op("&&").Op("*").Id("first").Op("==").Lit(0)).Op("||").Parens(jen.Id("last").Op("!=").Nil().Op("&&").Op("*").Id("last").Op("==").Lit(0))).Block(
			jen.Return(jen.Id("conn"), jen.Nil()),
		)

		group.If(jen.List(jen.Id(receiver), jen.Id("err")).Op("=").Id("pager").Dot("applyCursors").Call(jen.Id(receiver), jen.Id("after"), jen.Id("before")), jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Id("err")),
		)

		group.Id("limit").Op(":=").Id("paginateLimit").Call(jen.Id("first"), jen.Id("last"))
		group.If(jen.Id("limit").Op("!=").Lit(0)).Block(
			jen.Id(receiver).Dot("Limit").Call(jen.Id("limit")),
		)

		group.If(jen.Id("field").Op(":=").Id("collectedField").Call(jen.Id("ctx"), jen.Id("edgesField"), jen.Id("nodeField")), jen.Id("field").Op("!=").Nil()).Block(
			jen.If(jen.Id("err").Op(":=").Id(receiver).Dot("collectField").Call(
				jen.Id("ctx"),
				jen.Id("limit").Op("==").Lit(1),
				jen.Qual("github.com/99designs/gqlgen/graphql", "GetOperationContext").Call(jen.Id("ctx")),
				jen.Op("*").Id("field"),
				jen.Index().String().Values(jen.Id("edgesField"), jen.Id("nodeField")),
			), jen.Id("err").Op("!=").Nil()).Block(
				jen.Return(jen.Nil(), jen.Id("err")),
			),
		)

		group.Id(receiver).Op("=").Id("pager").Dot("applyOrder").Call(jen.Id(receiver))
		group.List(jen.Id("nodes"), jen.Id("err")).Op(":=").Id(receiver).Dot("All").Call(jen.Id("ctx"))
		group.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Id("err")),
		)

		group.Id("conn").Dot("build").Call(jen.Id("nodes"), jen.Id("pager"), jen.Id("after"), jen.Id("first"), jen.Id("before"), jen.Id("last"))
		group.Return(jen.Id("conn"), jen.Nil())
	})
	f.Line()
}

// genOrderFieldStruct generates the OrderField struct.
func (g *Generator) genOrderFieldStruct(f *jen.File, t *gen.Type, typeName, orderFieldName, entityPkg string) {
	f.Comment(fmt.Sprintf("// %s defines the ordering field of %s.", orderFieldName, t.Name))
	f.Type().Id(orderFieldName).Struct(
		jen.Comment("Value extracts the ordering value from the given "+t.Name+"."),
		jen.Id("Value").Func().Params(jen.Op("*").Id(typeName)).Params(jen.Qual("github.com/syssam/velox", "Value"), jen.Error()),
		jen.Id("column").String(),
		jen.Id("toTerm").Func().Params(jen.Op("...").Qual("github.com/syssam/velox/dialect/sql", "OrderTermOption")).Qual(entityPkg, "OrderOption"),
		jen.Id("toCursor").Func().Params(jen.Op("*").Id(typeName)).Id("Cursor"),
	)
	f.Line()
}

// genDefaultOrder generates the DefaultOrder variable.
func (g *Generator) genDefaultOrder(f *jen.File, t *gen.Type, typeName, receiver, orderName, orderFieldName, defaultOrderName, entityPkg string) {
	idField := "ID"
	idConst := "FieldID"
	idOrderName := "ByID"
	if t.ID != nil {
		// Use "ID" for id fields (uppercase acronym convention)
		if strings.EqualFold(t.ID.Name, "id") {
			idField = "ID"
		} else {
			idField = pascal(t.ID.Name)
		}
		idConst = "Field" + idField
		idOrderName = "By" + idField
	}

	f.Comment(fmt.Sprintf("// %s is the default ordering of %s.", defaultOrderName, t.Name))
	f.Var().Id(defaultOrderName).Op("=").Op("&").Id(orderName).Values(
		jen.Id("Direction").Op(":").Id("OrderDirectionAsc"),
		jen.Id("Field").Op(":").Op("&").Id(orderFieldName).Values(
			jen.Id("Value").Op(":").Func().Params(jen.Id(receiver).Op("*").Id(typeName)).Params(jen.Qual("github.com/syssam/velox", "Value"), jen.Error()).Block(
				jen.Return(jen.Id(receiver).Dot(idField), jen.Nil()),
			),
			jen.Id("column").Op(":").Qual(entityPkg, idConst),
			jen.Id("toTerm").Op(":").Qual(entityPkg, idOrderName),
			jen.Id("toCursor").Op(":").Func().Params(jen.Id(receiver).Op("*").Id(typeName)).Id("Cursor").Block(
				jen.Return(jen.Id("Cursor").Values(jen.Id("ID").Op(":").Id(receiver).Dot(idField))),
			),
		),
	)
	f.Line()
}

// genOrderFieldVars generates the order field variables for orderable fields.
func (g *Generator) genOrderFieldVars(f *jen.File, t *gen.Type, typeName, receiver, orderFieldName, entityPkg string) {
	// Use filterFields helper (like Ent) - filter by SkipOrderField
	fields := g.filterFields(t.Fields, SkipOrderField)
	var orderableFields []*gen.Field
	for _, field := range fields {
		// Include basic orderable types
		if g.isOrderableField(field) {
			orderableFields = append(orderableFields, field)
		}
	}

	if len(orderableFields) == 0 {
		return
	}

	f.Var().DefsFunc(func(group *jen.Group) {
		for _, field := range orderableFields {
			varName := camel(typeName) + "By" + pascal(field.Name)
			fieldConst := "Field" + pascal(field.Name)
			orderFunc := "By" + pascal(field.Name)
			structField := pascal(field.Name)

			group.Comment(fmt.Sprintf("// %s orders %s by %s.", varName, t.Name, field.Name))
			group.Id(varName).Op("=").Op("&").Id(orderFieldName).Values(
				jen.Id("Value").Op(":").Func().Params(jen.Id(receiver).Op("*").Id(typeName)).Params(jen.Qual("github.com/syssam/velox", "Value"), jen.Error()).Block(
					jen.Return(jen.Id(receiver).Dot(structField), jen.Nil()),
				),
				jen.Id("column").Op(":").Qual(entityPkg, fieldConst),
				jen.Id("toTerm").Op(":").Qual(entityPkg, orderFunc),
				jen.Id("toCursor").Op(":").Func().Params(jen.Id(receiver).Op("*").Id(typeName)).Id("Cursor").Block(
					jen.Return(jen.Id("Cursor").Values(
						jen.Id("ID").Op(":").Id(receiver).Dot("ID"),
						jen.Id("Value").Op(":").Id(receiver).Dot(structField),
					)),
				),
			)
		}
	})
	f.Line()
}

// genOrderFieldMethods generates String, MarshalGQL, UnmarshalGQL methods for OrderField.
func (g *Generator) genOrderFieldMethods(f *jen.File, t *gen.Type, typeName, orderFieldName string) {
	// Use filterFields helper (like Ent) - filter by SkipOrderField
	fields := g.filterFields(t.Fields, SkipOrderField)
	var orderableFields []*gen.Field
	for _, field := range fields {
		if g.isOrderableField(field) {
			orderableFields = append(orderableFields, field)
		}
	}

	// String method
	f.Comment("// String implement fmt.Stringer interface.")
	f.Func().Params(jen.Id("f").Id(orderFieldName)).Id("String").Params().String().BlockFunc(func(group *jen.Group) {
		group.Var().Id("str").String()
		group.Switch(jen.Id("f").Dot("column")).BlockFunc(func(sw *jen.Group) {
			for _, field := range orderableFields {
				varName := camel(typeName) + "By" + pascal(field.Name)
				gqlName := g.getOrderFieldName(field)
				sw.Case(jen.Id(varName).Dot("column")).Block(
					jen.Id("str").Op("=").Lit(gqlName),
				)
			}
		})
		group.Return(jen.Id("str"))
	})
	f.Line()

	// MarshalGQL method
	f.Comment("// MarshalGQL implements graphql.Marshaler interface.")
	f.Func().Params(jen.Id("f").Id(orderFieldName)).Id("MarshalGQL").Params(
		jen.Id("w").Qual("io", "Writer"),
	).Block(
		jen.Qual("io", "WriteString").Call(jen.Id("w"), jen.Qual("strconv", "Quote").Call(jen.Id("f").Dot("String").Call())),
	)
	f.Line()

	// UnmarshalGQL method
	f.Comment("// UnmarshalGQL implements graphql.Unmarshaler interface.")
	f.Func().Params(jen.Id("f").Op("*").Id(orderFieldName)).Id("UnmarshalGQL").Params(
		jen.Id("v").Interface(),
	).Error().BlockFunc(func(group *jen.Group) {
		group.List(jen.Id("str"), jen.Id("ok")).Op(":=").Id("v").Assert(jen.String())
		group.If(jen.Op("!").Id("ok")).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit(orderFieldName+" %T must be a string"), jen.Id("v"))),
		)
		group.Switch(jen.Id("str")).BlockFunc(func(sw *jen.Group) {
			for _, field := range orderableFields {
				varName := camel(typeName) + "By" + pascal(field.Name)
				gqlName := g.getOrderFieldName(field)
				sw.Case(jen.Lit(gqlName)).Block(
					jen.Op("*").Id("f").Op("=").Op("*").Id(varName),
				)
			}
			sw.Default().Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("%s is not a valid "+orderFieldName), jen.Id("str"))),
			)
		})
		group.Return(jen.Nil())
	})
	f.Line()
}

// genToEdge generates the ToEdge method on the entity.
func (g *Generator) genToEdge(f *jen.File, typeName, receiver, edgeName, orderName, defaultOrderName string) {
	f.Comment(fmt.Sprintf("// ToEdge converts %s into %s.", typeName, edgeName))
	f.Func().Params(
		jen.Id(receiver).Op("*").Id(typeName),
	).Id("ToEdge").Params(
		jen.Id("order").Op("*").Id(orderName),
	).Op("*").Id(edgeName).Block(
		jen.If(jen.Id("order").Op("==").Nil()).Block(
			jen.Id("order").Op("=").Id(defaultOrderName),
		),
		jen.Return(jen.Op("&").Id(edgeName).Values(
			jen.Id("Node").Op(":").Id(receiver),
			jen.Id("Cursor").Op(":").Id("order").Dot("Field").Dot("toCursor").Call(jen.Id(receiver)),
		)),
	)
	f.Line()
}

// isOrderableField returns true if the field can be used for ordering.
func (g *Generator) isOrderableField(field *gen.Field) bool {
	return field.IsTime() || field.IsString() || field.IsInt() || field.IsInt64() || field.IsBool()
}

// genLimitPerRow generates the LimitPerRow helper function.
// This is a velox-compatible version using the sqlgraph pattern.
func (g *Generator) genLimitPerRow(f *jen.File) {
	sqlPkg := "github.com/syssam/velox/dialect/sql"

	f.Comment("// LimitPerRow returns a query modifier that limits the number of rows per partition.")
	f.Func().Id("LimitPerRow").Params(
		jen.Id("partitionBy").String(),
		jen.Id("limit").Int(),
		jen.Id("orderBy").Op("...").Qual(sqlPkg, "Querier"),
	).Func().Params(jen.Op("*").Qual(sqlPkg, "Selector")).BlockFunc(func(group *jen.Group) {
		group.Return(jen.Func().Params(jen.Id("s").Op("*").Qual(sqlPkg, "Selector")).BlockFunc(func(innerGroup *jen.Group) {
			// Use the sqlgraph.NeighborsLimit pattern with CTEs
			innerGroup.Id("d").Op(":=").Qual(sqlPkg, "Dialect").Call(jen.Id("s").Dot("Dialect").Call())
			innerGroup.Id("rn").Op(":=").Qual(sqlPkg, "RowNumber").Call().Dot("PartitionBy").Call(jen.Id("partitionBy"))
			innerGroup.If(jen.Len(jen.Id("orderBy")).Op(">").Lit(0)).Block(
				jen.Id("rn").Dot("OrderExpr").Call(jen.Id("orderBy").Op("...")),
			)
			innerGroup.Id("s").Dot("SetDistinct").Call(jen.False())
			// Ensure the partitionBy column is in the SELECT list for the CTE and final SELECT
			innerGroup.Id("s").Dot("AppendSelect").Call(jen.Id("s").Dot("C").Call(jen.Id("partitionBy")))
			innerGroup.Id("with").Op(":=").Id("d").Dot("With").Call(jen.Lit("src")).
				Dot("As").Call(jen.Id("s").Dot("Clone").Call()).
				Dot("With").Call(jen.Lit("limited")).
				Dot("As").Call(
				jen.Id("d").Dot("Select").Call(jen.Lit("*")).
					Dot("AppendSelectExprAs").Call(jen.Id("rn"), jen.Lit("row_number")).
					Dot("From").Call(jen.Id("d").Dot("Table").Call(jen.Lit("src"))),
			)
			innerGroup.Id("t").Op(":=").Id("d").Dot("Table").Call(jen.Lit("limited")).Dot("As").Call(jen.Id("s").Dot("TableName").Call())
			innerGroup.Op("*").Id("s").Op("=").Op("*").Id("d").Dot("Select").Call(jen.Id("s").Dot("UnqualifiedColumns").Call().Op("...")).
				Dot("From").Call(jen.Id("t")).
				Dot("Where").Call(jen.Qual(sqlPkg, "LTE").Call(jen.Id("t").Dot("C").Call(jen.Lit("row_number")), jen.Id("limit"))).
				Dot("Prefix").Call(jen.Id("with"))
		}))
	})
	f.Line()
}

// genOrderDirection generates the OrderDirection type and constants.
func (g *Generator) genOrderDirection(f *jen.File) {
	f.Comment("// OrderDirection defines the ordering direction for pagination.")
	f.Type().Id("OrderDirection").String()
	f.Line()

	f.Comment("// Order direction constants.")
	f.Const().DefsFunc(func(group *jen.Group) {
		group.Id("OrderDirectionAsc").Id("OrderDirection").Op("=").Lit("ASC")
		group.Id("OrderDirectionDesc").Id("OrderDirection").Op("=").Lit("DESC")
	})
	f.Line()

	// String method
	f.Comment("// String returns the string representation of OrderDirection.")
	f.Func().Params(jen.Id("o").Id("OrderDirection")).Id("String").Params().String().Block(
		jen.Return(jen.String().Call(jen.Id("o"))),
	)
	f.Line()

	// Validate method
	f.Comment("// Validate validates the OrderDirection value.")
	f.Func().Params(jen.Id("o").Id("OrderDirection")).Id("Validate").Params().Error().Block(
		jen.If(jen.Id("o").Op("!=").Id("OrderDirectionAsc").Op("&&").Id("o").Op("!=").Id("OrderDirectionDesc")).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("invalid order direction: %q"), jen.Id("o"))),
		),
		jen.Return(jen.Nil()),
	)
	f.Line()

	// Reverse method
	f.Comment("// Reverse returns the reverse direction.")
	f.Func().Params(jen.Id("o").Id("OrderDirection")).Id("Reverse").Params().Id("OrderDirection").Block(
		jen.If(jen.Id("o").Op("==").Id("OrderDirectionAsc")).Block(
			jen.Return(jen.Id("OrderDirectionDesc")),
		),
		jen.Return(jen.Id("OrderDirectionAsc")),
	)
	f.Line()

	// OrderTermOption method (following Ent's pattern)
	f.Comment("// OrderTermOption returns the SQL order term option for this direction.")
	f.Func().Params(jen.Id("o").Id("OrderDirection")).Id("OrderTermOption").Params().Qual("github.com/syssam/velox/dialect/sql", "OrderTermOption").Block(
		jen.If(jen.Id("o").Op("==").Id("OrderDirectionDesc")).Block(
			jen.Return(jen.Qual("github.com/syssam/velox/dialect/sql", "OrderDesc").Call()),
		),
		jen.Return(jen.Qual("github.com/syssam/velox/dialect/sql", "OrderAsc").Call()),
	)
	f.Line()

	// MarshalGQL method
	f.Comment("// MarshalGQL implements the graphql.Marshaler interface.")
	f.Func().Params(jen.Id("o").Id("OrderDirection")).Id("MarshalGQL").Params(jen.Id("w").Qual("io", "Writer")).Block(
		jen.Qual("io", "WriteString").Call(jen.Id("w"), jen.Id("o").Dot("String").Call()),
	)
	f.Line()

	// UnmarshalGQL method
	f.Comment("// UnmarshalGQL implements the graphql.Unmarshaler interface.")
	f.Func().Params(jen.Id("o").Op("*").Id("OrderDirection")).Id("UnmarshalGQL").Params(jen.Id("v").Any()).Error().Block(
		jen.List(jen.Id("s"), jen.Id("ok")).Op(":=").Id("v").Assert(jen.String()),
		jen.If(jen.Op("!").Id("ok")).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("order direction must be a string"))),
		),
		jen.Op("*").Id("o").Op("=").Id("OrderDirection").Call(jen.Id("s")),
		jen.Return(jen.Id("o").Dot("Validate").Call()),
	)
	f.Line()
}

// genCursorType generates the Cursor type for pagination.
// Uses `any` for the ID field to maintain gqlgen compatibility.
func (g *Generator) genCursorType(f *jen.File) {
	f.Comment("// Cursor is a pagination cursor.")
	f.Type().Id("Cursor").Struct(
		jen.Id("ID").Any().Tag(map[string]string{"msgpack": "i"}),
		jen.Id("Value").Qual("github.com/syssam/velox", "Value").Tag(map[string]string{"msgpack": "v,omitempty"}),
	)
	f.Line()

	// MarshalGQL method
	f.Comment("// MarshalGQL implements the graphql.Marshaler interface.")
	f.Func().Params(jen.Id("c").Id("Cursor")).Id("MarshalGQL").Params(jen.Id("w").Qual("io", "Writer")).Block(
		jen.List(jen.Id("data"), jen.Id("_")).Op(":=").Qual("github.com/vmihailenco/msgpack/v5", "Marshal").Call(jen.Id("c")),
		jen.Id("s").Op(":=").Qual("encoding/base64", "StdEncoding").Dot("EncodeToString").Call(jen.Id("data")),
		jen.Qual("io", "WriteString").Call(jen.Id("w"), jen.Qual("strconv", "Quote").Call(jen.Id("s"))),
	)
	f.Line()

	// UnmarshalGQL method
	f.Comment("// UnmarshalGQL implements the graphql.Unmarshaler interface.")
	f.Func().Params(jen.Id("c").Op("*").Id("Cursor")).Id("UnmarshalGQL").Params(jen.Id("v").Any()).Error().Block(
		jen.List(jen.Id("s"), jen.Id("ok")).Op(":=").Id("v").Assert(jen.String()),
		jen.If(jen.Op("!").Id("ok")).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("cursor must be a string"))),
		),
		jen.If(jen.Id("s").Op("==").Lit("")).Block(
			jen.Return(jen.Nil()),
		),
		jen.List(jen.Id("data"), jen.Id("err")).Op(":=").Qual("encoding/base64", "StdEncoding").Dot("DecodeString").Call(jen.Id("s")),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("invalid cursor: %w"), jen.Id("err"))),
		),
		jen.If(jen.Id("err").Op(":=").Qual("github.com/vmihailenco/msgpack/v5", "Unmarshal").Call(jen.Id("data"), jen.Id("c")).Op(";").Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("invalid cursor: %w"), jen.Id("err"))),
		),
		jen.Return(jen.Nil()),
	)
	f.Line()
}

// genPageInfoType generates the PageInfo type for pagination.
func (g *Generator) genPageInfoType(f *jen.File) {
	f.Comment("// PageInfo is pagination information.")
	f.Type().Id("PageInfo").Struct(
		jen.Id("HasNextPage").Bool().Tag(map[string]string{"json": "hasNextPage"}),
		jen.Id("HasPreviousPage").Bool().Tag(map[string]string{"json": "hasPreviousPage"}),
		jen.Id("StartCursor").Op("*").Id("Cursor").Tag(map[string]string{"json": "startCursor,omitempty"}),
		jen.Id("EndCursor").Op("*").Id("Cursor").Tag(map[string]string{"json": "endCursor,omitempty"}),
	)
	f.Line()
}
