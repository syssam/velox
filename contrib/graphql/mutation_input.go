package graphql

// This file generates mutation input types (gql_mutation_input.go).
// Mutation inputs provide type-safe create/update operations:
//   - CreateXXXInput struct with required and optional fields
//   - UpdateXXXInput struct with all optional fields + clear operations
//   - Mutate() method to apply input to entity mutations
//   - SetInput() method on builders for fluent API integration

import (
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/syssam/velox/compiler/gen"
	"github.com/syssam/velox/schema/field"
)

// genMutationInput generates gql_mutation_input.go with Go structs for mutation inputs.
// This follows entgql's mutation_input.tmpl pattern:
//   - CreateXXXInput struct with fields for create mutations
//   - UpdateXXXInput struct with fields for update mutations
//   - Mutate(m *XXXMutation) method to apply input to mutation
//   - SetInput(i XXXInput) method on Create/Update builders
func (g *Generator) genMutationInput() *jen.File {
	if g.config.ORMPackage == "" {
		return nil
	}

	f := jen.NewFile(g.config.Package)
	f.HeaderComment("Code generated by velox. DO NOT EDIT.")

	// Import statements
	f.ImportName("context", "context")

	// Use filterNodes helper (like Ent)
	nodes := g.filterNodes(g.graph.Nodes, SkipType)

	// Generate entity package imports
	for _, t := range nodes {
		entityPkg := g.config.ORMPackage + "/" + strings.ToLower(t.Name)
		f.ImportName(entityPkg, strings.ToLower(t.Name))
	}

	// Generate mutation inputs for each entity
	for _, t := range nodes {
		// CreateInput
		if g.wantsMutationCreate(t) {
			g.genCreateInputStruct(f, t)
			g.genCreateInputMutate(f, t)
			g.genCreateSetInput(f, t)
		}

		// UpdateInput
		if g.wantsMutationUpdate(t) {
			g.genUpdateInputStruct(f, t)
			g.genUpdateInputMutate(f, t)
			g.genUpdateSetInput(f, t)
		}
	}

	return f
}

// isReferenceType returns true if the field type is a reference type (map, slice, interface, pointer)
// that doesn't need a pointer wrapper because nil is already a valid value.
func (g *Generator) isReferenceType(f *gen.Field) bool {
	// JSON fields with map or slice types are reference types
	if f.IsJSON() {
		if f.Type != nil && f.Type.Ident != "" {
			ident := f.Type.Ident
			// Check for explicit reference types
			if strings.HasPrefix(ident, "map[") ||
				strings.HasPrefix(ident, "[]") ||
				strings.HasPrefix(ident, "*") ||
				ident == "interface{}" ||
				ident == "any" {
				return true
			}
			// If it has a GoType but is not a reference type, it's a struct
			// Structs can't be compared to nil
			if f.HasGoType() {
				return false
			}
		}
		return true // Default JSON is map[string]interface{}, a reference type
	}
	return false
}

// isStructType returns true if the field is a struct type (not pointer, map, or slice)
// that can't be compared to nil. Such types need special handling in mutation inputs.
func (g *Generator) isStructType(f *gen.Field) bool {
	if !f.IsJSON() || f.Type == nil || f.Type.Ident == "" {
		return false
	}
	ident := f.Type.Ident
	// Not a reference type, and has a GoType = struct type
	return !strings.HasPrefix(ident, "map[") &&
		!strings.HasPrefix(ident, "[]") &&
		!strings.HasPrefix(ident, "*") &&
		ident != "interface{}" &&
		ident != "any" &&
		f.HasGoType()
}

// isPointerType returns true if the field is a pointer type that needs dereferencing
// when passing to setter methods.
func (g *Generator) isPointerType(f *gen.Field) bool {
	if !f.IsJSON() || f.Type == nil || f.Type.Ident == "" {
		return false
	}
	return strings.HasPrefix(f.Type.Ident, "*")
}

// genCreateInputStruct generates the CreateXXXInput struct.
func (g *Generator) genCreateInputStruct(f *jen.File, t *gen.Type) {
	typeName := t.Name
	inputName := "Create" + typeName + "Input"

	f.Comment(fmt.Sprintf("%s represents a mutation input for creating %s.", inputName, strings.ToLower(typeName)+"s"))
	f.Type().Id(inputName).StructFunc(func(group *jen.Group) {
		// Fields - use filterFields helper (like Ent)
		fields := g.filterFields(t.Fields, SkipMutationCreateInput)
		for _, field := range fields {
			if !g.fieldInCreateInput(field) {
				continue
			}

			fieldName := pascal(field.Name)
			fieldType := g.goInputFieldType(field, t.Name)

			// Required fields are not pointers, optional/nillable fields are pointers
			// Exception: reference types (map, slice) don't need pointers because nil is valid
			if field.Optional || field.Default || field.Nillable {
				if g.isReferenceType(field) {
					// Reference types don't need pointer wrapper
					group.Id(fieldName).Add(fieldType)
				} else {
					group.Id(fieldName).Op("*").Add(fieldType)
				}
			} else {
				group.Id(fieldName).Add(fieldType)
			}
		}

		// Edge fields
		for _, edge := range t.Edges {
			// Skip inverse edges that don't own the FK (handled on the other side)
			// But include M2O and inverse O2O edges where the FK is on this table
			if edge.IsInverse() && !edge.OwnFK() {
				continue
			}
			// Skip edges that have explicit FK fields (already generated from fields)
			if g.edgeHasExplicitFKField(edge) {
				continue
			}

			edgeName := pascal(edge.Name)
			idType := g.edgeIDType(edge)

			if edge.Unique {
				// Single edge: required edges use ID, optional edges use *ID
				if edge.Optional {
					group.Id(edgeName + "ID").Op("*").Add(idType)
				} else {
					group.Id(edgeName + "ID").Add(idType)
				}
			} else {
				// Multiple edges: []ID (use MutationAdd to get proper singular form)
				addMethod := edge.MutationAdd()
				structField := addMethod[3:] // "ChildIDs" from "AddChildIDs"
				group.Id(structField).Index().Add(idType)
			}
		}
	})
	f.Line()
}

// edgeHasExplicitFKField returns true if the edge has an explicit FK field reference.
// When an edge has .Field("xxx") set, the FK field is already defined as a regular field
// and should not be duplicated in the mutation input.
func (g *Generator) edgeHasExplicitFKField(edge *gen.Edge) bool {
	// Check if the edge has an associated FK field (set via .Field("xxx"))
	return edge.Field() != nil
}

// genCreateInputMutate generates the Mutate method for CreateXXXInput.
func (g *Generator) genCreateInputMutate(f *jen.File, t *gen.Type) {
	typeName := t.Name
	inputName := "Create" + typeName + "Input"
	mutationName := typeName + "Mutation"

	f.Comment(fmt.Sprintf("Mutate applies the %s on the %s builder.", inputName, mutationName))
	f.Func().Params(
		jen.Id("i").Op("*").Id(inputName),
	).Id("Mutate").Params(
		jen.Id("m").Add(g.ormTypePtr(mutationName)),
	).BlockFunc(func(group *jen.Group) {
		// Set fields - use filterFields helper (like Ent)
		fields := g.filterFields(t.Fields, SkipMutationCreateInput)
		for _, field := range fields {
			if !g.fieldInCreateInput(field) {
				continue
			}

			fieldName := pascal(field.Name)
			setMethod := "Set" + fieldName

			if field.Optional || field.Default || field.Nillable {
				// Optional/nillable: check for nil before setting
				switch {
				case g.isStructType(field):
					// Struct types: can't compare to nil, always set the value
					// The ORM will handle zero values appropriately
					group.Id("m").Dot(setMethod).Call(jen.Id("i").Dot(fieldName))
				case g.isPointerType(field):
					// Pointer types: check nil and dereference (ORM setter expects non-pointer)
					group.If(jen.Id("i").Dot(fieldName).Op("!=").Nil()).Block(
						jen.Id("m").Dot(setMethod).Call(jen.Op("*").Id("i").Dot(fieldName)),
					)
				case g.isReferenceType(field):
					// Other reference types (maps, slices): check nil but don't dereference
					group.If(jen.Id("i").Dot(fieldName).Op("!=").Nil()).Block(
						jen.Id("m").Dot(setMethod).Call(jen.Id("i").Dot(fieldName)),
					)
				default:
					// Value types: check nil and dereference
					group.If(jen.Id("i").Dot(fieldName).Op("!=").Nil()).Block(
						jen.Id("m").Dot(setMethod).Call(jen.Op("*").Id("i").Dot(fieldName)),
					)
				}
			} else {
				// Required: always set
				if g.isPointerType(field) {
					// Pointer types need dereferencing (ORM setter expects non-pointer)
					group.Id("m").Dot(setMethod).Call(jen.Op("*").Id("i").Dot(fieldName))
				} else {
					group.Id("m").Dot(setMethod).Call(jen.Id("i").Dot(fieldName))
				}
			}
		}

		// Set edges
		for _, edge := range t.Edges {
			// Skip inverse edges that don't own the FK (handled on the other side)
			// But include M2O and inverse O2O edges where the FK is on this table
			if edge.IsInverse() && !edge.OwnFK() {
				continue
			}
			// Skip edges that have explicit FK fields (already handled in fields section)
			if g.edgeHasExplicitFKField(edge) {
				continue
			}

			edgeName := pascal(edge.Name)

			if edge.Unique {
				structField := edgeName + "ID"
				setMethod := edge.MutationSet()
				if edge.Optional {
					// Optional edge: check for nil before setting
					group.If(jen.Id("i").Dot(structField).Op("!=").Nil()).Block(
						jen.Id("m").Dot(setMethod).Call(jen.Op("*").Id("i").Dot(structField)),
					)
				} else {
					// Required edge: always set
					group.Id("m").Dot(setMethod).Call(jen.Id("i").Dot(structField))
				}
			} else {
				// Use the edge's MutationAdd method name (uses rules.Singularize for proper handling)
				addMethod := edge.MutationAdd()
				// Struct field name: Singular(edgeName) + "IDs", e.g., "ChildIDs" for "children" edge
				structField := addMethod[3:] // Remove "Add" prefix to get "ChildIDs"
				group.If(jen.Len(jen.Id("i").Dot(structField)).Op(">").Lit(0)).Block(
					jen.Id("m").Dot(addMethod).Call(jen.Id("i").Dot(structField).Op("...")),
				)
			}
		}
	})
	f.Line()
}

// genCreateSetInput generates the SetInput method on CreateXXX builder.
func (g *Generator) genCreateSetInput(f *jen.File, t *gen.Type) {
	typeName := t.Name
	inputName := "Create" + typeName + "Input"
	builderName := typeName + "Create"

	f.Comment(fmt.Sprintf("SetInput applies the change-set in the %s on the %s builder.", inputName, builderName))
	f.Func().Params(
		jen.Id("c").Add(g.ormTypePtr(builderName)),
	).Id("SetInput").Params(
		jen.Id("i").Id(inputName),
	).Add(g.ormTypePtr(builderName)).Block(
		jen.Id("i").Dot("Mutate").Call(jen.Id("c").Dot("Mutation").Call()),
		jen.Return(jen.Id("c")),
	)
	f.Line()
}

// genUpdateInputStruct generates the UpdateXXXInput struct.
func (g *Generator) genUpdateInputStruct(f *jen.File, t *gen.Type) {
	typeName := t.Name
	inputName := "Update" + typeName + "Input"

	f.Comment(fmt.Sprintf("%s represents a mutation input for updating %s.", inputName, strings.ToLower(typeName)+"s"))
	f.Type().Id(inputName).StructFunc(func(group *jen.Group) {
		// Track if we've added any fields
		hasFields := false

		// Fields - use filterFields helper (like Ent)
		fields := g.filterFields(t.Fields, SkipMutationUpdateInput)
		for _, field := range fields {
			if field.Immutable || !g.fieldInUpdateInput(field) {
				continue
			}

			fieldName := pascal(field.Name)
			fieldType := g.goInputFieldType(field, t.Name)

			// Clear field for nillable fields
			if field.Nillable {
				group.Id("Clear" + fieldName).Bool()
			}

			// All update fields are optional (pointers)
			// Exception: reference types (map, slice) don't need pointers
			if g.isReferenceType(field) {
				group.Id(fieldName).Add(fieldType)
			} else {
				group.Id(fieldName).Op("*").Add(fieldType)
			}

			// Append field for slice types (JSON arrays)
			if field.SupportsMutationAppend() {
				group.Id("Append" + fieldName).Add(fieldType)
			}
			hasFields = true
		}

		// Edge fields
		for _, edge := range t.Edges {
			if edge.Immutable {
				continue
			}
			// Skip inverse edges that don't own the FK (handled on the other side)
			// But include M2O and inverse O2O edges where the FK is on this table
			if edge.IsInverse() && !edge.OwnFK() {
				continue
			}
			// Skip edges that have explicit FK fields (already generated from fields)
			if g.edgeHasExplicitFKField(edge) {
				continue
			}

			edgeName := pascal(edge.Name)
			idType := g.edgeIDType(edge)

			// Clear edge (only for optional edges)
			// Required edges cannot be cleared - they must always have a value
			if edge.Optional {
				group.Id("Clear" + edgeName).Bool()
			}

			if edge.Unique {
				// Single edge: *ID
				group.Id(edgeName + "ID").Op("*").Add(idType)
			} else {
				// Multiple edges: Add/Remove (use MutationAdd/MutationRemove for proper naming)
				// Struct fields use the full method name without "Add"/"Remove" prefix collision
				addMethod := edge.MutationAdd()
				removeMethod := edge.MutationRemove()
				group.Id(addMethod).Index().Add(idType)    // "AddChildIDs" field
				group.Id(removeMethod).Index().Add(idType) // "RemoveChildIDs" field
			}
			hasFields = true
		}

		// If no fields were added, add a placeholder to match the GraphQL schema
		// This prevents empty struct issues
		if !hasFields {
			group.Comment("Placeholder field for entities with no updatable fields")
			group.Id("Placeholder").Op("*").Bool().Tag(map[string]string{"json": "_placeholder,omitempty"})
		}
	})
	f.Line()
}

// genUpdateInputMutate generates the Mutate method for UpdateXXXInput.
func (g *Generator) genUpdateInputMutate(f *jen.File, t *gen.Type) {
	typeName := t.Name
	inputName := "Update" + typeName + "Input"
	mutationName := typeName + "Mutation"

	f.Comment(fmt.Sprintf("Mutate applies the %s on the %s builder.", inputName, mutationName))
	f.Func().Params(
		jen.Id("i").Op("*").Id(inputName),
	).Id("Mutate").Params(
		jen.Id("m").Add(g.ormTypePtr(mutationName)),
	).BlockFunc(func(group *jen.Group) {
		// Process fields: Clear, Set, Append (in order)
		// Use filterFields helper (like Ent)
		fields := g.filterFields(t.Fields, SkipMutationUpdateInput)
		for _, field := range fields {
			if field.Immutable || !g.fieldInUpdateInput(field) {
				continue
			}

			fieldName := pascal(field.Name)

			// Clear (for nillable fields)
			if field.Nillable {
				group.If(jen.Id("i").Dot("Clear" + fieldName)).Block(
					jen.Id("m").Dot("Clear" + fieldName).Call(),
				)
			}

			// Set
			switch {
			case g.isStructType(field):
				// Struct types: can't compare to nil, always set the value
				// The ORM will handle zero values appropriately
				group.Id("m").Dot("Set" + fieldName).Call(jen.Id("i").Dot(fieldName))
			case g.isPointerType(field):
				// Pointer types: check nil and dereference (ORM setter expects non-pointer)
				group.If(jen.Id("i").Dot(fieldName).Op("!=").Nil()).Block(
					jen.Id("m").Dot("Set" + fieldName).Call(jen.Op("*").Id("i").Dot(fieldName)),
				)
			case g.isReferenceType(field):
				// Other reference types (maps, slices): check nil but don't dereference
				group.If(jen.Id("i").Dot(fieldName).Op("!=").Nil()).Block(
					jen.Id("m").Dot("Set" + fieldName).Call(jen.Id("i").Dot(fieldName)),
				)
			default:
				// Value types: check nil and dereference
				group.If(jen.Id("i").Dot(fieldName).Op("!=").Nil()).Block(
					jen.Id("m").Dot("Set" + fieldName).Call(jen.Op("*").Id("i").Dot(fieldName)),
				)
			}

			// Append (for slice fields - JSON arrays)
			if field.SupportsMutationAppend() {
				group.If(jen.Id("i").Dot("Append" + fieldName).Op("!=").Nil()).Block(
					jen.Id("m").Dot("Append" + fieldName).Call(jen.Id("i").Dot("Append" + fieldName)),
				)
			}
		}

		// Process edges: Clear, Set/Add/Remove
		for _, edge := range t.Edges {
			if edge.Immutable {
				continue
			}
			// Skip inverse edges that don't own the FK (handled on the other side)
			// But include M2O and inverse O2O edges where the FK is on this table
			if edge.IsInverse() && !edge.OwnFK() {
				continue
			}
			// Skip edges that have explicit FK fields (already handled in fields section)
			if g.edgeHasExplicitFKField(edge) {
				continue
			}

			edgeName := pascal(edge.Name)

			// Clear (only for optional edges)
			// Required edges cannot be cleared - they must always have a value
			if edge.Optional {
				group.If(jen.Id("i").Dot("Clear" + edgeName)).Block(
					jen.Id("m").Dot("Clear" + edgeName).Call(),
				)
			}

			if edge.Unique {
				// Set single edge
				structField := edgeName + "ID"
				setMethod := edge.MutationSet()
				group.If(jen.Id("i").Dot(structField).Op("!=").Nil()).Block(
					jen.Id("m").Dot(setMethod).Call(jen.Op("*").Id("i").Dot(structField)),
				)
			} else {
				// Add edges (use MutationAdd for proper singular form)
				// Both struct field and method use the same name (AddChildIDs)
				addMethod := edge.MutationAdd()
				group.If(jen.Len(jen.Id("i").Dot(addMethod)).Op(">").Lit(0)).Block(
					jen.Id("m").Dot(addMethod).Call(jen.Id("i").Dot(addMethod).Op("...")),
				)

				// Remove edges (use MutationRemove for proper singular form)
				// Both struct field and method use the same name (RemoveChildIDs)
				removeMethod := edge.MutationRemove()
				group.If(jen.Len(jen.Id("i").Dot(removeMethod)).Op(">").Lit(0)).Block(
					jen.Id("m").Dot(removeMethod).Call(jen.Id("i").Dot(removeMethod).Op("...")),
				)
			}
		}
	})
	f.Line()
}

// genUpdateSetInput generates the SetInput method on UpdateXXX and UpdateOneXXX builders.
func (g *Generator) genUpdateSetInput(f *jen.File, t *gen.Type) {
	typeName := t.Name
	inputName := "Update" + typeName + "Input"

	// SetInput on UpdateXXX builder
	builderName := typeName + "Update"
	f.Comment(fmt.Sprintf("SetInput applies the change-set in the %s on the %s builder.", inputName, builderName))
	f.Func().Params(
		jen.Id("c").Add(g.ormTypePtr(builderName)),
	).Id("SetInput").Params(
		jen.Id("i").Id(inputName),
	).Add(g.ormTypePtr(builderName)).Block(
		jen.Id("i").Dot("Mutate").Call(jen.Id("c").Dot("Mutation").Call()),
		jen.Return(jen.Id("c")),
	)
	f.Line()

	// SetInput on UpdateOneXXX builder
	builderOneName := typeName + "UpdateOne"
	f.Comment(fmt.Sprintf("SetInput applies the change-set in the %s on the %s builder.", inputName, builderOneName))
	f.Func().Params(
		jen.Id("c").Add(g.ormTypePtr(builderOneName)),
	).Id("SetInput").Params(
		jen.Id("i").Id(inputName),
	).Add(g.ormTypePtr(builderOneName)).Block(
		jen.Id("i").Dot("Mutate").Call(jen.Id("c").Dot("Mutation").Call()),
		jen.Return(jen.Id("c")),
	)
	f.Line()
}

// goInputFieldType returns the Go type for a field in mutation input.
// entityName is used to qualify enum types (e.g., category.Status).
func (g *Generator) goInputFieldType(f *gen.Field, entityName string) jen.Code {
	if f.Type == nil {
		return jen.String()
	}

	// Handle special types
	if f.IsTime() {
		return jen.Qual("time", "Time")
	}
	if f.IsUUID() {
		return jen.Qual("github.com/google/uuid", "UUID")
	}
	if f.IsEnum() {
		// Check if enum has custom GoType (like schematype.Currency)
		if f.HasGoType() && f.Type != nil && f.Type.PkgPath != "" {
			typeName := f.Type.Ident
			if idx := strings.LastIndex(typeName, "."); idx >= 0 {
				typeName = typeName[idx+1:]
			}
			return jen.Qual(f.Type.PkgPath, typeName)
		}
		// Fall back to auto-generated enum type in entity package (e.g., category.Status)
		entityPkg := g.config.ORMPackage + "/" + strings.ToLower(entityName)
		return jen.Qual(entityPkg, pascal(f.Name))
	}
	if f.IsJSON() {
		// For JSON fields with custom Go types (like map[string]interface{}), use the actual type
		if f.HasGoType() && f.Type != nil && f.Type.Ident != "" {
			if f.Type.PkgPath != "" {
				// Qualified type (e.g., custom JSON type from another package)
				typeName := f.Type.Ident

				// Handle pointer types: *pkgname.Type -> *Type from pkgname
				var isPointer bool
				if strings.HasPrefix(typeName, "*") {
					isPointer = true
					typeName = typeName[1:]
				}

				// Handle slice types: []pkgname.Type -> []Type from pkgname
				var isSlice bool
				if strings.HasPrefix(typeName, "[]") {
					isSlice = true
					typeName = typeName[2:]
				}

				// Extract just the type name (e.g., schematype.Permission -> Permission)
				if idx := strings.LastIndex(typeName, "."); idx >= 0 {
					typeName = typeName[idx+1:]
				}

				qualType := jen.Qual(f.Type.PkgPath, typeName)
				if isSlice {
					return jen.Index().Add(qualType)
				}
				if isPointer {
					return jen.Op("*").Add(qualType)
				}
				return qualType
			}
			// Unqualified type (like map[string]interface{})
			return jen.Id(f.Type.Ident)
		}
		return jen.Any()
	}

	// Handle list types (JSON arrays)
	if f.SupportsMutationAppend() {
		elemType := g.goBasicType(f)
		return jen.Index().Add(elemType)
	}

	// Handle custom Go types (e.g., decimal.Decimal, custom structs)
	// This must come after list types check to avoid wrong handling
	if f.HasGoType() && f.Type != nil && f.Type.Ident != "" {
		if f.Type.PkgPath != "" {
			// Qualified type from external package (e.g., decimal.Decimal)
			typeName := f.Type.Ident
			if idx := strings.LastIndex(typeName, "."); idx >= 0 {
				typeName = typeName[idx+1:]
			}
			return jen.Qual(f.Type.PkgPath, typeName)
		}
		// Unqualified custom type
		return jen.Id(f.Type.Ident)
	}

	return g.goBasicType(f)
}

// goBasicType returns the basic Go type for a field.
// Uses field.Type enum constants for robust type matching.
func (g *Generator) goBasicType(f *gen.Field) jen.Code {
	if f.Type == nil {
		return jen.String()
	}

	switch f.Type.Type {
	case field.TypeString:
		return jen.String()
	case field.TypeInt:
		return jen.Int()
	case field.TypeInt8:
		return jen.Int8()
	case field.TypeInt16:
		return jen.Int16()
	case field.TypeInt32:
		return jen.Int32()
	case field.TypeInt64:
		return jen.Int64()
	case field.TypeUint:
		return jen.Uint()
	case field.TypeUint8:
		return jen.Uint8()
	case field.TypeUint16:
		return jen.Uint16()
	case field.TypeUint32:
		return jen.Uint32()
	case field.TypeUint64:
		return jen.Uint64()
	case field.TypeFloat32:
		return jen.Float32()
	case field.TypeFloat64:
		return jen.Float64()
	case field.TypeBool:
		return jen.Bool()
	case field.TypeBytes:
		return jen.Index().Byte()
	default:
		// For unknown types (TypeOther, TypeInvalid), return string as fallback
		return jen.String()
	}
}

// edgeIDType returns the Go type for edge IDs.
func (g *Generator) edgeIDType(e *gen.Edge) jen.Code {
	if e.Type != nil && e.Type.ID != nil {
		if e.Type.ID.IsInt64() {
			return jen.Int64()
		}
		if e.Type.ID.IsInt() {
			return jen.Int()
		}
		if e.Type.ID.IsUUID() {
			return jen.Qual("github.com/google/uuid", "UUID")
		}
		if e.Type.ID.IsString() {
			return jen.String()
		}
	}
	// Default to int (matching Ent's default ID type)
	return jen.Int()
}
