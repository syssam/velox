package graphql

// This file generates WhereInput filter types (gql_where_input.go).
// WhereInputs provide type-safe filtering in GraphQL queries:
//   - Logical operators: not, and, or for composing complex filters
//   - Field predicates: EQ, NEQ, In, NotIn, GT, GTE, LT, LTE, Contains, etc.
//   - Edge predicates: HasXxx, HasXxxWith for relationship filtering
//   - Custom predicates via AddPredicates method

import (
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/syssam/velox/compiler/gen"
	"github.com/syssam/velox/schema/field"
)

// genWhereInputGo generates gql_where_input.go with WhereInput filter types.
// This follows entgql's where_input.tmpl pattern exactly:
//   - XXXWhereInput struct with Not, Or, And fields for composability
//   - Field predicates (EQ, NEQ, In, NotIn, GT, GTE, LT, LTE, Contains, etc.)
//   - Edge predicates (HasXxx, HasXxxWith)
//   - AddPredicates method for custom predicates
//   - Filter method to apply WhereInput to a query
//   - P method to build a predicate from the WhereInput
//
// Note: genWhereInput in generator.go generates SDL (GraphQL schema),
// while this function generates Go code.
func (g *Generator) genWhereInputGo() *jen.File {
	if g.config.ORMPackage == "" || !g.config.WhereInputs {
		return nil
	}

	f := jen.NewFile(g.config.Package)
	f.HeaderComment("Code generated by velox. DO NOT EDIT.")

	// Import statements
	f.ImportName("errors", "errors")
	f.ImportName("fmt", "fmt")

	// Import predicate package
	predicatePkg := g.config.ORMPackage + "/predicate"
	f.ImportName(predicatePkg, "predicate")

	// Use filterNodes helper (like Ent) - filter both SkipType and SkipWhereInput
	nodes := g.filterNodes(g.graph.Nodes, SkipType|SkipWhereInput)

	// Import entity packages
	for _, t := range nodes {
		entityPkg := g.config.ORMPackage + "/" + strings.ToLower(t.Name)
		f.ImportName(entityPkg, strings.ToLower(t.Name))
	}

	// Generate WhereInput for each entity
	for _, t := range nodes {
		g.genEntityWhereInputGo(f, t)
	}

	return f
}

// genEntityWhereInputGo generates the WhereInput struct and methods for an entity.
func (g *Generator) genEntityWhereInputGo(f *jen.File, t *gen.Type) {
	typeName := g.graphqlTypeName(t)
	inputName := typeName + "WhereInput"
	queryType := t.Name + "Query"
	predicatePkg := g.config.ORMPackage + "/predicate"
	entityPkg := g.config.ORMPackage + "/" + strings.ToLower(t.Name)
	errName := "ErrEmpty" + inputName

	// Collect all filterable fields (ID + all fields except skipped)
	var filterableFields []*gen.Field
	if t.ID != nil && !g.skipFieldInWhereInput(t.ID) {
		filterableFields = append(filterableFields, t.ID)
	}
	for _, fld := range t.Fields {
		if !g.skipFieldInWhereInput(fld) {
			filterableFields = append(filterableFields, fld)
		}
	}

	// WhereInput struct
	f.Comment(fmt.Sprintf("%s represents a where input for filtering %s queries.", inputName, t.Name))
	f.Type().Id(inputName).StructFunc(func(group *jen.Group) {
		// Predicates field for custom predicates
		group.Id("Predicates").Index().Qual(predicatePkg, t.Name).Tag(map[string]string{"json": "-"})
		// Not, Or, And for composability
		group.Id("Not").Op("*").Id(inputName).Tag(map[string]string{"json": "not,omitempty"})
		group.Id("Or").Index().Op("*").Id(inputName).Tag(map[string]string{"json": "or,omitempty"})
		group.Id("And").Index().Op("*").Id(inputName).Tag(map[string]string{"json": "and,omitempty"})

		// Field predicates
		for _, fld := range filterableFields {
			g.genWhereInputFieldPredicates(group, t, fld)
		}

		// Edge predicates
		for _, edge := range t.Edges {
			if g.skipEdgeInWhereInput(edge) {
				continue
			}
			g.genWhereInputEdgePredicates(group, edge)
		}
	})
	f.Line()

	// AddPredicates method
	f.Comment("AddPredicates adds custom predicates to the where input to be used during the filtering phase.")
	f.Func().Params(
		jen.Id("i").Op("*").Id(inputName),
	).Id("AddPredicates").Params(
		jen.Id("predicates").Op("...").Qual(predicatePkg, t.Name),
	).Block(
		jen.Id("i").Dot("Predicates").Op("=").Append(
			jen.Id("i").Dot("Predicates"),
			jen.Id("predicates").Op("..."),
		),
	)
	f.Line()

	// Filter method (before Error variable to match Ent order)
	f.Comment(fmt.Sprintf("Filter applies the %s filter on the %s builder.", inputName, queryType))
	f.Func().Params(
		jen.Id("i").Op("*").Id(inputName),
	).Id("Filter").Params(
		jen.Id("q").Add(g.ormTypePtr(queryType)),
	).Params(
		g.ormTypePtr(queryType),
		jen.Error(),
	).Block(
		jen.If(jen.Id("i").Op("==").Nil()).Block(
			jen.Return(jen.Id("q"), jen.Nil()),
		),
		jen.List(jen.Id("p"), jen.Id("err")).Op(":=").Id("i").Dot("P").Call(),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			// Skip errors only for top-level empty predicates
			jen.If(jen.Id("err").Op("==").Id(errName)).Block(
				jen.Return(jen.Id("q"), jen.Nil()),
			),
			jen.Return(jen.Nil(), jen.Id("err")),
		),
		jen.Return(jen.Id("q").Dot("Where").Call(jen.Id("p")), jen.Nil()),
	)
	f.Line()

	// Error variable (after Filter to match Ent order)
	f.Comment(fmt.Sprintf("%s is returned in case the %s is empty.", errName, inputName))
	f.Var().Id(errName).Op("=").Qual("errors", "New").Call(
		jen.Lit("velox: empty predicate " + inputName),
	)
	f.Line()

	// P method - builds predicate from where input
	g.genWhereInputPMethod(f, t, inputName, errName, filterableFields, entityPkg, predicatePkg)
}

// genWhereInputFieldPredicates generates field predicate fields in the struct.
func (g *Generator) genWhereInputFieldPredicates(group *jen.Group, t *gen.Type, fld *gen.Field) {
	// Use uppercase ID for consistency with Ent (ID, IDNEQ, IDIn, etc.)
	structField := pascal(fld.Name)
	if strings.EqualFold(fld.Name, "id") {
		structField = "ID"
	}

	// Define operators for this field type
	ops := g.getWhereInputFieldOps(fld)

	group.Line()
	group.Comment(fmt.Sprintf("%q field predicates.", fld.Name))

	for _, op := range ops {
		fieldName := structField + op.Name
		jsonTag := camel(fld.Name) + op.Name

		// EQ is named just by the field name
		if op.Name == "EQ" {
			fieldName = structField
			jsonTag = camel(fld.Name)
		}

		var fieldType jen.Code
		goType := g.goWhereInputFieldType(fld, t.Name)

		switch {
		case op.Niladic:
			// Niladic ops are bool (IsNil, NotNil)
			fieldType = jen.Bool()
		case op.Variadic:
			// Variadic ops are slices (In, NotIn)
			fieldType = jen.Index().Add(goType)
		default:
			// Regular ops are pointers
			fieldType = jen.Op("*").Add(goType)
		}

		group.Id(fieldName).Add(fieldType).Tag(map[string]string{"json": jsonTag + ",omitempty"})
	}
}

// genWhereInputEdgePredicates generates edge predicate fields in the struct.
func (g *Generator) genWhereInputEdgePredicates(group *jen.Group, edge *gen.Edge) {
	// Skip edges with nil Type
	if edge.Type == nil {
		return
	}
	structField := pascal(edge.Name)
	hasField := "Has" + structField
	hasWithField := hasField + "With"
	targetInputName := g.graphqlTypeName(edge.Type) + "WhereInput"

	group.Line()
	group.Comment(fmt.Sprintf("%q edge predicates.", edge.Name))

	// HasXxx *bool
	group.Id(hasField).Op("*").Bool().Tag(map[string]string{
		"json": camel("has_"+edge.Name) + ",omitempty",
	})

	// HasXxxWith []*EdgeWhereInput
	group.Id(hasWithField).Index().Op("*").Id(targetInputName).Tag(map[string]string{
		"json": camel("has_"+edge.Name+"_with") + ",omitempty",
	})
}

// genWhereInputPMethod generates the P() method for building predicates.
func (g *Generator) genWhereInputPMethod(f *jen.File, t *gen.Type, inputName, errName string, filterableFields []*gen.Field, entityPkg, predicatePkg string) {
	f.Comment(fmt.Sprintf("P returns a predicate for filtering %ss.", strings.ToLower(t.Name)))
	f.Comment("An error is returned if the input is empty or invalid.")
	f.Func().Params(
		jen.Id("i").Op("*").Id(inputName),
	).Id("P").Params().Params(
		jen.Qual(predicatePkg, t.Name),
		jen.Error(),
	).BlockFunc(func(group *jen.Group) {
		group.Var().Id("predicates").Index().Qual(predicatePkg, t.Name)

		// Handle Not
		group.If(jen.Id("i").Dot("Not").Op("!=").Nil()).Block(
			jen.List(jen.Id("p"), jen.Id("err")).Op(":=").Id("i").Dot("Not").Dot("P").Call(),
			jen.If(jen.Id("err").Op("!=").Nil()).Block(
				jen.Return(jen.Nil(), jen.Qual("fmt", "Errorf").Call(jen.Lit("%w: field 'not'"), jen.Id("err"))),
			),
			jen.Id("predicates").Op("=").Append(jen.Id("predicates"), jen.Qual(entityPkg, "Not").Call(jen.Id("p"))),
		)

		// Handle Or - always wrap in Or() for semantic consistency
		group.If(jen.Len(jen.Id("i").Dot("Or")).Op(">").Lit(0)).BlockFunc(func(orGroup *jen.Group) {
			orGroup.Id("or").Op(":=").Make(jen.Index().Qual(predicatePkg, t.Name), jen.Lit(0), jen.Len(jen.Id("i").Dot("Or")))
			orGroup.For(jen.List(jen.Id("_"), jen.Id("w")).Op(":=").Range().Id("i").Dot("Or")).Block(
				// Skip nil elements in the Or slice
				jen.If(jen.Id("w").Op("==").Nil()).Block(
					jen.Continue(),
				),
				jen.List(jen.Id("p"), jen.Id("err")).Op(":=").Id("w").Dot("P").Call(),
				jen.If(jen.Id("err").Op("!=").Nil()).Block(
					jen.Return(jen.Nil(), jen.Qual("fmt", "Errorf").Call(jen.Lit("%w: field 'or'"), jen.Id("err"))),
				),
				jen.Id("or").Op("=").Append(jen.Id("or"), jen.Id("p")),
			)
			orGroup.Id("predicates").Op("=").Append(jen.Id("predicates"), jen.Qual(entityPkg, "Or").Call(jen.Id("or").Op("...")))
		})

		// Handle And - always wrap in And() for semantic consistency
		group.If(jen.Len(jen.Id("i").Dot("And")).Op(">").Lit(0)).BlockFunc(func(andGroup *jen.Group) {
			andGroup.Id("and").Op(":=").Make(jen.Index().Qual(predicatePkg, t.Name), jen.Lit(0), jen.Len(jen.Id("i").Dot("And")))
			andGroup.For(jen.List(jen.Id("_"), jen.Id("w")).Op(":=").Range().Id("i").Dot("And")).Block(
				// Skip nil elements in the And slice
				jen.If(jen.Id("w").Op("==").Nil()).Block(
					jen.Continue(),
				),
				jen.List(jen.Id("p"), jen.Id("err")).Op(":=").Id("w").Dot("P").Call(),
				jen.If(jen.Id("err").Op("!=").Nil()).Block(
					jen.Return(jen.Nil(), jen.Qual("fmt", "Errorf").Call(jen.Lit("%w: field 'and'"), jen.Id("err"))),
				),
				jen.Id("and").Op("=").Append(jen.Id("and"), jen.Id("p")),
			)
			andGroup.Id("predicates").Op("=").Append(jen.Id("predicates"), jen.Qual(entityPkg, "And").Call(jen.Id("and").Op("...")))
		})

		// Append custom predicates
		group.Id("predicates").Op("=").Append(jen.Id("predicates"), jen.Id("i").Dot("Predicates").Op("..."))

		// Handle field predicates
		for _, fld := range filterableFields {
			g.genWhereInputFieldPredicateChecks(group, t, fld, entityPkg)
		}

		// Handle edge predicates
		for _, edge := range t.Edges {
			if g.skipEdgeInWhereInput(edge) {
				continue
			}
			g.genWhereInputEdgePredicateChecks(group, edge, entityPkg, predicatePkg)
		}

		// Return based on predicate count
		group.Switch(jen.Len(jen.Id("predicates"))).BlockFunc(func(sw *jen.Group) {
			sw.Case(jen.Lit(0)).Block(
				jen.Return(jen.Nil(), jen.Id(errName)),
			)
			sw.Case(jen.Lit(1)).Block(
				jen.Return(jen.Id("predicates").Index(jen.Lit(0)), jen.Nil()),
			)
			sw.Default().Block(
				jen.Return(jen.Qual(entityPkg, "And").Call(jen.Id("predicates").Op("...")), jen.Nil()),
			)
		})
	})
	f.Line()
}

// genWhereInputFieldPredicateChecks generates field predicate checks in the P() method.
func (g *Generator) genWhereInputFieldPredicateChecks(group *jen.Group, t *gen.Type, fld *gen.Field, entityPkg string) {
	// Use uppercase ID for consistency with Ent
	structField := pascal(fld.Name)
	if strings.EqualFold(fld.Name, "id") {
		structField = "ID"
	}
	ops := g.getWhereInputFieldOps(fld)
	useGeneric := g.useGenericPredicates()

	// For generic predicates: all fields use "Field" suffix
	// e.g., user.EmailField.EQ(), user.StatusField.EQ()
	// Check for enum value conflicts (e.g., WorkModeField enum value)
	predicateVarName := g.getPredicateVarName(t, structField)

	for _, op := range ops {
		fieldName := structField + op.Name
		funcName := structField + op.Name

		// EQ is named just by the field name
		if op.Name == "EQ" {
			fieldName = structField
		}

		switch {
		case op.Niladic:
			// Niladic ops (IsNil, NotNil)
			if useGeneric {
				// Generate: entityPkg.FieldNameField.OpName()
				group.If(jen.Id("i").Dot(fieldName)).Block(
					jen.Id("predicates").Op("=").Append(
						jen.Id("predicates"),
						jen.Qual(entityPkg, predicateVarName).Dot(op.Name).Call(),
					),
				)
			} else {
				group.If(jen.Id("i").Dot(fieldName)).Block(
					jen.Id("predicates").Op("=").Append(
						jen.Id("predicates"),
						jen.Qual(entityPkg, funcName).Call(),
					),
				)
			}
		case op.Variadic:
			// Variadic ops (In, NotIn)
			if useGeneric {
				// Generate: entityPkg.FieldNameField.OpName(values...)
				group.If(jen.Len(jen.Id("i").Dot(fieldName)).Op(">").Lit(0)).Block(
					jen.Id("predicates").Op("=").Append(
						jen.Id("predicates"),
						jen.Qual(entityPkg, predicateVarName).Dot(op.Name).Call(jen.Id("i").Dot(fieldName).Op("...")),
					),
				)
			} else {
				group.If(jen.Len(jen.Id("i").Dot(fieldName)).Op(">").Lit(0)).Block(
					jen.Id("predicates").Op("=").Append(
						jen.Id("predicates"),
						jen.Qual(entityPkg, funcName).Call(jen.Id("i").Dot(fieldName).Op("...")),
					),
				)
			}
		default:
			// Regular ops
			if useGeneric {
				// Generate: entityPkg.FieldNameField.OpName(*value)
				group.If(jen.Id("i").Dot(fieldName).Op("!=").Nil()).Block(
					jen.Id("predicates").Op("=").Append(
						jen.Id("predicates"),
						jen.Qual(entityPkg, predicateVarName).Dot(op.Name).Call(jen.Op("*").Id("i").Dot(fieldName)),
					),
				)
			} else {
				group.If(jen.Id("i").Dot(fieldName).Op("!=").Nil()).Block(
					jen.Id("predicates").Op("=").Append(
						jen.Id("predicates"),
						jen.Qual(entityPkg, funcName).Call(jen.Op("*").Id("i").Dot(fieldName)),
					),
				)
			}
		}
	}
}

// genWhereInputEdgePredicateChecks generates edge predicate checks in the P() method.
func (g *Generator) genWhereInputEdgePredicateChecks(group *jen.Group, edge *gen.Edge, entityPkg, predicatePkg string) {
	// Skip edges with nil Type (shouldn't happen in valid schema but adds safety)
	if edge.Type == nil {
		return
	}
	structField := pascal(edge.Name)
	hasField := "Has" + structField
	hasWithField := hasField + "With"

	// HasXxx predicate
	group.If(jen.Id("i").Dot(hasField).Op("!=").Nil()).Block(
		jen.Id("p").Op(":=").Qual(entityPkg, hasField).Call(),
		jen.If(jen.Op("!").Op("*").Id("i").Dot(hasField)).Block(
			jen.Id("p").Op("=").Qual(entityPkg, "Not").Call(jen.Id("p")),
		),
		jen.Id("predicates").Op("=").Append(jen.Id("predicates"), jen.Id("p")),
	)

	// HasXxxWith predicate
	group.If(jen.Len(jen.Id("i").Dot(hasWithField)).Op(">").Lit(0)).Block(
		jen.Id("with").Op(":=").Make(
			jen.Index().Qual(predicatePkg, edge.Type.Name),
			jen.Lit(0),
			jen.Len(jen.Id("i").Dot(hasWithField)),
		),
		jen.For(jen.List(jen.Id("_"), jen.Id("w")).Op(":=").Range().Id("i").Dot(hasWithField)).Block(
			jen.List(jen.Id("p"), jen.Id("err")).Op(":=").Id("w").Dot("P").Call(),
			jen.If(jen.Id("err").Op("!=").Nil()).Block(
				jen.Return(jen.Nil(), jen.Qual("fmt", "Errorf").Call(
					jen.Lit("%w: field '"+hasWithField+"'"),
					jen.Id("err"),
				)),
			),
			jen.Id("with").Op("=").Append(jen.Id("with"), jen.Id("p")),
		),
		jen.Id("predicates").Op("=").Append(
			jen.Id("predicates"),
			jen.Qual(entityPkg, hasWithField).Call(jen.Id("with").Op("...")),
		),
	)
}

// whereInputFieldOp represents a predicate operator for a field.
type whereInputFieldOp struct {
	Name     string
	Niladic  bool // No arguments (IsNil, NotNil)
	Variadic bool // Slice argument (In, NotIn)
}

// getWhereInputFieldOps returns the operators available for a field based on its type
// and annotations. The order matches Ent's entgql: EQ, NEQ, In, NotIn, GT, GTE, LT, LTE,
// Contains, HasPrefix, HasSuffix, EqualFold, ContainsFold, IsNil, NotNil.
//
// Smart defaults by field type:
//   - ID/FK fields (name ends with "ID" or "_id"): OpsEquality (4 ops: EQ, NEQ, In, NotIn)
//   - String fields: OpsString (9 ops: EQ, NEQ, In, NotIn, Contains, ContainsFold, EqualFold, HasPrefix, HasSuffix)
//   - Numeric/Time fields: OpsComparison (8 ops: EQ, NEQ, In, NotIn, GT, GTE, LT, LTE)
//   - Enum fields: OpsEquality (4 ops: EQ, NEQ, In, NotIn)
//   - Bool fields: 2 ops (EQ, NEQ)
//   - Nullable fields: automatically add OpsNullable (+2 ops: IsNil, NotNil)
func (g *Generator) getWhereInputFieldOps(fld *gen.Field) []whereInputFieldOp {
	// JSON fields don't support standard predicates
	if fld.IsJSON() {
		return nil
	}

	// Get effective WhereOps for this field
	whereOps := g.getEffectiveWhereOps(fld)

	// Build operators list based on WhereOps flags
	var ops []whereInputFieldOp

	// EQ, NEQ
	if whereOps.HasEQ() {
		ops = append(ops, whereInputFieldOp{Name: "EQ"})
	}
	if whereOps.HasNEQ() {
		ops = append(ops, whereInputFieldOp{Name: "NEQ"})
	}

	// In, NotIn (variadic)
	if whereOps.HasIn() {
		ops = append(ops, whereInputFieldOp{Name: "In", Variadic: true})
	}
	if whereOps.HasNotIn() {
		ops = append(ops, whereInputFieldOp{Name: "NotIn", Variadic: true})
	}

	// GT, GTE, LT, LTE (ordering)
	if whereOps.HasGT() {
		ops = append(ops, whereInputFieldOp{Name: "GT"})
	}
	if whereOps.HasGTE() {
		ops = append(ops, whereInputFieldOp{Name: "GTE"})
	}
	if whereOps.HasLT() {
		ops = append(ops, whereInputFieldOp{Name: "LT"})
	}
	if whereOps.HasLTE() {
		ops = append(ops, whereInputFieldOp{Name: "LTE"})
	}

	// String operations (substring matching)
	if whereOps.HasContains() {
		ops = append(ops, whereInputFieldOp{Name: "Contains"})
	}
	if whereOps.HasHasPrefix() {
		ops = append(ops, whereInputFieldOp{Name: "HasPrefix"})
	}
	if whereOps.HasHasSuffix() {
		ops = append(ops, whereInputFieldOp{Name: "HasSuffix"})
	}

	// Case-insensitive operations
	if whereOps.HasEqualFold() {
		ops = append(ops, whereInputFieldOp{Name: "EqualFold"})
	}
	if whereOps.HasContainsFold() {
		ops = append(ops, whereInputFieldOp{Name: "ContainsFold"})
	}

	// Nullable operations (niladic)
	if whereOps.HasIsNil() {
		ops = append(ops, whereInputFieldOp{Name: "IsNil", Niladic: true})
	}
	if whereOps.HasNotNil() {
		ops = append(ops, whereInputFieldOp{Name: "NotNil", Niladic: true})
	}

	return ops
}

// getEffectiveWhereOps returns the WhereOp flags for a field.
// If explicitly set via annotation, uses that. Otherwise, determines smart defaults
// based on field type and naming conventions.
func (g *Generator) getEffectiveWhereOps(fld *gen.Field) WhereOp {
	ann := g.getFieldAnnotation(fld)

	// If WhereOps explicitly set, use it
	if ann.HasWhereOpsSet() {
		ops := ann.GetWhereOps()
		// Auto-add nullable ops if field is nillable and not explicitly disabled
		if fld.Nillable && !ops.HasIsNil() && !ops.HasNotNil() {
			// Only add if the user hasn't explicitly set any ops that would
			// indicate they want full control (i.e., they set something other than OpsNone)
			if ops != OpsNone {
				ops |= OpsNullable
			}
		}
		return ops
	}

	// Smart defaults based on field type
	var ops WhereOp

	switch {
	case g.isIDOrFKField(fld):
		// ID/FK fields: equality operations only
		ops = OpsEquality
	case fld.IsBool():
		// Boolean: only EQ and NEQ make sense
		ops = OpEQ | OpNEQ
	case fld.IsEnum():
		// Enum: equality operations
		ops = OpsEquality
	case fld.IsString():
		// String: equality + text search (no GT/GTE/LT/LTE)
		ops = OpsString
	case g.isOrderedField(fld):
		// Numeric and Time: comparison operations
		ops = OpsComparison
	default:
		// Default fallback: equality
		ops = OpsEquality
	}

	// Auto-add nullable ops for nillable fields
	if fld.Nillable {
		ops |= OpsNullable
	}

	return ops
}

// isIDOrFKField returns true if the field is an ID or foreign key field.
// Detection is based on:
//   - Field name is "id" or "ID" (primary key)
//   - Field name ends with "_id" (snake_case FK convention)
//   - Field name ends with "ID" (camelCase FK convention, e.g., customerID)
//   - Field type is UUID (typically used for IDs)
func (g *Generator) isIDOrFKField(fld *gen.Field) bool {
	name := fld.Name
	lowerName := strings.ToLower(name)

	// Primary key
	if lowerName == "id" {
		return true
	}

	// Foreign key by snake_case convention (e.g., customer_id, user_id)
	if strings.HasSuffix(lowerName, "_id") {
		return true
	}

	// Foreign key by camelCase convention (e.g., customerID, userID)
	// Check if name ends with "ID" (uppercase) and has at least one char before it
	if len(name) > 2 && strings.HasSuffix(name, "ID") {
		return true
	}

	// UUID type is typically used for IDs
	if fld.IsUUID() {
		return true
	}

	return false
}

// isOrderedField returns true if the field supports ordering operators (GT, GTE, LT, LTE).
// Only checks built-in types. For custom Go types (like decimal.Decimal), users should
// explicitly set WhereOps annotation to enable comparison operations.
func (g *Generator) isOrderedField(fld *gen.Field) bool {
	if fld.Type == nil {
		return false
	}

	// Built-in numeric, time, and UUID types are ordered
	switch fld.Type.Type {
	case field.TypeInt, field.TypeInt8, field.TypeInt16, field.TypeInt32, field.TypeInt64,
		field.TypeUint, field.TypeUint8, field.TypeUint16, field.TypeUint32, field.TypeUint64,
		field.TypeFloat32, field.TypeFloat64:
		return true
	case field.TypeTime:
		return true
	case field.TypeUUID:
		// UUIDs can be compared lexicographically
		return true
	}

	// For custom Go types (decimal.Decimal, big.Int, etc.), users must explicitly
	// configure WhereOps annotation to enable comparison operations:
	//
	//   field.Other("amount", decimal.Decimal{}).
	//       Annotations(graphql.WhereOps(graphql.OpsComparison))
	//
	return false
}

// goWhereInputFieldType returns the Go type for a field in where input.
// For enum types, it returns the fully qualified type (e.g., category.Status).
func (g *Generator) goWhereInputFieldType(fld *gen.Field, entityName string) jen.Code {
	if fld.Type == nil {
		return jen.String()
	}

	// Handle special types
	if fld.IsTime() {
		return jen.Qual("time", "Time")
	}
	if fld.IsUUID() {
		return jen.Qual("github.com/google/uuid", "UUID")
	}
	if fld.IsEnum() {
		// Check if enum has custom GoType (like schematype.Currency)
		if fld.HasGoType() && fld.Type != nil && fld.Type.PkgPath != "" {
			typeName := fld.Type.Ident
			if idx := strings.LastIndex(typeName, "."); idx >= 0 {
				typeName = typeName[idx+1:]
			}
			return jen.Qual(fld.Type.PkgPath, typeName)
		}
		// Fall back to auto-generated enum type in entity package (e.g., category.Status)
		entityPkg := g.config.ORMPackage + "/" + strings.ToLower(entityName)
		return jen.Qual(entityPkg, pascal(fld.Name))
	}

	// Handle custom Go types (e.g., decimal.Decimal, custom structs)
	if fld.HasGoType() && fld.Type != nil && fld.Type.Ident != "" {
		if fld.Type.PkgPath != "" {
			// Qualified type from external package (e.g., decimal.Decimal)
			typeName := fld.Type.Ident

			// Handle slice types: []pkgname.Type -> []Type from pkgname
			var isSlice bool
			if strings.HasPrefix(typeName, "[]") {
				isSlice = true
				typeName = typeName[2:]
			}

			if idx := strings.LastIndex(typeName, "."); idx >= 0 {
				typeName = typeName[idx+1:]
			}

			qualType := jen.Qual(fld.Type.PkgPath, typeName)
			if isSlice {
				return jen.Index().Add(qualType)
			}
			return qualType
		}
		// Unqualified custom type
		return jen.Id(fld.Type.Ident)
	}

	return g.goBasicType(fld)
}

// skipFieldInWhereInput returns true if the field should be skipped in WhereInput.
func (g *Generator) skipFieldInWhereInput(fld *gen.Field) bool {
	ann := g.getFieldAnnotation(fld)
	// Check both SkipType (general skip) and SkipWhereInput (specific to WhereInput)
	return ann.IsSkipType() || ann.IsSkipField() || ann.IsSkipWhereInput() || fld.Sensitive()
}

// skipEdgeInWhereInput returns true if the edge should be skipped in WhereInput.
func (g *Generator) skipEdgeInWhereInput(e *gen.Edge) bool {
	// Check for annotations on the edge type
	ann := g.getTypeAnnotation(e.Type)
	return ann.IsSkipWhereInput()
}

// getPredicateVarName returns the predicate variable name for a field.
// All fields use "Field" suffix by default (e.g., EmailField, StatusField).
// If the name conflicts with an enum value (e.g., WorkModeField), use "Pred" suffix instead.
func (g *Generator) getPredicateVarName(t *gen.Type, structField string) string {
	// Build set of enum values that could conflict
	enumValues := make(map[string]bool)
	for _, fld := range t.Fields {
		if fld.IsEnum() {
			for _, v := range fld.EnumValues() {
				// Enum values are PascalCase + value
				enumValues[fld.StructField()+gen.Pascal(v)] = true
			}
		}
	}

	// Try "Field" suffix first
	varName := structField + "Field"
	if enumValues[varName] {
		// Conflict with enum value, use "Pred" suffix
		varName = structField + "Pred"
	}
	return varName
}
