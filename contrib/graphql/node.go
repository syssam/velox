package graphql

// This file generates Relay Node interface implementation (gql_node.go).
// It provides the foundation for Relay-compliant GraphQL APIs including:
//   - Noder interface for all node types
//   - Client.Noder() and Client.Noders() for ID-based lookup
//   - Batch loading optimization for multiple IDs
//   - Universal ID support via tables struct

import (
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/syssam/velox/compiler/gen"
	"github.com/syssam/velox/schema/field"
)

// genNode generates gql_node.go with Noder interface implementation.
// It provides:
// - Noder interface with IsNode() method
// - Per-entity implementors slices for gqlgen interface checking
// - NodeOption pattern for custom type resolution
// - Client.Noder() and Client.Noders() methods using native ID type
// - Batch loading optimization with table grouping
// - collectField integration for automatic eager loading
// - tables struct for universal-id support
func (g *Generator) genNode() *jen.File {
	f := jen.NewFile(g.config.Package)
	f.HeaderComment("Code generated by velox. DO NOT EDIT.")

	// Import statements
	f.ImportName("context", "context")
	f.ImportName("errors", "errors")
	f.ImportName("fmt", "fmt")
	f.ImportName("sync", "sync")
	f.ImportName("sync/atomic", "atomic")
	f.ImportName("github.com/99designs/gqlgen/graphql", "graphql")
	f.ImportName("golang.org/x/sync/semaphore", "semaphore")
	f.ImportName("github.com/syssam/velox/dialect", "dialect")
	f.ImportName("github.com/syssam/velox/dialect/sql", "sql")
	f.ImportName("github.com/syssam/velox/dialect/sql/schema", "schema")

	// Use filterNodes helper (like Ent)
	nodes := g.filterNodes(g.graph.Nodes, SkipType)

	// Generate entity package imports for table constants
	for _, t := range nodes {
		entityPkg := g.config.ORMPackage + "/" + strings.ToLower(t.Name)
		f.ImportName(entityPkg, strings.ToLower(t.Name))
	}

	// Universal ID bit layout constant
	// The universal-id scheme encodes table index in high bits and row ID in low bits
	f.Comment("tableIndexBitOffset is the number of bits used for the actual row ID in the universal-id scheme.")
	f.Comment("Universal-id layout: [table index (32 bits)][row ID (32 bits)]")
	f.Comment("This allows up to 2^32 tables and 2^32 rows per table.")
	f.Const().Id("tableIndexBitOffset").Op("=").Lit(32)
	f.Line()

	// Noder interface - follows entgql pattern exactly (no Node() method)
	f.Comment("Noder wraps the basic Node method.")
	f.Type().Id("Noder").InterfaceFunc(func(group *jen.Group) {
		group.Id("IsNode").Params()
	})
	f.Line()

	// Generate implementors and interface methods for each type
	g.genImplementors(f)

	// Node error variables - generic messages for security (don't expose internal details)
	f.Comment("Node resolution errors - generic messages to avoid leaking internal details.")
	f.Var().DefsFunc(func(g *jen.Group) {
		g.Id("errNodeInvalidID").Op("=").Op("&").Id("NotFoundError").Values(jen.Lit("node"))
		g.Id("ErrNodeNotFound").Op("=").Qual("errors", "New").Call(jen.Lit("node not found"))
	})
	f.Line()

	// NodeOption type
	f.Comment("NodeOption allows configuring the Noder execution using functional options.")
	f.Type().Id("NodeOption").Func().Params(jen.Op("*").Id("nodeOptions"))
	f.Line()

	// WithNodeType option - uses native ID type from graph
	idType := g.graphIDType()
	f.Comment("WithNodeType sets the node Type resolver function (i.e. the table to query).")
	f.Comment("If was not provided, the table will be derived from the universal-id configuration.")
	f.Func().Id("WithNodeType").Params(
		jen.Id("f").Func().Params(
			jen.Qual("context", "Context"),
			idType,
		).Params(jen.String(), jen.Error()),
	).Id("NodeOption").Block(
		jen.Return(jen.Func().Params(jen.Id("o").Op("*").Id("nodeOptions")).Block(
			jen.Id("o").Dot("nodeType").Op("=").Id("f"),
		)),
	)
	f.Line()

	// WithFixedNodeType option
	f.Comment("WithFixedNodeType sets the Type of the node to a fixed value.")
	f.Func().Id("WithFixedNodeType").Params(
		jen.Id("t").String(),
	).Id("NodeOption").Block(
		jen.Return(jen.Id("WithNodeType").Call(
			jen.Func().Params(
				jen.Qual("context", "Context"),
				idType,
			).Params(jen.String(), jen.Error()).Block(
				jen.Return(jen.Id("t"), jen.Nil()),
			),
		)),
	)
	f.Line()

	// nodeOptions struct
	f.Type().Id("nodeOptions").Struct(
		jen.Id("nodeType").Func().Params(
			jen.Qual("context", "Context"),
			idType,
		).Params(jen.String(), jen.Error()),
	)
	f.Line()

	// newNodeOpts helper on Client
	g.genNewNodeOpts(f)

	// Client.Noder method
	g.genClientNoder(f)

	// Client.noder internal method
	g.genClientNoderInternal(f)

	// Client.Noders method (batch)
	g.genClientNoders(f)

	// Client.noders internal method (batch)
	g.genClientNodersInternal(f)

	// tables struct for universal-id support (like Ent)
	g.genTablesStruct(f)

	// Node descriptor for schema introspection (like Ent's node_descriptor.tmpl)
	g.genNodeDescriptor(f)

	return f
}

// graphIDType returns the jen.Code for the graph-level ID type.
// This is different from idType(t *gen.Type) in collection.go which uses per-type ID.
func (g *Generator) graphIDType() jen.Code {
	if g.graph.IDType != nil {
		switch g.graph.IDType.Type {
		case field.TypeInt:
			return jen.Int()
		case field.TypeInt64:
			return jen.Int64()
		case field.TypeString:
			return jen.String()
		case field.TypeUUID:
			return jen.Qual("github.com/google/uuid", "UUID")
		default:
			return jen.Int()
		}
	}
	return jen.Int() // Default to int like Ent
}

// genImplementors generates implementors slices and interface methods for each entity.
// This follows entgql's pattern for gqlgen interface checking.
func (g *Generator) genImplementors(f *jen.File) {
	// Use filterNodes helper (like Ent)
	nodes := g.filterNodes(g.graph.Nodes, SkipType)
	for _, t := range nodes {
		typeName := g.graphqlTypeName(t)

		// Collect all interfaces this type implements
		implementors := g.getNodeImplementors(t)

		// Generate implementors slice
		// var userImplementors = []string{"User", "Node"}
		f.Var().Id(g.implementorsVarName(t)).Op("=").Index().String().ValuesFunc(func(group *jen.Group) {
			group.Lit(typeName)
			for _, iface := range implementors {
				group.Lit(iface)
			}
		})
		f.Line()

		// Generate interface check methods
		// func (*User) IsNode() {}
		f.Comment("IsNode implements the Node interface check for GQLGen.")
		f.Func().Params(jen.Op("*").Add(g.ormType(t.Name))).Id("IsNode").Params().Block()

		// Generate Is<Interface>() for each additional interface
		for _, iface := range implementors {
			if iface == "Node" {
				continue // Already handled by IsNode
			}
			methodName := "Is" + iface
			f.Comment(fmt.Sprintf("%s implements the %s interface check for GQLGen.", methodName, iface))
			f.Func().Params(jen.Op("*").Add(g.ormType(t.Name))).Id(methodName).Params().Block()
		}
		f.Line()
	}
}

// genNewNodeOpts generates the newNodeOpts helper method on Client.
func (g *Generator) genNewNodeOpts(f *jen.File) {
	idType := g.graphIDType()
	f.Func().Params(
		jen.Id("c").Add(g.ormTypePtr("Client")),
	).Id("newNodeOpts").Params(
		jen.Id("opts").Index().Id("NodeOption"),
	).Op("*").Id("nodeOptions").Block(
		jen.Id("nopts").Op(":=").Op("&").Id("nodeOptions").Values(),
		jen.For(jen.List(jen.Id("_"), jen.Id("opt")).Op(":=").Range().Id("opts")).Block(
			jen.Id("opt").Call(jen.Id("nopts")),
		),
		jen.If(jen.Id("nopts").Dot("nodeType").Op("==").Nil()).Block(
			jen.Id("nopts").Dot("nodeType").Op("=").Func().Params(
				jen.Id("ctx").Qual("context", "Context"),
				jen.Id("id").Add(idType),
			).Params(jen.String(), jen.Error()).Block(
				jen.Return(jen.Id("c").Dot("tables").Dot("nodeType").Call(
					jen.Id("ctx"),
					jen.Id("c").Dot("driver"),
					jen.Id("id"),
				)),
			),
		),
		jen.Return(jen.Id("nopts")),
	)
	f.Line()
}

// genClientNoder generates the Client.Noder method.
func (g *Generator) genClientNoder(f *jen.File) {
	idType := g.graphIDType()

	f.Comment("Noder returns a Node by its id. If the NodeType was not provided, it will")
	f.Comment("be derived from the id value according to the universal-id configuration.")
	f.Comment("")
	f.Comment("    c.Noder(ctx, id)")
	f.Comment("    c.Noder(ctx, id, WithNodeType(typeResolver))")
	f.Func().Params(
		jen.Id("c").Add(g.ormTypePtr("Client")),
	).Id("Noder").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("id").Add(idType),
		jen.Id("opts").Op("...").Id("NodeOption"),
	).Params(
		jen.Id("_").Id("Noder"),
		jen.Id("err").Error(),
	).Block(
		jen.Defer().Func().Params().Block(
			jen.If(jen.Id("IsNotFound").Call(jen.Id("err"))).Block(
				jen.Id("err").Op("=").Qual("errors", "Join").Call(
					jen.Id("err"),
					jen.Id("ErrNodeNotFound"),
				),
			),
		).Call(),
		jen.List(jen.Id("table"), jen.Id("err")).Op(":=").Id("c").Dot("newNodeOpts").Call(jen.Id("opts")).Dot("nodeType").Call(
			jen.Id("ctx"),
			jen.Id("id"),
		),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Id("err")),
		),
		jen.Return(jen.Id("c").Dot("noder").Call(jen.Id("ctx"), jen.Id("table"), jen.Id("id"))),
	)
	f.Line()
}

// genClientNoderInternal generates the internal c.noder method with switch on table.
func (g *Generator) genClientNoderInternal(f *jen.File) {
	idType := g.graphIDType()

	f.Func().Params(
		jen.Id("c").Add(g.ormTypePtr("Client")),
	).Id("noder").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("table").String(),
		jen.Id("id").Add(idType),
	).Params(
		jen.Id("Noder"),
		jen.Error(),
	).BlockFunc(func(group *jen.Group) {
		group.Switch(jen.Id("table")).BlockFunc(func(sw *jen.Group) {
			nodes := g.filterNodes(g.graph.Nodes, SkipType)
			for _, t := range nodes {
				typeName := t.Name
				entityPkg := g.config.ORMPackage + "/" + strings.ToLower(t.Name)

				sw.Case(jen.Qual(entityPkg, "Table")).BlockFunc(func(c *jen.Group) {
					// Use IDField.EQ() for generic predicates (default), ID() for Ent-compatible predicates
					var idPredicate jen.Code
					if g.useGenericPredicates() {
						idPredicate = jen.Qual(entityPkg, "IDField").Dot("EQ").Call(jen.Id("id"))
					} else {
						idPredicate = jen.Qual(entityPkg, "ID").Call(jen.Id("id"))
					}
					c.Id("query").Op(":=").Id("c").Dot(typeName).Dot("Query").Call().
						Dot("Where").Call(idPredicate)

					c.If(jen.Id("fc").Op(":=").Qual("github.com/99designs/gqlgen/graphql", "GetFieldContext").Call(jen.Id("ctx")).Op(";").Id("fc").Op("!=").Nil()).Block(
						jen.If(
							jen.Id("err").Op(":=").Id("query").Dot("collectField").Call(
								jen.Id("ctx"),
								jen.True(),
								jen.Qual("github.com/99designs/gqlgen/graphql", "GetOperationContext").Call(jen.Id("ctx")),
								jen.Id("fc").Dot("Field"),
								jen.Nil(),
								jen.Id(g.implementorsVarName(t)).Op("..."),
							).Op(";").Id("err").Op("!=").Nil(),
						).Block(
							jen.Return(jen.Nil(), jen.Id("err")),
						),
					)
					c.Return(jen.Id("query").Dot("Only").Call(jen.Id("ctx")))
				})
			}
			sw.Default().Block(
				jen.Return(
					jen.Nil(),
					jen.Qual("fmt", "Errorf").Call(
						jen.Lit("cannot resolve noder from table %q: %w"),
						jen.Id("table"),
						jen.Id("errNodeInvalidID"),
					),
				),
			)
		})
	})
	f.Line()
}

// genClientNoders generates the Client.Noders batch method.
// This follows Ent's pattern exactly - no maximum batch size limit is enforced.
func (g *Generator) genClientNoders(f *jen.File) {
	idType := g.graphIDType()

	f.Func().Params(
		jen.Id("c").Add(g.ormTypePtr("Client")),
	).Id("Noders").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("ids").Index().Add(idType),
		jen.Id("opts").Op("...").Id("NodeOption"),
	).Params(
		jen.Index().Id("Noder"),
		jen.Error(),
	).BlockFunc(func(group *jen.Group) {
		group.Switch(jen.Len(jen.Id("ids"))).Block(
			jen.Case(jen.Lit(1)).Block(
				jen.List(jen.Id("noder"), jen.Id("err")).Op(":=").Id("c").Dot("Noder").Call(
					jen.Id("ctx"),
					jen.Id("ids").Index(jen.Lit(0)),
					jen.Id("opts").Op("..."),
				),
				jen.If(jen.Id("err").Op("!=").Nil()).Block(
					jen.Return(jen.Nil(), jen.Id("err")),
				),
				jen.Return(jen.Index().Id("Noder").Values(jen.Id("noder")), jen.Nil()),
			),
			jen.Case(jen.Lit(0)).Block(
				jen.Return(jen.Index().Id("Noder").Values(), jen.Nil()),
			),
		)
		group.Line()

		group.Id("noders").Op(":=").Make(jen.Index().Id("Noder"), jen.Len(jen.Id("ids")))
		group.Id("errs").Op(":=").Make(jen.Index().Error(), jen.Len(jen.Id("ids")))
		group.Id("tables").Op(":=").Make(jen.Map(jen.String()).Index().Add(idType))
		group.Id("id2idx").Op(":=").Make(jen.Map(idType).Index().Int(), jen.Len(jen.Id("ids")))
		group.Id("nopts").Op(":=").Id("c").Dot("newNodeOpts").Call(jen.Id("opts"))
		group.For(jen.List(jen.Id("i"), jen.Id("id")).Op(":=").Range().Id("ids")).Block(
			jen.List(jen.Id("table"), jen.Id("err")).Op(":=").Id("nopts").Dot("nodeType").Call(
				jen.Id("ctx"),
				jen.Id("id"),
			),
			jen.If(jen.Id("err").Op("!=").Nil()).Block(
				jen.Id("errs").Index(jen.Id("i")).Op("=").Id("err"),
				jen.Continue(),
			),
			jen.Id("tables").Index(jen.Id("table")).Op("=").Append(
				jen.Id("tables").Index(jen.Id("table")),
				jen.Id("id"),
			),
			jen.Id("id2idx").Index(jen.Id("id")).Op("=").Append(
				jen.Id("id2idx").Index(jen.Id("id")),
				jen.Id("i"),
			),
		)
		group.Line()

		group.For(jen.List(jen.Id("table"), jen.Id("ids")).Op(":=").Range().Id("tables")).Block(
			jen.List(jen.Id("nodes"), jen.Id("err")).Op(":=").Id("c").Dot("noders").Call(
				jen.Id("ctx"),
				jen.Id("table"),
				jen.Id("ids"),
			),
			jen.If(jen.Id("err").Op("!=").Nil()).Block(
				jen.For(jen.List(jen.Id("_"), jen.Id("id")).Op(":=").Range().Id("ids")).Block(
					jen.For(jen.List(jen.Id("_"), jen.Id("idx")).Op(":=").Range().Id("id2idx").Index(jen.Id("id"))).Block(
						jen.Id("errs").Index(jen.Id("idx")).Op("=").Id("err"),
					),
				),
			).Else().Block(
				jen.For(jen.List(jen.Id("i"), jen.Id("id")).Op(":=").Range().Id("ids")).Block(
					jen.For(jen.List(jen.Id("_"), jen.Id("idx")).Op(":=").Range().Id("id2idx").Index(jen.Id("id"))).Block(
						jen.Id("noders").Index(jen.Id("idx")).Op("=").Id("nodes").Index(jen.Id("i")),
					),
				),
			),
		)
		group.Line()

		// Final error handling loop - doesn't need id variable
		group.For(jen.Id("i").Op(":=").Range().Id("ids")).Block(
			jen.If(jen.Id("errs").Index(jen.Id("i")).Op("==").Nil()).Block(
				jen.If(jen.Id("noders").Index(jen.Id("i")).Op("!=").Nil()).Block(
					jen.Continue(),
				),
				jen.Id("errs").Index(jen.Id("i")).Op("=").Id("ErrNodeNotFound"),
			).Else().If(jen.Id("IsNotFound").Call(jen.Id("errs").Index(jen.Id("i")))).Block(
				jen.Id("errs").Index(jen.Id("i")).Op("=").Qual("errors", "Join").Call(
					jen.Id("errs").Index(jen.Id("i")),
					jen.Id("ErrNodeNotFound"),
				),
			),
			jen.Id("ctx").Op(":=").Qual("github.com/99designs/gqlgen/graphql", "WithPathContext").Call(
				jen.Id("ctx"),
				jen.Qual("github.com/99designs/gqlgen/graphql", "NewPathWithIndex").Call(jen.Id("i")),
			),
			jen.Qual("github.com/99designs/gqlgen/graphql", "AddError").Call(
				jen.Id("ctx"),
				jen.Id("errs").Index(jen.Id("i")),
			),
		)
		group.Return(jen.Id("noders"), jen.Nil())
	})
	f.Line()
}

// genClientNodersInternal generates the internal c.noders batch method with switch on table.
func (g *Generator) genClientNodersInternal(f *jen.File) {
	idType := g.graphIDType()

	f.Func().Params(
		jen.Id("c").Add(g.ormTypePtr("Client")),
	).Id("noders").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("table").String(),
		jen.Id("ids").Index().Add(idType),
	).Params(
		jen.Index().Id("Noder"),
		jen.Error(),
	).BlockFunc(func(group *jen.Group) {
		group.Id("noders").Op(":=").Make(jen.Index().Id("Noder"), jen.Len(jen.Id("ids")))
		group.Id("idmap").Op(":=").Make(
			jen.Map(idType).Index().Op("*").Id("Noder"),
			jen.Len(jen.Id("ids")),
		)
		group.For(jen.List(jen.Id("i"), jen.Id("id")).Op(":=").Range().Id("ids")).Block(
			jen.Id("idmap").Index(jen.Id("id")).Op("=").Append(
				jen.Id("idmap").Index(jen.Id("id")),
				jen.Op("&").Id("noders").Index(jen.Id("i")),
			),
		)
		group.Switch(jen.Id("table")).BlockFunc(func(sw *jen.Group) {
			nodes := g.filterNodes(g.graph.Nodes, SkipType)
			for _, t := range nodes {
				typeName := t.Name
				entityPkg := g.config.ORMPackage + "/" + strings.ToLower(t.Name)

				sw.Case(jen.Qual(entityPkg, "Table")).BlockFunc(func(c *jen.Group) {
					// Use IDField.In() for generic predicates (default), IDIn() for Ent-compatible predicates
					var idInPredicate jen.Code
					if g.useGenericPredicates() {
						idInPredicate = jen.Qual(entityPkg, "IDField").Dot("In").Call(jen.Id("ids").Op("..."))
					} else {
						idInPredicate = jen.Qual(entityPkg, "IDIn").Call(jen.Id("ids").Op("..."))
					}
					c.Id("query").Op(":=").Id("c").Dot(typeName).Dot("Query").Call().
						Dot("Where").Call(idInPredicate)
					c.List(jen.Id("query"), jen.Id("err")).Op(":=").Id("query").Dot("CollectFields").Call(
						jen.Id("ctx"),
						jen.Id(g.implementorsVarName(t)).Op("..."),
					)
					c.If(jen.Id("err").Op("!=").Nil()).Block(
						jen.Return(jen.Nil(), jen.Id("err")),
					)
					c.List(jen.Id("nodes"), jen.Id("err")).Op(":=").Id("query").Dot("All").Call(jen.Id("ctx"))
					c.If(jen.Id("err").Op("!=").Nil()).Block(
						jen.Return(jen.Nil(), jen.Id("err")),
					)
					c.For(jen.List(jen.Id("_"), jen.Id("node")).Op(":=").Range().Id("nodes")).Block(
						jen.For(jen.List(jen.Id("_"), jen.Id("noder")).Op(":=").Range().Id("idmap").Index(
							jen.Id("node").Dot("ID"),
						)).Block(
							jen.Op("*").Id("noder").Op("=").Id("node"),
						),
					)
				})
			}
			sw.Default().Block(
				jen.Return(
					jen.Nil(),
					jen.Qual("fmt", "Errorf").Call(
						jen.Lit("cannot resolve noders from table %q: %w"),
						jen.Id("table"),
						jen.Id("errNodeInvalidID"),
					),
				),
			)
		})
		group.Return(jen.Id("noders"), jen.Nil())
	})
	f.Line()
}

// genTablesStruct generates the tables struct for universal-id support like Ent.
func (g *Generator) genTablesStruct(f *jen.File) {
	idType := g.graphIDType()

	// tables struct
	f.Type().Id("tables").Struct(
		jen.Id("once").Qual("sync", "Once"),
		jen.Id("sem").Op("*").Qual("golang.org/x/sync/semaphore", "Weighted"),
		jen.Id("value").Qual("sync/atomic", "Value"),
	)
	f.Line()

	// nodeType method
	// Note: For UUID or string IDs, the universal-id scheme (bit-shifting) doesn't work.
	// These ID types require explicit type information or global IDs.
	f.Func().Params(
		jen.Id("t").Op("*").Id("tables"),
	).Id("nodeType").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("drv").Qual("github.com/syssam/velox/dialect", "Driver"),
		jen.Id("id").Add(idType),
	).Params(jen.String(), jen.Error()).BlockFunc(func(block *jen.Group) {
		// Check if using UUID or string IDs (can't use bit-shifting universal-id scheme)
		usesNonIntegerID := g.graph.IDType != nil &&
			(g.graph.IDType.Type == field.TypeUUID || g.graph.IDType.Type == field.TypeString)

		if usesNonIntegerID {
			// For non-integer IDs, we can't determine type from the ID alone.
			// The caller must provide the type explicitly via NodeOption.
			idTypeName := "UUID"
			if g.graph.IDType.Type == field.TypeString {
				idTypeName = "string"
			}
			block.Return(
				jen.Lit(""),
				jen.Qual("fmt", "Errorf").Call(
					jen.Lit("cannot determine node type from "+idTypeName+" id %v: use NodeOption with explicit type"),
					jen.Id("id"),
				),
			)
		} else {
			// For integer IDs, use the universal-id scheme
			block.List(jen.Id("tables"), jen.Id("err")).Op(":=").Id("t").Dot("Load").Call(jen.Id("ctx"), jen.Id("drv"))
			block.If(jen.Id("err").Op("!=").Nil()).Block(
				jen.Return(jen.Lit(""), jen.Id("err")),
			)
			// Universal-id scheme: extract table index from high bits using tableIndexBitOffset constant
			block.Id("idx").Op(":=").Int().Call(jen.Id("id").Op(">>").Id("tableIndexBitOffset"))
			block.If(jen.Id("idx").Op("<").Lit(0).Op("||").Id("idx").Op(">=").Len(jen.Id("tables"))).Block(
				jen.Return(jen.Lit(""), jen.Qual("fmt", "Errorf").Call(
					jen.Lit("cannot resolve table from id %v: %w"),
					jen.Id("id"),
					jen.Id("errNodeInvalidID"),
				)),
			)
			block.Return(jen.Id("tables").Index(jen.Id("idx")), jen.Nil())
		}
	})
	f.Line()

	// Load method
	f.Func().Params(
		jen.Id("t").Op("*").Id("tables"),
	).Id("Load").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("drv").Qual("github.com/syssam/velox/dialect", "Driver"),
	).Params(jen.Index().String(), jen.Error()).Block(
		jen.If(jen.Id("tables").Op(":=").Id("t").Dot("value").Dot("Load").Call().Op(";").Id("tables").Op("!=").Nil()).Block(
			jen.Return(jen.Id("tables").Op(".").Parens(jen.Index().String()), jen.Nil()),
		),
		jen.Id("t").Dot("once").Dot("Do").Call(jen.Func().Params().Block(
			jen.Id("t").Dot("sem").Op("=").Qual("golang.org/x/sync/semaphore", "NewWeighted").Call(jen.Lit(1)),
		)),
		jen.If(jen.Id("err").Op(":=").Id("t").Dot("sem").Dot("Acquire").Call(jen.Id("ctx"), jen.Lit(1)).Op(";").Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Id("err")),
		),
		jen.Defer().Id("t").Dot("sem").Dot("Release").Call(jen.Lit(1)),
		jen.If(jen.Id("tables").Op(":=").Id("t").Dot("value").Dot("Load").Call().Op(";").Id("tables").Op("!=").Nil()).Block(
			jen.Return(jen.Id("tables").Op(".").Parens(jen.Index().String()), jen.Nil()),
		),
		jen.List(jen.Id("tables"), jen.Id("err")).Op(":=").Id("t").Dot("load").Call(jen.Id("ctx"), jen.Id("drv")),
		jen.If(jen.Id("err").Op("==").Nil()).Block(
			jen.Id("t").Dot("value").Dot("Store").Call(jen.Id("tables")),
		),
		jen.Return(jen.Id("tables"), jen.Id("err")),
	)
	f.Line()

	// load method
	f.Func().Params(
		jen.Op("*").Id("tables"),
	).Id("load").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("drv").Qual("github.com/syssam/velox/dialect", "Driver"),
	).Params(jen.Index().String(), jen.Error()).Block(
		jen.Id("rows").Op(":=").Op("&").Qual("github.com/syssam/velox/dialect/sql", "Rows").Values(),
		jen.List(jen.Id("query"), jen.Id("args")).Op(":=").Qual("github.com/syssam/velox/dialect/sql", "Dialect").Call(
			jen.Id("drv").Dot("Dialect").Call(),
		).Dot("Select").Call(jen.Lit("type")).
			Dot("From").Call(jen.Qual("github.com/syssam/velox/dialect/sql", "Table").Call(
			jen.Qual("github.com/syssam/velox/dialect/sql/schema", "TypeTable"),
		)).Dot("OrderBy").Call(
			jen.Qual("github.com/syssam/velox/dialect/sql", "Asc").Call(jen.Lit("id")),
		).Dot("Query").Call(),
		jen.If(jen.Id("err").Op(":=").Id("drv").Dot("Query").Call(
			jen.Id("ctx"),
			jen.Id("query"),
			jen.Id("args"),
			jen.Id("rows"),
		).Op(";").Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Id("err")),
		),
		jen.Defer().Id("rows").Dot("Close").Call(),
		jen.Var().Id("tables").Index().String(),
		jen.Return(jen.Id("tables"), jen.Qual("github.com/syssam/velox/dialect/sql", "ScanSlice").Call(
			jen.Id("rows"),
			jen.Op("&").Id("tables"),
		)),
	)
	f.Line()
}

// genNodeDescriptor generates the Node descriptor types and methods for schema introspection.
// This follows Ent's node_descriptor.tmpl pattern:
//   - NodeDescriptor struct: ID, Type, Fields, Edges
//   - FieldDescriptor struct: Name, Type, Value
//   - EdgeDescriptor struct: Name, Type, IDs
//   - Node() method on each entity returning *NodeDescriptor
func (g *Generator) genNodeDescriptor(f *jen.File) {
	// NodeDescriptor struct - provides schema introspection for admin tools
	f.Comment("NodeDescriptor represents a node with its type and introspection data.")
	f.Comment("This enables admin tools to browse and inspect schema at runtime.")
	f.Type().Id("NodeDescriptor").Struct(
		jen.Id("ID").Any().Tag(map[string]string{"json": "id"}),
		jen.Id("Type").String().Tag(map[string]string{"json": "type"}),
		jen.Id("Fields").Index().Op("*").Id("FieldDescriptor").Tag(map[string]string{"json": "fields,omitempty"}),
		jen.Id("Edges").Index().Op("*").Id("EdgeDescriptor").Tag(map[string]string{"json": "edges,omitempty"}),
	)
	f.Line()

	// FieldDescriptor struct
	f.Comment("FieldDescriptor describes a field in a node for introspection.")
	f.Type().Id("FieldDescriptor").Struct(
		jen.Id("Name").String().Tag(map[string]string{"json": "name"}),
		jen.Id("Type").String().Tag(map[string]string{"json": "type"}),
		jen.Id("Value").Any().Tag(map[string]string{"json": "value,omitempty"}),
	)
	f.Line()

	// EdgeDescriptor struct
	f.Comment("EdgeDescriptor describes an edge in a node for introspection.")
	f.Type().Id("EdgeDescriptor").Struct(
		jen.Id("Name").String().Tag(map[string]string{"json": "name"}),
		jen.Id("Type").String().Tag(map[string]string{"json": "type"}),
		jen.Id("IDs").Index().Any().Tag(map[string]string{"json": "ids,omitempty"}),
	)
	f.Line()

	// Generate Node() method for each entity
	nodes := g.filterNodes(g.graph.Nodes, SkipType)
	for _, t := range nodes {
		g.genEntityNodeMethod(f, t)
	}
}

// genEntityNodeMethod generates the Node() method on an entity for schema introspection.
func (g *Generator) genEntityNodeMethod(f *jen.File, t *gen.Type) {
	f.Commentf("Node returns a NodeDescriptor for %s for schema introspection.", t.Name)
	f.Func().Params(
		jen.Id("_e").Add(g.ormTypePtr(t.Name)),
	).Id("Node").Params(
		jen.Id("ctx").Qual("context", "Context"),
	).Params(
		jen.Op("*").Id("NodeDescriptor"),
		jen.Error(),
	).BlockFunc(func(group *jen.Group) {
		// Build node descriptor
		group.Id("node").Op(":=").Op("&").Id("NodeDescriptor").Values(jen.Dict{
			jen.Id("ID"):   jen.Id("_e").Dot("ID"),
			jen.Id("Type"): jen.Lit(t.Name),
		})

		// Add fields
		group.Id("node").Dot("Fields").Op("=").Index().Op("*").Id("FieldDescriptor").ValuesFunc(func(fields *jen.Group) {
			// Get fields excluding edge fields
			for _, fld := range t.Fields {
				if fld.IsEdgeField() {
					continue
				}
				fields.Values(jen.Dict{
					jen.Id("Name"):  jen.Lit(fld.Name),
					jen.Id("Type"):  jen.Lit(g.fieldTypeString(fld)),
					jen.Id("Value"): jen.Id("_e").Dot(fld.StructField()),
				})
			}
		})

		// Add edges - only include loaded edges
		group.Id("node").Dot("Edges").Op("=").Index().Op("*").Id("EdgeDescriptor").ValuesFunc(func(edges *jen.Group) {
			for _, e := range t.Edges {
				edges.Values(jen.Dict{
					jen.Id("Name"): jen.Lit(e.Name),
					jen.Id("Type"): jen.Lit(e.Type.Name),
				})
			}
		})

		// Update edge IDs from loaded edges
		for i, e := range t.Edges {
			edgeStructField := e.StructField()
			if e.Unique {
				// Unique edge - single ID
				group.If(jen.Id("_e").Dot("Edges").Dot("loaded" + edgeStructField)).Block(
					jen.If(jen.Id("_e").Dot("Edges").Dot(edgeStructField).Op("!=").Nil()).Block(
						jen.Id("node").Dot("Edges").Index(jen.Lit(i)).Dot("IDs").Op("=").
							Append(jen.Id("node").Dot("Edges").Index(jen.Lit(i)).Dot("IDs"),
								jen.Id("_e").Dot("Edges").Dot(edgeStructField).Dot("ID")),
					),
				)
			} else {
				// Non-unique edge - multiple IDs
				group.If(jen.Id("_e").Dot("Edges").Dot("loaded" + edgeStructField)).Block(
					jen.For(jen.List(jen.Id("_"), jen.Id("edge")).Op(":=").Range().Id("_e").Dot("Edges").Dot(edgeStructField)).Block(
						// Skip nil edge elements (shouldn't happen but adds safety)
						jen.If(jen.Id("edge").Op("==").Nil()).Block(
							jen.Continue(),
						),
						jen.Id("node").Dot("Edges").Index(jen.Lit(i)).Dot("IDs").Op("=").
							Append(jen.Id("node").Dot("Edges").Index(jen.Lit(i)).Dot("IDs"),
								jen.Id("edge").Dot("ID")),
					),
				)
			}
		}

		group.Return(jen.Id("node"), jen.Nil())
	})
	f.Line()
}

// fieldTypeString returns a string representation of a field's type for introspection.
func (g *Generator) fieldTypeString(f *gen.Field) string {
	if f.Type == nil {
		return "unknown"
	}
	if f.IsEnum() {
		return "enum"
	}
	if f.IsJSON() {
		return "json"
	}
	if f.IsTime() {
		return "time.Time"
	}
	if f.IsUUID() {
		return "uuid.UUID"
	}
	switch f.Type.Type {
	case field.TypeString:
		return "string"
	case field.TypeInt, field.TypeInt8, field.TypeInt16, field.TypeInt32, field.TypeInt64:
		return "int"
	case field.TypeUint, field.TypeUint8, field.TypeUint16, field.TypeUint32, field.TypeUint64:
		return "uint"
	case field.TypeFloat32, field.TypeFloat64:
		return "float"
	case field.TypeBool:
		return "bool"
	case field.TypeBytes:
		return "[]byte"
	default:
		return f.Type.String()
	}
}

// implementorsVarName returns the variable name for the implementors slice.
func (g *Generator) implementorsVarName(t *gen.Type) string {
	return strings.ToLower(t.Name[:1]) + t.Name[1:] + "Implementors"
}

// getNodeImplementors returns the list of interfaces a type implements.
func (g *Generator) getNodeImplementors(t *gen.Type) []string {
	implementors := []string{"Node"}

	// Check for additional interfaces from annotations
	ann := g.getTypeAnnotation(t)
	if additionalInterfaces := ann.GetImplements(); len(additionalInterfaces) > 0 {
		implementors = append(implementors, additionalInterfaces...)
	}

	return implementors
}
