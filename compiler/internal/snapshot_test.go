package internal

import (
	"errors"
	"io"
	"os"
	"path/filepath"
	"testing"

	"github.com/syssam/velox"
	"github.com/syssam/velox/compiler/gen"
	"github.com/syssam/velox/compiler/load"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSnapshot_Restore(t *testing.T) {
	t.Log("Running snapshot-restore integration test")

	// Create a temporary directory for the test to avoid corrupting the real integration test files
	tempDir := t.TempDir()

	// Copy the schema directory to temp
	srcSchema := "../integration/privacy/velox/schema"
	dstSchema := filepath.Join(tempDir, "schema")
	require.NoError(t, copyDir(srcSchema, dstSchema))

	// Create internal directory with snapshot
	internalDir := filepath.Join(tempDir, "internal")
	require.NoError(t, os.MkdirAll(internalDir, 0o755))

	// Create a valid snapshot file
	snapshotContent := `// Code generated by velox, DO NOT EDIT.

package internal

const Schema = "{\"schema\":\"./schema\",\"package\":\"github.com/syssam/velox/compiler/integration/privacy/velox\",\"schemas\":[{\"name\":\"User\",\"fields\":[{\"name\":\"name\",\"type\":{\"Type\":7}},{\"name\":\"email\",\"type\":{\"Type\":7},\"unique\":true}]}],\"features\":[]}"
`
	snapshotPath := filepath.Join(internalDir, "schema.go")
	require.NoError(t, os.WriteFile(snapshotPath, []byte(snapshotContent), 0o644))

	// Add conflict markers to the snapshot file to test conflict resolution
	f, err := os.OpenFile(snapshotPath, os.O_WRONLY|os.O_APPEND, 0o644)
	require.NoError(t, err)
	_, err = f.WriteString("\n" + conflictMarker)
	require.NoError(t, err)
	require.NoError(t, f.Close())

	// Test snapshot restore
	storage, err := gen.NewStorage("sql")
	require.NoError(t, err)

	snap := &Snapshot{
		Path: snapshotPath,
		Config: &gen.Config{
			Storage: storage,
			Target:  tempDir,
			Schema:  dstSchema,
			Package: "github.com/syssam/velox/compiler/integration/privacy/velox",
			Header:  "// Code generated by velox, DO NOT EDIT.\n",
		},
	}

	// Restore should succeed even with conflict markers
	require.NoError(t, snap.Restore())
}

// copyDir recursively copies a directory.
func copyDir(src, dst string) error {
	return filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		relPath, err := filepath.Rel(src, path)
		if err != nil {
			return err
		}
		dstPath := filepath.Join(dst, relPath)

		if info.IsDir() {
			return os.MkdirAll(dstPath, info.Mode())
		}

		return copyFile(path, dstPath)
	})
}

// copyFile copies a single file.
func copyFile(src, dst string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	_, err = io.Copy(dstFile, srcFile)
	return err
}

// TestMerge tests the merge function.
func TestMerge(t *testing.T) {
	// Test merging empty local with populated other
	local := &gen.Snapshot{
		Schema:   "",
		Package:  "",
		Schemas:  []*load.Schema{},
		Features: []string{},
	}
	other := &gen.Snapshot{
		Schema:  "./schema",
		Package: "github.com/example/ent",
		Schemas: []*load.Schema{
			{Name: "User", Fields: []*load.Field{{Name: "name"}}},
		},
		Features: []string{"entql", "privacy"},
	}

	merge(local, other)

	assert.Equal(t, "./schema", local.Schema)
	assert.Equal(t, "github.com/example/ent", local.Package)
	require.Len(t, local.Schemas, 1)
	assert.Equal(t, "User", local.Schemas[0].Name)
	require.Len(t, local.Features, 2)

	// Test merging with existing local values
	local = &gen.Snapshot{
		Schema:  "./local-schema",
		Package: "github.com/local/ent",
		Schemas: []*load.Schema{
			{Name: "User", Fields: []*load.Field{{Name: "email"}}},
		},
		Features: []string{"entql"},
	}
	other = &gen.Snapshot{
		Schema:  "./other-schema",
		Package: "github.com/other/ent",
		Schemas: []*load.Schema{
			{Name: "User", Fields: []*load.Field{{Name: "name"}}},
			{Name: "Post", Fields: []*load.Field{{Name: "title"}}},
		},
		Features: []string{"privacy"},
	}

	merge(local, other)

	// Local values should be preserved
	assert.Equal(t, "./local-schema", local.Schema)
	assert.Equal(t, "github.com/local/ent", local.Package)
	// Should have both schemas now
	require.Len(t, local.Schemas, 2)
	// Features should be merged
	require.Len(t, local.Features, 2)
	assert.Contains(t, local.Features, "entql")
	assert.Contains(t, local.Features, "privacy")
}

// TestMergeSchema tests the mergeSchema function.
func TestMergeSchema(t *testing.T) {
	// Test merging with empty local
	local := &load.Schema{
		Name: "User",
		Config: velox.Config{
			Table: "",
		},
		Fields: []*load.Field{},
		Edges:  []*load.Edge{},
	}
	other := &load.Schema{
		Name: "User",
		Config: velox.Config{
			Table: "users",
		},
		Annotations: map[string]any{"graphql": true},
		Fields:      []*load.Field{{Name: "name"}},
		Edges:       []*load.Edge{{Name: "posts"}},
	}

	mergeSchema(local, other)

	assert.Equal(t, "users", local.Config.Table)
	require.NotNil(t, local.Annotations)
	assert.Equal(t, true, local.Annotations["graphql"])
	require.Len(t, local.Fields, 1)
	require.Len(t, local.Edges, 1)

	// Test merging with existing local values
	local = &load.Schema{
		Name: "User",
		Config: velox.Config{
			Table: "my_users",
		},
		Annotations: map[string]any{"sql": "custom"},
		Fields:      []*load.Field{{Name: "email"}},
		Edges:       []*load.Edge{{Name: "comments"}},
	}
	other = &load.Schema{
		Name: "User",
		Config: velox.Config{
			Table: "users",
		},
		Annotations: map[string]any{"graphql": true, "sql": "other"},
		Fields:      []*load.Field{{Name: "email"}, {Name: "name"}},
		Edges:       []*load.Edge{{Name: "comments"}, {Name: "posts"}},
	}

	mergeSchema(local, other)

	// Local table should be preserved
	assert.Equal(t, "my_users", local.Config.Table)
	// Local annotation should be preserved, other annotation added
	assert.Equal(t, "custom", local.Annotations["sql"])
	assert.Equal(t, true, local.Annotations["graphql"])
	// Should have both fields and edges
	require.Len(t, local.Fields, 2)
	require.Len(t, local.Edges, 2)
}

// TestMergeField tests the mergeField function.
func TestMergeField(t *testing.T) {
	// Test merging with nil local annotations
	local := &load.Field{
		Name:      "email",
		Immutable: false,
	}
	other := &load.Field{
		Name:        "email",
		Annotations: map[string]any{"graphql": "skip"},
		Immutable:   true,
	}

	mergeField(local, other)

	require.NotNil(t, local.Annotations)
	assert.Equal(t, "skip", local.Annotations["graphql"])
	assert.True(t, local.Immutable)

	// Test merging with existing local values
	local = &load.Field{
		Name:        "email",
		Annotations: map[string]any{"sql": "varchar(255)"},
		Immutable:   true, // Already immutable
	}
	other = &load.Field{
		Name:        "email",
		Annotations: map[string]any{"graphql": "skip", "sql": "text"},
		Immutable:   false,
	}

	mergeField(local, other)

	// Local annotation preserved, other added
	assert.Equal(t, "varchar(255)", local.Annotations["sql"])
	assert.Equal(t, "skip", local.Annotations["graphql"])
	// Already immutable, should remain true
	assert.True(t, local.Immutable)
}

// TestMergeEdge tests the mergeEdge function.
func TestMergeEdge(t *testing.T) {
	// Test merging with nil local annotations
	local := &load.Edge{
		Name: "posts",
	}
	other := &load.Edge{
		Name:        "posts",
		Annotations: map[string]any{"graphql": "connection"},
	}

	mergeEdge(local, other)

	require.NotNil(t, local.Annotations)
	assert.Equal(t, "connection", local.Annotations["graphql"])

	// Test merging with existing local annotations
	local = &load.Edge{
		Name:        "comments",
		Annotations: map[string]any{"sql": "cascade"},
	}
	other = &load.Edge{
		Name:        "comments",
		Annotations: map[string]any{"graphql": "skip", "sql": "restrict"},
	}

	mergeEdge(local, other)

	// Local annotation preserved, other added
	assert.Equal(t, "cascade", local.Annotations["sql"])
	assert.Equal(t, "skip", local.Annotations["graphql"])
}

// TestIsBuildError tests the IsBuildError function.
func TestIsBuildError(t *testing.T) {
	tests := []struct {
		name     string
		err      error
		expected bool
	}{
		{
			name:     "entc/load prefix",
			err:      errors.New("entc/load: # some error"),
			expected: true,
		},
		{
			name:     "syntax error",
			err:      errors.New("file.go:10:5: syntax error: unexpected token"),
			expected: true,
		},
		{
			name:     "previous declaration",
			err:      errors.New("previous declaration at file.go:5"),
			expected: true,
		},
		{
			name:     "invalid character",
			err:      errors.New("invalid character 'x' in literal"),
			expected: true,
		},
		{
			name:     "could not import",
			err:      errors.New("could not import github.com/some/package"),
			expected: true,
		},
		{
			name:     "merge conflict marker",
			err:      errors.New("found '<<' in source"),
			expected: true,
		},
		{
			name:     "regular error",
			err:      errors.New("some other error"),
			expected: false,
		},
		{
			name:     "validation error",
			err:      errors.New("field 'name' is required"),
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := IsBuildError(tt.err)
			assert.Equal(t, tt.expected, result)
		})
	}
}

// TestTrim tests the trim function.
func TestTrim(t *testing.T) {
	// Test valid line
	line := []byte(`const Schema = "{\"key\":\"value\"}"`)
	result, err := trim(line)
	require.NoError(t, err)
	assert.Equal(t, `{"key":"value"}`, string(result))

	// Test line without quotes
	line = []byte(`const Schema = no quotes here`)
	_, err = trim(line)
	assert.Error(t, err)

	// Test line with only one quote
	line = []byte(`const Schema = "no closing`)
	_, err = trim(line)
	assert.Error(t, err)
}

// TestParseSnapshotErrors tests error cases in parseSnapshot.
func TestParseSnapshotErrors(t *testing.T) {
	// Test empty file
	snap := &Snapshot{Path: "test.go"}
	_, err := snap.parseSnapshot([]byte(""))
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "schema snapshot was not found")

	// Test multiple schemas without conflict
	content := `const Schema = "{}"
const Schema = "{}"`
	_, err = snap.parseSnapshot([]byte(content))
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "expect to have exactly 1 snapshot")
}
