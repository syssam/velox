// Package sql provides SQL dialect code generation.
package sql

import (
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/syssam/velox/compiler/gen"
	"github.com/syssam/velox/dialect/sql/schema"
	"github.com/syssam/velox/schema/field"
)

// genMigrate generates the migrate package with schema definitions and migration support.
// This creates two files:
//   - migrate/schema.go: Table and column definitions
//   - migrate/migrate.go: Schema type with Create() method
func genMigrate(h gen.GeneratorHelper) []*jen.File {
	return []*jen.File{
		genMigrateSchema(h),
		genMigrateMigrate(h),
	}
}

// genMigrateSchema generates migrate/schema.go with table definitions.
func genMigrateSchema(h gen.GeneratorHelper) *jen.File {
	f := h.NewFile("migrate")
	f.HeaderComment("Code generated by velox. DO NOT EDIT.")

	// Imports
	schemaPkg := "github.com/syssam/velox/dialect/sql/schema"
	fieldPkg := "github.com/syssam/velox/schema/field"
	f.ImportName(schemaPkg, "schema")
	f.ImportName(fieldPkg, "field")

	graph := h.Graph()

	// Generate column and table definitions for each entity
	for _, t := range graph.Nodes {
		columnsVar := pascal(t.Name) + "Columns"
		tableVar := pascal(t.Name) + "Table"

		// Generate columns slice
		f.Comment("// " + columnsVar + " holds the columns for the \"" + t.Table() + "\" table.")
		f.Var().Id(columnsVar).Op("=").Index().Op("*").Qual(schemaPkg, "Column").ValuesFunc(func(g *jen.Group) {
			// ID/Primary key column
			if t.ID != nil {
				pk := t.ID.PK()
				g.Op("&").Qual(schemaPkg, "Column").Values(genColumnDict(pk, fieldPkg))
			}

			// Other columns
			for _, fld := range t.Fields {
				col := fld.Column()
				g.Op("&").Qual(schemaPkg, "Column").Values(genColumnDict(col, fieldPkg))
			}

			// Edge FK columns (M2O and O2O edges that own the FK)
			for _, e := range t.Edges {
				if fkCol := edgeFKColumn(e, t); fkCol != nil {
					g.Op("&").Qual(schemaPkg, "Column").Values(genColumnDict(fkCol, fieldPkg))
				}
			}
		})
		f.Line()

		// Generate table definition
		f.Comment("// " + tableVar + " holds the schema information for the \"" + t.Table() + "\" table.")
		f.Var().Id(tableVar).Op("=").Op("&").Qual(schemaPkg, "Table").Values(jen.Dict{
			jen.Id("Name"):        jen.Lit(t.Table()),
			jen.Id("Columns"):     jen.Id(columnsVar),
			jen.Id("PrimaryKey"):  genPrimaryKey(t, columnsVar, schemaPkg),
			jen.Id("ForeignKeys"): genForeignKeysSchema(t, schemaPkg),
			jen.Id("Indexes"):     genIndexesSchema(t, schemaPkg),
		})
		f.Line()
	}

	// Generate Tables slice
	f.Comment("// Tables holds all the tables in the schema.")
	f.Var().Id("Tables").Op("=").Index().Op("*").Qual(schemaPkg, "Table").ValuesFunc(func(g *jen.Group) {
		for _, t := range graph.Nodes {
			g.Id(pascal(t.Name) + "Table")
		}
	})
	f.Line()

	// Generate init function to set foreign key references
	f.Func().Id("init").Params().BlockFunc(func(g *jen.Group) {
		for _, t := range graph.Nodes {
			tableVar := pascal(t.Name) + "Table"
			fkIdx := 0
			for _, e := range t.Edges {
				// Only M2O edges and O2O edges where this table owns the FK
				if e.Rel.Type != gen.M2O && (e.Rel.Type != gen.O2O || e.IsInverse()) {
					continue
				}
				if e.Type == nil {
					continue
				}
				// Check if this edge generates a FK (either via field association or implicit FK column)
				if e.Field() != nil || edgeFKColumn(e, t) != nil {
					refTableVar := pascal(e.Type.Name) + "Table"
					g.Id(tableVar).Dot("ForeignKeys").Index(jen.Lit(fkIdx)).Dot("RefTable").Op("=").Id(refTableVar)
					fkIdx++
				}
			}
		}
	})

	return f
}

// genMigrateMigrate generates migrate/migrate.go with the Schema type.
func genMigrateMigrate(h gen.GeneratorHelper) *jen.File {
	f := h.NewFile("migrate")
	f.HeaderComment("Code generated by velox. DO NOT EDIT.")

	// Imports
	dialectPkg := "github.com/syssam/velox/dialect"
	schemaPkg := "github.com/syssam/velox/dialect/sql/schema"
	f.ImportName("context", "context")
	f.ImportName("fmt", "fmt")
	f.ImportName("io", "io")
	f.ImportName(dialectPkg, "dialect")
	f.ImportName(schemaPkg, "schema")

	// Export schema options
	f.Var().DefsFunc(func(g *jen.Group) {
		g.Comment("// WithGlobalUniqueID sets the universal ids options to the migration.")
		g.Id("WithGlobalUniqueID").Op("=").Qual(schemaPkg, "WithGlobalUniqueID")
		g.Comment("// WithDropColumn sets the drop column option to the migration.")
		g.Id("WithDropColumn").Op("=").Qual(schemaPkg, "WithDropColumn")
		g.Comment("// WithDropIndex sets the drop index option to the migration.")
		g.Id("WithDropIndex").Op("=").Qual(schemaPkg, "WithDropIndex")
		g.Comment("// WithForeignKeys enables creating foreign-key in schema DDL.")
		g.Id("WithForeignKeys").Op("=").Qual(schemaPkg, "WithForeignKeys")
	})
	f.Line()

	// Schema struct
	f.Comment("// Schema is the API for creating, migrating and dropping a schema.")
	f.Type().Id("Schema").Struct(
		jen.Id("drv").Qual(dialectPkg, "Driver"),
	)
	f.Line()

	// NewSchema constructor
	f.Comment("// NewSchema creates a new schema client.")
	f.Func().Id("NewSchema").Params(
		jen.Id("drv").Qual(dialectPkg, "Driver"),
	).Op("*").Id("Schema").Block(
		jen.Return(jen.Op("&").Id("Schema").Values(jen.Dict{
			jen.Id("drv"): jen.Id("drv"),
		})),
	)
	f.Line()

	// Create method
	f.Comment("// Create creates all schema resources.")
	f.Func().Params(
		jen.Id("s").Op("*").Id("Schema"),
	).Id("Create").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("opts").Op("...").Qual(schemaPkg, "MigrateOption"),
	).Error().Block(
		jen.Return(jen.Id("Create").Call(
			jen.Id("ctx"),
			jen.Id("s"),
			jen.Id("Tables"),
			jen.Id("opts").Op("..."),
		)),
	)
	f.Line()

	// Package-level Create function
	f.Comment("// Create creates all table resources using the given schema driver.")
	f.Func().Id("Create").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("s").Op("*").Id("Schema"),
		jen.Id("tables").Index().Op("*").Qual(schemaPkg, "Table"),
		jen.Id("opts").Op("...").Qual(schemaPkg, "MigrateOption"),
	).Error().Block(
		jen.List(jen.Id("migrate"), jen.Id("err")).Op(":=").Qual(schemaPkg, "NewMigrate").Call(
			jen.Id("s").Dot("drv"),
			jen.Id("opts").Op("..."),
		),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("velox/migrate: %w"), jen.Id("err"))),
		),
		jen.Return(jen.Id("migrate").Dot("Create").Call(jen.Id("ctx"), jen.Id("tables").Op("..."))),
	)
	f.Line()

	// WriteTo method
	f.Comment("// WriteTo writes the schema changes to w instead of running them against the database.")
	f.Func().Params(
		jen.Id("s").Op("*").Id("Schema"),
	).Id("WriteTo").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("w").Qual("io", "Writer"),
		jen.Id("opts").Op("...").Qual(schemaPkg, "MigrateOption"),
	).Error().Block(
		jen.Return(jen.Id("Create").Call(
			jen.Id("ctx"),
			jen.Op("&").Id("Schema").Values(jen.Dict{
				jen.Id("drv"): jen.Op("&").Qual(schemaPkg, "WriteDriver").Values(jen.Dict{
					jen.Id("Writer"): jen.Id("w"),
					jen.Id("Driver"): jen.Id("s").Dot("drv"),
				}),
			}),
			jen.Id("Tables"),
			jen.Id("opts").Op("..."),
		)),
	)

	return f
}

// genColumnDict generates a jen.Dict for a schema.Column.
func genColumnDict(col *schema.Column, fieldPkg string) jen.Dict {
	dict := jen.Dict{
		jen.Id("Name"): jen.Lit(col.Name),
		jen.Id("Type"): fieldTypeCode(col.Type, fieldPkg),
	}
	if col.Unique {
		dict[jen.Id("Unique")] = jen.True()
	}
	if col.Increment {
		dict[jen.Id("Increment")] = jen.True()
	}
	if col.Nullable {
		dict[jen.Id("Nullable")] = jen.True()
	}
	if col.Size != 0 {
		dict[jen.Id("Size")] = jen.Lit(col.Size)
	}
	if len(col.Enums) > 0 {
		dict[jen.Id("Enums")] = jen.Index().String().ValuesFunc(func(g *jen.Group) {
			for _, e := range col.Enums {
				g.Lit(e)
			}
		})
	}
	if col.Default != nil {
		switch v := col.Default.(type) {
		case string:
			dict[jen.Id("Default")] = jen.Lit(v)
		case int, int64, float64, bool:
			dict[jen.Id("Default")] = jen.Lit(v)
		case schema.Expr:
			dict[jen.Id("Default")] = jen.Qual("github.com/syssam/velox/dialect/sql/schema", "Expr").Call(jen.Lit(string(v)))
		}
	}
	if col.Collation != "" {
		dict[jen.Id("Collation")] = jen.Lit(col.Collation)
	}
	if col.Comment != "" {
		dict[jen.Id("Comment")] = jen.Lit(col.Comment)
	}
	// Include SchemaType for TypeOther fields (like decimal) that need dialect-specific types
	if len(col.SchemaType) > 0 {
		dict[jen.Id("SchemaType")] = jen.Map(jen.String()).String().ValuesFunc(func(g *jen.Group) {
			for dialect, typ := range col.SchemaType {
				g.Lit(dialect).Op(":").Lit(typ)
			}
		})
	}
	return dict
}

// edgeFKColumn returns the FK column for an edge if it should be included in the table.
// Returns nil if the edge doesn't have a FK column on this table.
func edgeFKColumn(e *gen.Edge, t *gen.Type) *schema.Column {
	// Only M2O edges and O2O edges where this table owns the FK
	if e.Rel.Type != gen.M2O && (e.Rel.Type != gen.O2O || e.IsInverse()) {
		return nil
	}
	// If the edge has a field-edge (edge-field pattern), the column is already included
	if e.Field() != nil {
		return nil
	}
	// Get FK column name
	fkName := e.Rel.Column()
	if fkName == "" {
		return nil
	}
	// Create FK column
	col := &schema.Column{
		Name:     fkName,
		Nullable: e.Optional,
	}
	// Use the type of the referenced entity's ID
	if e.Type != nil && e.Type.ID != nil {
		col.Type = e.Type.ID.Type.Type
	} else {
		col.Type = field.TypeInt64 // Default
	}
	return col
}

// genPrimaryKey generates the PrimaryKey field for a table.
func genPrimaryKey(t *gen.Type, columnsVar string, schemaPkg string) jen.Code {
	return jen.Index().Op("*").Qual(schemaPkg, "Column").Values(
		jen.Id(columnsVar).Index(jen.Lit(0)), // First column is always ID
	)
}

// genForeignKeysSchema generates foreign key definitions for a type.
func genForeignKeysSchema(t *gen.Type, schemaPkg string) jen.Code {
	var fks []jen.Code
	columnsVar := pascal(t.Name) + "Columns"

	// Track which edge FK columns are added (for edges without field association)
	edgeFKIdx := 1 + len(t.Fields)

	for _, e := range t.Edges {
		// Only M2O edges and O2O edges where this table owns the FK
		if e.Rel.Type != gen.M2O && (e.Rel.Type != gen.O2O || e.IsInverse()) {
			continue
		}
		if e.Type == nil {
			continue
		}

		fkSymbol := t.Table() + "_" + strings.ToLower(e.Name) + "_fkey"
		refColumnsVar := pascal(e.Type.Name) + "Columns"

		var fkColIdx int
		// Check if edge has a field association
		if fld := e.Field(); fld != nil {
			// Find the field index
			fkColIdx = findColumnIndex(t, fld.StorageKey())
		} else if edgeFKColumn(e, t) != nil {
			// Edge has an implicit FK column added after fields
			fkColIdx = edgeFKIdx
			edgeFKIdx++
		} else {
			continue
		}

		// Determine OnDelete action based on annotation or edge optionality
		onDelete := deleteAction(e)

		fks = append(fks, jen.Values(jen.Dict{
			jen.Id("Symbol"): jen.Lit(fkSymbol),
			jen.Id("Columns"): jen.Index().Op("*").Qual(schemaPkg, "Column").Values(
				jen.Id(columnsVar).Index(jen.Lit(fkColIdx)),
			),
			jen.Id("RefColumns"): jen.Index().Op("*").Qual(schemaPkg, "Column").Values(
				jen.Id(refColumnsVar).Index(jen.Lit(0)), // Reference ID column
			),
			jen.Id("OnDelete"): onDelete,
		}))
	}

	if len(fks) == 0 {
		return jen.Nil()
	}
	return jen.Index().Op("*").Qual(schemaPkg, "ForeignKey").Values(fks...)
}

// genIndexesSchema generates index definitions for a type.
func genIndexesSchema(t *gen.Type, schemaPkg string) jen.Code {
	var indexes []jen.Code
	columnsVar := pascal(t.Name) + "Columns"

	for _, idx := range t.Indexes {
		idxDict := jen.Dict{
			jen.Id("Name"):   jen.Lit(idx.Name),
			jen.Id("Unique"): jen.Lit(idx.Unique),
		}

		// Find column indices
		var colRefs []jen.Code
		for _, col := range idx.Columns {
			colIndex := findColumnIndex(t, col)
			colRefs = append(colRefs, jen.Id(columnsVar).Index(jen.Lit(colIndex)))
		}
		idxDict[jen.Id("Columns")] = jen.Index().Op("*").Qual(schemaPkg, "Column").Values(colRefs...)

		indexes = append(indexes, jen.Values(idxDict))
	}

	if len(indexes) == 0 {
		return jen.Nil()
	}
	return jen.Index().Op("*").Qual(schemaPkg, "Index").Values(indexes...)
}

// findColumnIndex finds the index of a column in the type's column list.
func findColumnIndex(t *gen.Type, colName string) int {
	// ID is at index 0
	if t.ID != nil && t.ID.StorageKey() == colName {
		return 0
	}
	// Fields start at index 1
	for i, f := range t.Fields {
		if f.StorageKey() == colName {
			return i + 1
		}
	}
	return 0
}

// fieldTypeCode returns the Jennifer code for a field type constant.
func fieldTypeCode(ft field.Type, fieldPkg string) jen.Code {
	switch ft {
	case field.TypeBool:
		return jen.Qual(fieldPkg, "TypeBool")
	case field.TypeTime:
		return jen.Qual(fieldPkg, "TypeTime")
	case field.TypeJSON:
		return jen.Qual(fieldPkg, "TypeJSON")
	case field.TypeUUID:
		return jen.Qual(fieldPkg, "TypeUUID")
	case field.TypeBytes:
		return jen.Qual(fieldPkg, "TypeBytes")
	case field.TypeEnum:
		return jen.Qual(fieldPkg, "TypeEnum")
	case field.TypeString:
		return jen.Qual(fieldPkg, "TypeString")
	case field.TypeOther:
		return jen.Qual(fieldPkg, "TypeOther")
	case field.TypeInt:
		return jen.Qual(fieldPkg, "TypeInt")
	case field.TypeInt8:
		return jen.Qual(fieldPkg, "TypeInt8")
	case field.TypeInt16:
		return jen.Qual(fieldPkg, "TypeInt16")
	case field.TypeInt32:
		return jen.Qual(fieldPkg, "TypeInt32")
	case field.TypeInt64:
		return jen.Qual(fieldPkg, "TypeInt64")
	case field.TypeUint:
		return jen.Qual(fieldPkg, "TypeUint")
	case field.TypeUint8:
		return jen.Qual(fieldPkg, "TypeUint8")
	case field.TypeUint16:
		return jen.Qual(fieldPkg, "TypeUint16")
	case field.TypeUint32:
		return jen.Qual(fieldPkg, "TypeUint32")
	case field.TypeUint64:
		return jen.Qual(fieldPkg, "TypeUint64")
	case field.TypeFloat32:
		return jen.Qual(fieldPkg, "TypeFloat32")
	case field.TypeFloat64:
		return jen.Qual(fieldPkg, "TypeFloat64")
	default:
		return jen.Qual(fieldPkg, "TypeString")
	}
}

// pascal converts a string to PascalCase.
func pascal(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

// deleteAction returns the Jennifer code for the ON DELETE referential action.
// It checks the edge's sqlschema.OnDelete annotation first, then falls back to
// default behavior based on edge optionality (SetNull for optional, Cascade for required).
func deleteAction(e *gen.Edge) jen.Code {
	schemaPkg := "github.com/syssam/velox/dialect/sql/schema"

	// Check for explicit annotation
	if ant := e.EntSQL(); ant != nil && ant.OnDelete != "" {
		return jen.Qual(schemaPkg, string(ant.OnDelete))
	}

	// Default behavior based on edge optionality
	if e.Optional {
		return jen.Qual(schemaPkg, "SetNull")
	}
	return jen.Qual(schemaPkg, "Cascade")
}
