package sql

import (
	"testing"

	"github.com/dave/jennifer/jen"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/syssam/velox/compiler/gen"
	"github.com/syssam/velox/compiler/load"
	"github.com/syssam/velox/dialect/sql/schema"
	"github.com/syssam/velox/schema/field"
)

// =============================================================================
// genMigrate Tests
// =============================================================================

func TestGenMigrate_ReturnsTwoFiles(t *testing.T) {
	helper := newMockHelper()
	helper.graph.Nodes = []*gen.Type{createTestType("User")}

	var files []*jen.File
	ok := safeGenerate(func() {
		files = genMigrate(helper)
	})
	if !ok {
		t.Skip("genMigrate panicked due to incomplete mock state")
	}
	require.NotNil(t, files)
	assert.Len(t, files, 2)
	assert.NotNil(t, files[0])
	assert.NotNil(t, files[1])
}

// =============================================================================
// genMigrateSchema Tests
// =============================================================================

func TestGenMigrateSchema_BasicEntity(t *testing.T) {
	helper := newMockHelper()
	helper.graph.Nodes = []*gen.Type{createTestType("User")}

	var file *jen.File
	ok := safeGenerate(func() {
		file = genMigrateSchema(helper)
	})
	if !ok {
		t.Skip("genMigrateSchema panicked due to incomplete mock state")
	}
	require.NotNil(t, file)

	code := file.GoString()
	assert.Contains(t, code, "Code generated by velox. DO NOT EDIT.")
	assert.Contains(t, code, "package migrate")
	assert.Contains(t, code, "UserColumns")
	assert.Contains(t, code, "UserTable")
	assert.Contains(t, code, "func init()")
}

func TestGenMigrateSchema_MultipleEntities(t *testing.T) {
	helper := newMockHelper()
	helper.graph.Nodes = []*gen.Type{
		createTestType("User"),
		createTestType("Post"),
		createTestType("Comment"),
	}

	var file *jen.File
	ok := safeGenerate(func() {
		file = genMigrateSchema(helper)
	})
	if !ok {
		t.Skip("genMigrateSchema panicked due to incomplete mock state")
	}
	require.NotNil(t, file)

	code := file.GoString()
	assert.Contains(t, code, "UserColumns")
	assert.Contains(t, code, "PostColumns")
	assert.Contains(t, code, "CommentColumns")
	assert.Contains(t, code, "UserTable")
	assert.Contains(t, code, "PostTable")
	assert.Contains(t, code, "CommentTable")
}

func TestGenMigrateSchema_WithEdges(t *testing.T) {
	helper := newMockHelper()
	userType := createTestType("User")
	postType := createTestType("Post")

	postType.Edges = []*gen.Edge{{
		Name:   "author",
		Type:   userType,
		Unique: true,
		Rel:    gen.Relation{Type: gen.M2O},
	}}
	userType.Edges = []*gen.Edge{{
		Name:   "posts",
		Type:   postType,
		Unique: false,
		Rel:    gen.Relation{Type: gen.O2M},
	}}
	helper.graph.Nodes = []*gen.Type{userType, postType}

	var file *jen.File
	ok := safeGenerate(func() {
		file = genMigrateSchema(helper)
	})
	if !ok {
		t.Skip("genMigrateSchema panicked due to incomplete mock state")
	}
	require.NotNil(t, file)

	code := file.GoString()
	assert.Contains(t, code, "PostTable")
	assert.Contains(t, code, "ForeignKeys")
	assert.Contains(t, code, "func init()")
}

func TestGenMigrateSchema_WithM2OEdgeAndFK(t *testing.T) {
	helper := newMockHelper()
	userType := createTestType("User")
	postType := createTestType("Post")

	// M2O edge on post referencing user, with FK column
	m2oEdge := &gen.Edge{
		Name:   "author",
		Type:   userType,
		Unique: true,
		Rel: gen.Relation{
			Type:    gen.M2O,
			Table:   "posts",
			Columns: []string{"author_id"},
		},
	}
	postType.Edges = []*gen.Edge{m2oEdge}
	helper.graph.Nodes = []*gen.Type{userType, postType}

	var file *jen.File
	ok := safeGenerate(func() {
		file = genMigrateSchema(helper)
	})
	if !ok {
		t.Skip("genMigrateSchema panicked due to incomplete mock state")
	}
	require.NotNil(t, file)

	code := file.GoString()
	// Check that FK columns and init() references are generated
	assert.Contains(t, code, "PostColumns")
	assert.Contains(t, code, "PostTable")
	assert.Contains(t, code, "ForeignKeys")
	assert.Contains(t, code, "func init()")
	assert.Contains(t, code, "RefTable")
}

func TestGenMigrateSchema_WithO2OEdge(t *testing.T) {
	helper := newMockHelper()
	userType := createTestType("User")
	profileType := createTestType("Profile")

	// O2O edge on profile referencing user, profile owns FK
	o2oEdge := &gen.Edge{
		Name:   "owner",
		Type:   userType,
		Unique: true,
		Rel: gen.Relation{
			Type:    gen.O2O,
			Table:   "profiles",
			Columns: []string{"owner_id"},
		},
	}
	profileType.Edges = []*gen.Edge{o2oEdge}
	helper.graph.Nodes = []*gen.Type{userType, profileType}

	var file *jen.File
	ok := safeGenerate(func() {
		file = genMigrateSchema(helper)
	})
	if !ok {
		t.Skip("genMigrateSchema panicked due to incomplete mock state")
	}
	require.NotNil(t, file)

	code := file.GoString()
	assert.Contains(t, code, "ProfileColumns")
	assert.Contains(t, code, "ProfileTable")
}

func TestGenMigrateSchema_WithFields(t *testing.T) {
	helper := newMockHelper()
	userType := createTestTypeWithFields("User", []*gen.Field{
		createTestField("name", field.TypeString),
		createTestField("email", field.TypeString),
		createTestField("age", field.TypeInt),
		createNillableField("bio", field.TypeString),
	})
	helper.graph.Nodes = []*gen.Type{userType}

	var file *jen.File
	ok := safeGenerate(func() {
		file = genMigrateSchema(helper)
	})
	if !ok {
		t.Skip("genMigrateSchema panicked due to incomplete mock state")
	}
	require.NotNil(t, file)

	code := file.GoString()
	assert.Contains(t, code, "UserColumns")
	assert.Contains(t, code, "Tables")
}

func TestGenMigrateSchema_WithSchemaFields(t *testing.T) {
	// Use createTestTypeWithSchema to get proper field.typ set,
	// so Column() doesn't panic on field.sqlComment()
	helper := newMockHelper()
	userType := createTestTypeWithSchema("User", &load.Schema{
		Fields: []*load.Field{
			{Name: "name", Info: &field.TypeInfo{Type: field.TypeString}},
			{Name: "email", Info: &field.TypeInfo{Type: field.TypeString}},
			{Name: "age", Info: &field.TypeInfo{Type: field.TypeInt}},
		},
	})
	helper.graph.Nodes = []*gen.Type{userType}

	var file *jen.File
	ok := safeGenerate(func() {
		file = genMigrateSchema(helper)
	})
	if !ok {
		t.Skip("genMigrateSchema panicked due to incomplete mock state")
	}
	require.NotNil(t, file)

	code := file.GoString()
	assert.Contains(t, code, "UserColumns")
	assert.Contains(t, code, "UserTable")
	assert.Contains(t, code, "Tables")
}

func TestGenMigrateSchema_WithM2OEdgeAndFKInit(t *testing.T) {
	helper := newMockHelper()
	userType := createTestTypeWithSchema("User", &load.Schema{})
	postType := createTestTypeWithSchema("Post", &load.Schema{})

	// M2O edge with Rel.Columns set so edgeFKColumn returns non-nil
	// and the init() body generates FK ref table assignments
	m2oEdge := &gen.Edge{
		Name:   "author",
		Type:   userType,
		Unique: true,
		Rel: gen.Relation{
			Type:    gen.M2O,
			Table:   "posts",
			Columns: []string{"author_id"},
		},
	}
	postType.Edges = []*gen.Edge{m2oEdge}
	// Also add the O2M reverse edge on user
	o2mEdge := &gen.Edge{
		Name:   "posts",
		Type:   postType,
		Unique: false,
		Rel: gen.Relation{
			Type:    gen.O2M,
			Table:   "posts",
			Columns: []string{"author_id"},
		},
	}
	userType.Edges = []*gen.Edge{o2mEdge}
	helper.graph.Nodes = []*gen.Type{userType, postType}

	var file *jen.File
	ok := safeGenerate(func() {
		file = genMigrateSchema(helper)
	})
	if !ok {
		t.Skip("genMigrateSchema panicked due to incomplete mock state")
	}
	require.NotNil(t, file)

	code := file.GoString()
	// The init() should contain FK ref table assignment
	assert.Contains(t, code, "RefTable")
	assert.Contains(t, code, "PostTable")
	assert.Contains(t, code, "UserTable")
	assert.Contains(t, code, "ForeignKeys")
}

func TestGenMigrateSchema_MultipleM2OEdges(t *testing.T) {
	helper := newMockHelper()
	userType := createTestTypeWithSchema("User", &load.Schema{})
	categoryType := createTestTypeWithSchema("Category", &load.Schema{})
	postType := createTestTypeWithSchema("Post", &load.Schema{})

	// Post has two M2O edges: author (User) and category (Category)
	postType.Edges = []*gen.Edge{
		{
			Name:   "author",
			Type:   userType,
			Unique: true,
			Rel: gen.Relation{
				Type:    gen.M2O,
				Table:   "posts",
				Columns: []string{"author_id"},
			},
		},
		{
			Name:   "category",
			Type:   categoryType,
			Unique: true,
			Rel: gen.Relation{
				Type:    gen.M2O,
				Table:   "posts",
				Columns: []string{"category_id"},
			},
		},
	}
	helper.graph.Nodes = []*gen.Type{userType, categoryType, postType}

	var file *jen.File
	ok := safeGenerate(func() {
		file = genMigrateSchema(helper)
	})
	if !ok {
		t.Skip("genMigrateSchema panicked due to incomplete mock state")
	}
	require.NotNil(t, file)

	code := file.GoString()
	assert.Contains(t, code, "PostColumns")
	assert.Contains(t, code, "PostTable")
	assert.Contains(t, code, "RefTable")
}

func TestGenMigrateSchema_O2OEdgeNotInverseOwnFK(t *testing.T) {
	helper := newMockHelper()
	userType := createTestTypeWithSchema("User", &load.Schema{})
	profileType := createTestTypeWithSchema("Profile", &load.Schema{})

	// O2O edge where profile owns FK (not inverse)
	profileType.Edges = []*gen.Edge{
		{
			Name:   "owner",
			Type:   userType,
			Unique: true,
			Rel: gen.Relation{
				Type:    gen.O2O,
				Table:   "profiles",
				Columns: []string{"owner_id"},
			},
			// Not inverse (no Inverse field set) - this entity owns the FK
		},
	}
	helper.graph.Nodes = []*gen.Type{userType, profileType}

	var file *jen.File
	ok := safeGenerate(func() {
		file = genMigrateSchema(helper)
	})
	if !ok {
		t.Skip("genMigrateSchema panicked due to incomplete mock state")
	}
	require.NotNil(t, file)

	code := file.GoString()
	assert.Contains(t, code, "ProfileTable")
	assert.Contains(t, code, "ForeignKeys")
	assert.Contains(t, code, "RefTable")
}

func TestGenMigrateSchema_WithIndexes(t *testing.T) {
	helper := newMockHelper()
	userType := createTestType("User")
	userType.Indexes = []*gen.Index{
		{Name: "user_email_idx", Unique: true, Columns: []string{"email"}},
	}
	helper.graph.Nodes = []*gen.Type{userType}

	var file *jen.File
	ok := safeGenerate(func() {
		file = genMigrateSchema(helper)
	})
	if !ok {
		t.Skip("genMigrateSchema panicked due to incomplete mock state")
	}
	require.NotNil(t, file)

	code := file.GoString()
	assert.Contains(t, code, "Indexes")
}

// =============================================================================
// genMigrateMigrate Tests
// =============================================================================

func TestGenMigrateMigrate_BasicEntity(t *testing.T) {
	helper := newMockHelper()
	helper.graph.Nodes = []*gen.Type{createTestType("User")}

	file := genMigrateMigrate(helper)
	require.NotNil(t, file)

	code := file.GoString()
	assert.Contains(t, code, "Code generated by velox. DO NOT EDIT.")
	assert.Contains(t, code, "package migrate")
	assert.Contains(t, code, "type Schema struct")
	assert.Contains(t, code, "drv dialect.Driver")
	assert.Contains(t, code, "func NewSchema(")
	assert.Contains(t, code, "return &Schema{")
	assert.Contains(t, code, "func (s *Schema) Create(")
	assert.Contains(t, code, "ctx context.Context")
	assert.Contains(t, code, "opts ...schema.MigrateOption")
	assert.Contains(t, code, "return Create(ctx, s, Tables, opts...)")
	assert.Contains(t, code, "func Create(")
	assert.Contains(t, code, "tables []*schema.Table")
	assert.Contains(t, code, "func (s *Schema) WriteTo(")
	assert.Contains(t, code, "w io.Writer")
	assert.Contains(t, code, "schema.WriteDriver")
}

func TestGenMigrateMigrate_SchemaOptions(t *testing.T) {
	helper := newMockHelper()
	helper.graph.Nodes = []*gen.Type{createTestType("User")}

	file := genMigrateMigrate(helper)
	require.NotNil(t, file)

	code := file.GoString()
	assert.Contains(t, code, "WithGlobalUniqueID")
	assert.Contains(t, code, "WithDropColumn")
	assert.Contains(t, code, "WithDropIndex")
	assert.Contains(t, code, "WithForeignKeys")
}

func TestGenMigrateMigrate_ErrorHandling(t *testing.T) {
	helper := newMockHelper()
	helper.graph.Nodes = []*gen.Type{createTestType("User")}

	file := genMigrateMigrate(helper)
	require.NotNil(t, file)

	code := file.GoString()
	assert.Contains(t, code, "if err != nil")
	assert.Contains(t, code, `fmt.Errorf("velox/migrate: %w", err)`)
	assert.Contains(t, code, "migrate.Create(ctx, tables...)")
}

func TestGenMigrateMigrate_WriteDriverUsage(t *testing.T) {
	helper := newMockHelper()
	helper.graph.Nodes = []*gen.Type{createTestType("User")}

	file := genMigrateMigrate(helper)
	require.NotNil(t, file)

	code := file.GoString()
	assert.Contains(t, code, "schema.WriteDriver{")
	assert.Contains(t, code, "Writer: w")
	assert.Contains(t, code, "Driver: s.drv")
}

// =============================================================================
// Helper Function Tests
// =============================================================================

func TestPascal(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"user", "User"},
		{"post", "Post"},
		{"comment", "Comment"},
		{"", ""},
		{"a", "A"},
		{"User", "User"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			assert.Equal(t, tt.expected, pascal(tt.input))
		})
	}
}

func TestFieldTypeCode(t *testing.T) {
	fieldPkg := "github.com/syssam/velox/schema/field"

	tests := []field.Type{
		field.TypeBool, field.TypeTime, field.TypeJSON, field.TypeUUID,
		field.TypeBytes, field.TypeEnum, field.TypeString, field.TypeInt,
		field.TypeInt64, field.TypeFloat64, field.TypeOther,
		field.TypeInt8, field.TypeInt16, field.TypeInt32,
		field.TypeUint, field.TypeUint8, field.TypeUint16, field.TypeUint32, field.TypeUint64,
		field.TypeFloat32,
	}

	for _, typ := range tests {
		t.Run(typ.String(), func(t *testing.T) {
			code := fieldTypeCode(typ, fieldPkg)
			assert.NotNil(t, code)
		})
	}
}

func TestDeleteAction(t *testing.T) {
	t.Run("optional_edge_defaults_to_SetNull", func(t *testing.T) {
		edge := &gen.Edge{Name: "profile", Optional: true}
		code := deleteAction(edge)
		require.NotNil(t, code)
	})

	t.Run("required_edge_defaults_to_Cascade", func(t *testing.T) {
		edge := &gen.Edge{Name: "author", Optional: false}
		code := deleteAction(edge)
		require.NotNil(t, code)
	})
}

func TestEdgeFKColumn(t *testing.T) {
	t.Run("M2O_edge_generates_FK_column", func(t *testing.T) {
		userType := createTestType("User")
		postType := createTestType("Post")

		edge := &gen.Edge{
			Name: "author", Type: userType, Unique: true,
			Rel: gen.Relation{Type: gen.M2O, Columns: []string{"author_id"}},
		}
		col := edgeFKColumn(edge, postType)
		require.NotNil(t, col)
		assert.Equal(t, "author_id", col.Name)
		assert.Equal(t, field.TypeInt64, col.Type)
		assert.False(t, col.Nullable)
	})

	t.Run("O2M_edge_returns_nil", func(t *testing.T) {
		postType := createTestType("Post")
		edge := &gen.Edge{
			Name: "posts", Type: postType, Unique: false,
			Rel: gen.Relation{Type: gen.O2M},
		}
		col := edgeFKColumn(edge, createTestType("User"))
		assert.Nil(t, col)
	})

	t.Run("optional_edge_nullable_FK", func(t *testing.T) {
		userType := createTestType("User")
		edge := &gen.Edge{
			Name: "author", Type: userType, Unique: true, Optional: true,
			Rel: gen.Relation{Type: gen.M2O, Columns: []string{"author_id"}},
		}
		col := edgeFKColumn(edge, createTestType("Post"))
		require.NotNil(t, col)
		assert.True(t, col.Nullable)
	})

	t.Run("M2M_edge_returns_nil", func(t *testing.T) {
		tagType := createTestType("Tag")
		edge := &gen.Edge{
			Name: "tags", Type: tagType, Unique: false,
			Rel: gen.Relation{Type: gen.M2M},
		}
		col := edgeFKColumn(edge, createTestType("Post"))
		assert.Nil(t, col)
	})
}

func TestGenColumnDict(t *testing.T) {
	fieldPkg := "github.com/syssam/velox/schema/field"

	t.Run("basic_column", func(t *testing.T) {
		col := &schema.Column{Name: "name", Type: field.TypeString}
		dict := genColumnDict(col, fieldPkg)
		require.NotNil(t, dict)
		assert.Len(t, dict, 2)
	})

	t.Run("unique_column", func(t *testing.T) {
		col := &schema.Column{Name: "email", Type: field.TypeString, Unique: true}
		dict := genColumnDict(col, fieldPkg)
		assert.Greater(t, len(dict), 2)
	})

	t.Run("nullable_column", func(t *testing.T) {
		col := &schema.Column{Name: "bio", Type: field.TypeString, Nullable: true}
		dict := genColumnDict(col, fieldPkg)
		assert.Greater(t, len(dict), 2)
	})

	t.Run("enum_column", func(t *testing.T) {
		col := &schema.Column{Name: "status", Type: field.TypeEnum, Enums: []string{"active", "inactive"}}
		dict := genColumnDict(col, fieldPkg)
		assert.Greater(t, len(dict), 2)
	})

	t.Run("column_with_size", func(t *testing.T) {
		col := &schema.Column{Name: "code", Type: field.TypeString, Size: 10}
		dict := genColumnDict(col, fieldPkg)
		assert.Greater(t, len(dict), 2)
	})

	t.Run("column_with_increment", func(t *testing.T) {
		col := &schema.Column{Name: "id", Type: field.TypeInt64, Increment: true}
		dict := genColumnDict(col, fieldPkg)
		assert.Greater(t, len(dict), 2)
	})

	t.Run("column_with_default_string", func(t *testing.T) {
		col := &schema.Column{Name: "role", Type: field.TypeString, Default: "user"}
		dict := genColumnDict(col, fieldPkg)
		assert.Greater(t, len(dict), 2)
	})

	t.Run("column_with_default_int", func(t *testing.T) {
		col := &schema.Column{Name: "age", Type: field.TypeInt, Default: 0}
		dict := genColumnDict(col, fieldPkg)
		assert.Greater(t, len(dict), 2)
	})

	t.Run("column_with_default_bool", func(t *testing.T) {
		col := &schema.Column{Name: "active", Type: field.TypeBool, Default: true}
		dict := genColumnDict(col, fieldPkg)
		assert.Greater(t, len(dict), 2)
	})

	t.Run("column_with_collation", func(t *testing.T) {
		col := &schema.Column{Name: "name", Type: field.TypeString, Collation: "utf8mb4_unicode_ci"}
		dict := genColumnDict(col, fieldPkg)
		assert.Greater(t, len(dict), 2)
	})

	t.Run("column_with_comment", func(t *testing.T) {
		col := &schema.Column{Name: "name", Type: field.TypeString, Comment: "user name"}
		dict := genColumnDict(col, fieldPkg)
		assert.Greater(t, len(dict), 2)
	})

	t.Run("column_with_schema_type", func(t *testing.T) {
		col := &schema.Column{
			Name:       "amount",
			Type:       field.TypeOther,
			SchemaType: map[string]string{"postgres": "DECIMAL(10,2)"},
		}
		dict := genColumnDict(col, fieldPkg)
		assert.Greater(t, len(dict), 2)
	})

	t.Run("column_with_default_expr", func(t *testing.T) {
		col := &schema.Column{
			Name:    "created_at",
			Type:    field.TypeTime,
			Default: schema.Expr("CURRENT_TIMESTAMP"),
		}
		dict := genColumnDict(col, fieldPkg)
		assert.Greater(t, len(dict), 2)
	})
}

func TestFindColumnIndex(t *testing.T) {
	typ := createTestType("User")

	t.Run("id_column", func(t *testing.T) {
		assert.Equal(t, 0, findColumnIndex(typ, "id"))
	})

	t.Run("first_field", func(t *testing.T) {
		assert.Equal(t, 1, findColumnIndex(typ, "name"))
	})

	t.Run("second_field", func(t *testing.T) {
		assert.Equal(t, 2, findColumnIndex(typ, "email"))
	})

	t.Run("third_field", func(t *testing.T) {
		assert.Equal(t, 3, findColumnIndex(typ, "age"))
	})

	t.Run("not_found_returns_zero", func(t *testing.T) {
		assert.Equal(t, 0, findColumnIndex(typ, "nonexistent"))
	})
}

// =============================================================================
// Integration Tests
// =============================================================================

func TestGenMigrate_FullWorkflow(t *testing.T) {
	helper := newMockHelper()
	userType := createTestType("User")
	postType := createTestType("Post")
	postType.Edges = []*gen.Edge{{
		Name: "author", Type: userType, Unique: true,
		Rel: gen.Relation{Type: gen.M2O},
	}}
	helper.graph.Nodes = []*gen.Type{userType, postType}

	var files []*jen.File
	ok := safeGenerate(func() {
		files = genMigrate(helper)
	})
	if !ok {
		t.Skip("genMigrate panicked due to incomplete mock state")
	}
	require.Len(t, files, 2)

	migrateCode := files[1].GoString()
	assert.Contains(t, migrateCode, "type Schema struct")
	assert.Contains(t, migrateCode, "func NewSchema")
	assert.Contains(t, migrateCode, "func (s *Schema) Create")
	assert.Contains(t, migrateCode, "func (s *Schema) WriteTo")
}

// =============================================================================
// Benchmark Tests
// =============================================================================

func BenchmarkGenMigrateMigrate(b *testing.B) {
	helper := newMockHelper()
	helper.graph.Nodes = []*gen.Type{createTestType("User")}
	for b.Loop() {
		_ = genMigrateMigrate(helper)
	}
}

func BenchmarkPascal(b *testing.B) {
	inputs := []string{"user", "post", "comment", "profile", "tag"}
	for b.Loop() {
		for _, input := range inputs {
			_ = pascal(input)
		}
	}
}

// =============================================================================
// genPrimaryKey Tests
// =============================================================================

func TestGenPrimaryKey(t *testing.T) {
	userType := createTestType("User")
	schemaPkgPath := "github.com/syssam/velox/dialect/sql/schema"

	code := genPrimaryKey(userType, "UserColumns", schemaPkgPath)
	assert.NotNil(t, code)

	// Render the code to verify structure
	f := jen.NewFile("test")
	f.Var().Id("pk").Op("=").Add(code)
	output := f.GoString()
	assert.Contains(t, output, "UserColumns")
	assert.Contains(t, output, "schema")
}

// =============================================================================
// genForeignKeysSchema Tests
// =============================================================================

func TestGenForeignKeysSchema_NoEdges(t *testing.T) {
	userType := createTestType("User")
	userType.Edges = nil
	schemaPkgPath := "github.com/syssam/velox/dialect/sql/schema"

	code := genForeignKeysSchema(userType, schemaPkgPath)
	assert.NotNil(t, code)

	f := jen.NewFile("test")
	f.Var().Id("fks").Op("=").Add(code)
	output := f.GoString()
	assert.Contains(t, output, "nil")
}

func TestGenForeignKeysSchema_WithM2OEdge(t *testing.T) {
	userType := createTestType("User")
	postType := createTestType("Post")

	edge := createM2OEdge("author", userType, "posts", "author_id")
	postType.Edges = []*gen.Edge{edge}
	schemaPkgPath := "github.com/syssam/velox/dialect/sql/schema"

	code := genForeignKeysSchema(postType, schemaPkgPath)
	assert.NotNil(t, code)

	f := jen.NewFile("test")
	f.Var().Id("fks").Op("=").Add(code)
	output := f.GoString()
	assert.Contains(t, output, "Symbol")
	assert.Contains(t, output, "fkey")
}

func TestGenForeignKeysSchema_SkipsO2M(t *testing.T) {
	userType := createTestType("User")
	postType := createTestType("Post")

	edge := createO2MEdge("posts", postType, "posts", "user_id")
	userType.Edges = []*gen.Edge{edge}
	schemaPkgPath := "github.com/syssam/velox/dialect/sql/schema"

	code := genForeignKeysSchema(userType, schemaPkgPath)
	assert.NotNil(t, code)

	f := jen.NewFile("test")
	f.Var().Id("fks").Op("=").Add(code)
	output := f.GoString()
	// O2M edges don't own FK, so should be nil
	assert.Contains(t, output, "nil")
}

// =============================================================================
// genIndexesSchema Tests
// =============================================================================

func TestGenIndexesSchema_NoIndexes(t *testing.T) {
	userType := createTestType("User")
	userType.Indexes = nil
	schemaPkgPath := "github.com/syssam/velox/dialect/sql/schema"

	code := genIndexesSchema(userType, schemaPkgPath)
	assert.NotNil(t, code)

	f := jen.NewFile("test")
	f.Var().Id("idxs").Op("=").Add(code)
	output := f.GoString()
	assert.Contains(t, output, "nil")
}

func TestGenIndexesSchema_WithIndexes(t *testing.T) {
	userType := createTestType("User")
	userType.Indexes = []*gen.Index{
		{Name: "user_email", Unique: true, Columns: []string{"email"}},
		{Name: "user_status_name", Unique: false, Columns: []string{"status", "name"}},
	}
	schemaPkgPath := "github.com/syssam/velox/dialect/sql/schema"

	code := genIndexesSchema(userType, schemaPkgPath)
	assert.NotNil(t, code)

	f := jen.NewFile("test")
	f.Var().Id("idxs").Op("=").Add(code)
	output := f.GoString()
	assert.Contains(t, output, "user_email")
	assert.Contains(t, output, "user_status_name")
}

func BenchmarkFieldTypeCode(b *testing.B) {
	fieldPkg := "github.com/syssam/velox/schema/field"
	types := []field.Type{field.TypeString, field.TypeInt, field.TypeInt64, field.TypeBool, field.TypeTime}
	for b.Loop() {
		for _, typ := range types {
			_ = fieldTypeCode(typ, fieldPkg)
		}
	}
}
